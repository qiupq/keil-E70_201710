/* ---------------------------------------------------------------------------- */
/*                  Atmel Microcontroller Software Support                      */
/*                       SAM Software Package License                           */
/* ---------------------------------------------------------------------------- */
/* Copyright (c) 2015, Atmel Corporation                                        */
/*                                                                              */
/* All rights reserved.                                                         */
/*                                                                              */
/* Redistribution and use in source and binary forms, with or without           */
/* modification, are permitted provided that the following condition is met:    */
/*                                                                              */
/* - Redistributions of source code must retain the above copyright notice,     */
/* this list of conditions and the disclaimer below.                            */
/*                                                                              */
/* Atmel's name may not be used to endorse or promote products derived from     */
/* this software without specific prior written permission.                     */
/*                                                                              */
/* DISCLAIMER:  THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR   */
/* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF */
/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE   */
/* DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,      */
/* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT */
/* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,  */
/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF    */
/* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING         */
/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, */
/* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                           */
/* ---------------------------------------------------------------------------- */

/**
 *  \page usart_hw_handshaking USART Hardware Handshaking Example
 *
 *  \section Purpose
 *
 *  This example demonstrates the hardware handshaking mode (i.e. RTS/CTS)
 *  provided by the USART peripherals on SAMV7/E7 microcontrollers. The practical
 *  use of hardware handshaking is that it allows to stop transfer on the USART
 *  without losing any data in the process. This is very useful for applications
 *  that need to program slow memories for example.
 *
 *  \section Requirements
 *
 *  This package can be used with SAMV71 Xplained Ultra board or SAME70 Xplained board.
 *  It requires a fly some serial lines with hardware control support( TXD and
 *  RXD cross over,
 *  RTS and CTS cross over) to connect the PINs and PC.
 *  Connection:
 *     USART0 CTS0 (D39)
 *     USART0 RTS0 (D40)
 *     USART0 RXD0 (D14)
 *     USART0 TXD0 (D15)
 *
 *  \section Description
 *
 *  The provided program uses hardware handshaking mode to regulate the data
 *  rate of an incoming file transfer. A terminal application, such as
 *  hyper-terminal, is used to send a text file to the device (without any
 *  protocol such as X-modem). The device will enforce the configured
 *  bytes per second (bps) rate with its Request To Send (RTS) line.
 *
 *  Whenever the data rate meet or exceed the configurable threshold, the device
 *  stops receiving data on the USART. Since no buffer is provided to the XDMA,
 *  this will set the RTS line, telling the computer to stop sending data. Each
 *  second, the current data rate and total number of bytes received are
 *  displayed; the transfer is also restarted.
 *
 *  Note that the device may receive slightly less bytes than the actual file
 *  size, depending on the nature of the file. This does NOT mean that bytes
 *  have been lost: this is simply an issue with how line breaks are transmitted
 *  by the terminal. It is therefore better to use binary files, as they most
 *  often do not contain line breaks. For example, send one of the object files
 *  generated by the compiler.
 *
 *  \section Usage
 *
 *  -# Build the program and download it inside the board.
 *  Please refer to the Getting Started with SAM V71/E70 Microcontrollers.pdf
 *  -# Connect a serial cable to a USART port on the evaluation kit.
 *  -# On the computer, open and configure a terminal application (e.g.
 *     HyperTerminal on Microsoft Windows) with these settings:
 *        - 115200 baud rates
 *        - 8 data bits
 *        - No parity
 *        - 1 stop bit
 *        - Hardware flow control (RTS/CTS)
 *  -# Start the application. The following traces shall appear on the debug
 * terminal:
 *     \code
 *     -- USART Hardware Handshaking Example xxx --
 *     -- SAMxxxxx-xx
 *     -- Compiled: xxx xx xxxx xx:xx:xx --
 *     -I- Configure system tick to get 1ms tick period.
*      -I- Please send a file to serial port (USART0)
 *     Total bytes received 0x0
 *     \endcode
 *  -# Send a file in text format to the device. On HyperTerminal, this is done
 *     by selecting "Transfer -> Send Text File" (this does not prevent you from
 *     sending binary files). The transfer will start and the device will update
 *     the bytes received counter on the terminal.
 *  -# Whenever the transfer is complete, the total number of bytes received
 *     should match the size of the sent file (unless it is a text file, see
 *     explanation in description section).
 *
 *  \section References
 *  - usart_hw_handshaking/main.c
 *  - pio.h
 *  - usart_dma.h
 *  - usart.h
 */

/** \file
 *
 *  This file contains all the specific code for the usart_hw_handshaking.
 */

/*------------------------------------------------------------------------------
 *         Headers
 *-----------------------------------------------------------------------------*/

#include "board.h"
#include "..\..\..\..\utils\utility.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "..\..\..\..\utils\md5\md5.h"
/*------------------------------------------------------------------------------
 *         Local definition
 *-----------------------------------------------------------------------------*/

//#define USE_MD5_CHECK
#define FULL_DUPLEX
/** Size of the receive buffer used by the DMA, in bytes.*/
#define BUFFER_SIZE         128

/** Pins for USART */
#define PINS_USART          PIN_USART0_TXD, PIN_USART0_RXD, PIN_USART0_RTS, PIN_USART0_CTS

/** Register base for USART */
#define BASE_USART          USART0

/** Register base for USART */
#define BASE_USART_IRQ      USART0_IRQn

/** ID for USART */
#define ID_USART           ID_USART0

#define USART_Interrupt    USART0_Handler

#define USART_TX_TIMEOUT   5000    // 5 seconds


/* USART DMA LLI size ---- should not be less than 2*/
#define USART_DMA_LLI      10

#define APP_BUFFER         ( 100*1024)                          // 100 KB
#define RX_BUFFER          ( BUFFER_SIZE * USART_DMA_LLI )      // RingBuffer's Size
#define MIN_FREE_BYTES     ( BUFFER_SIZE * (USART_DMA_LLI-1) )  // min free bytes in ring buffer
#define MAX_FREE_BYTES     ( BUFFER_SIZE * (USART_DMA_LLI-2) )  // min free bytes in ring buffer

#define XDMA_NVIC_PRIO     1
#define USART_NVIC_PRIO    3
#define TC_NVIC_PRIO       4

#ifdef USE_MD5_CHECK
static md5_state_t pms;
static uint8_t md5[16];
#endif

/*------------------------------------------------------------------------------
 *          Type
 * ----------------------------------------------------------------------------*/
 /* RingBuffer structure */
COMPILER_PACK_SET(4)
typedef struct
{
	uint8_t               *pBuffer;       /* RingBuffer's data buffer */
	const uint8_t         reserved[3];    /* reserved */
	uint32_t              BuffSize;       /* RinBuffer's Size */
	volatile uint32_t     Count;          /* Unread bytes in buffer */
	volatile uint32_t     *pHead;         /* Head pointer of buffer */
	uint32_t              pTail;          /* Tail pointer of buffer */
}RignBuffer_t;
COMPILER_PACK_RESET()

/*------------------------------------------------------------------------------
 *          Local variables
 * ----------------------------------------------------------------------------*/
/** Global DMA driver for all transfer */
static sXdmad ChDma;

static UsartDma Usartd;
static UsartChannel UsartTx, UsartRx;


/**  Pins to configure for the application.*/
const Pin pins[] = {PINS_USART};

/**  Number of bytes received between two timer ticks.*/
volatile uint32_t mutexTimeout;
volatile uint8_t semaphore = 0;
volatile uint32_t dmaflush = 0;
static uint32_t TotalbytesReceived = 0;
static uint8_t PingPongBufferFlag = 0;
volatile uint32_t TimeOutTimer = 0;

//uint8_t __attribute__((at(0x20448c94))) pRxBuffer[RX_BUFFER];
//volatile uint32_t __attribute__((at(0x20448c94+RX_BUFFER))) dmaflush = 0;

/**  Ring buffer */
COMPILER_ALIGNED(32) uint8_t pRxBuffer[RX_BUFFER];

/**  Application Rx buffer.*/
COMPILER_ALIGNED(32) uint8_t FirstAppBuff[APP_BUFFER];
COMPILER_ALIGNED(32) uint8_t SecondAppBuff[APP_BUFFER];

COMPILER_WORD_ALIGNED RignBuffer_t *pUsartBuffer;

static void _DmaRxCallback(uint8_t status, void* pArg);

/*----------------------------------------------------------------------------
 *         Local functions
 *----------------------------------------------------------------------------*/
#ifdef FULL_DUPLEX
__STATIC_INLINE void _UpdateTxConfig(uint32_t Source, uint32_t size)
{
	XDMAC_SetSourceAddr(ChDma.pXdmacs, UsartTx.ChNum, Source);
	XDMAC_SetMicroblockControl(ChDma.pXdmacs, UsartTx.ChNum, size);
}

/**
 *  \brief Callback function for DMA receiving.
 */
static void _DmaTxCallback(uint8_t status, void* pArg)
{
	/*dummy*/
	status = status;
	pArg = pArg;

	UsartTx.dmaProgress = 1;
	if (PingPongBufferFlag)
		_UpdateTxConfig((uint32_t)&SecondAppBuff[0], APP_BUFFER);
	else
	_UpdateTxConfig((uint32_t)&FirstAppBuff[0], APP_BUFFER);
}

/**
 * \brief Send the rest of the data in buffer if it is less than 100KB
*/
__STATIC_INLINE void FlushTxBuffer(uint32_t TxBytesLeft)
{
	if (PingPongBufferFlag)
		_UpdateTxConfig((uint32_t)&SecondAppBuff[0], TxBytesLeft);
	else
		_UpdateTxConfig((uint32_t)&FirstAppBuff[0], TxBytesLeft);
	USARTD_SendData(&Usartd);
	while (!UsartTx.dmaProgress);
}

#endif
/**
* \brief This function updates the Count variable of ring buffer
**/
__STATIC_INLINE void _UpdateCount(void)
{
	/* check if there is detain ring buffer  */
	if (pUsartBuffer->pTail != *pUsartBuffer->pHead) {
		if (pUsartBuffer->pTail > *pUsartBuffer->pHead)
			pUsartBuffer->Count = (pUsartBuffer->BuffSize -
				(pUsartBuffer->pTail % *pUsartBuffer->pHead));
		else
			pUsartBuffer->Count = (*pUsartBuffer->pHead % pUsartBuffer->pTail);
	}
	memory_barrier();
	TRACE_DEBUG("COUNT is %d \n\r",pUsartBuffer->Count);
}

/**
 * ISR for XDMA interrupt
 */
void XDMAC_Handler(void)
{
	XDMAD_Handler(&ChDma);
}

/**
 *  \brief USART interrupt routine to serve Timeout interrupts from USART
 */
void USART_Interrupt(void)
{
	if (BASE_USART->US_CSR & US_CSR_TIMEOUT) {
		/* calculate the number of bytes in circular buffer */
		USART_AcknowledgeRxTimeOut(BASE_USART, 0);
		/* Flush the DMA FIFO */
		BASE_USART->US_CR = US_CR_RTSEN;
		XDMAC_SoftwareFlushReq(ChDma.pXdmacs, UsartRx.ChNum);
		dmaflush++;
		TRACE_DEBUG(" Time out \n\r");
	}
}

/**
 *  \brief Callback function for DMA receiving.
 */
static void _DmaRxCallback( uint8_t status, void* pArg )
{
	/*dummy*/
	status = status;
	pArg = pArg;

	mutexTimeout = 0x7FF;
	while (LockMutex(semaphore, mutexTimeout)); // lock semaphore
	_UpdateCount();
	SCB_InvalidateDCache_by_Addr((uint32_t *)pRxBuffer,sizeof(pRxBuffer));
	if (__LDREXW(&pUsartBuffer->Count) >= MAX_FREE_BYTES) {
		/* Send signal to Tx side to stop sending data after filling all
		 * except one block of buffer
		 */
		BASE_USART->US_CR = US_CR_RTSEN;
	}
	ReleaseMutex(semaphore);
}

/**
 * \brief Initialize circular buffer
*/
__STATIC_INLINE void _initCircularBuffer(RignBuffer_t *pBuff)
{
	pBuff->pBuffer = &pRxBuffer[0];
	pBuff->BuffSize = RX_BUFFER;
	pBuff->pTail = (uint32_t )pRxBuffer;
	// point Head pointer of buffer to Destination address of DMA
	pBuff->pHead = &ChDma.pXdmacs->XDMAC_CHID[UsartRx.ChNum].XDMAC_CDA;
	pBuff->Count = 0;
}

/**
 *  \brief USART hardware handshaking configuration
 *
 * Configures USART in hardware handshaking mode, asynchronous, 8 bits, 1 stop
 * bit, no parity, 115200 baud rates and enables its transmitter and receiver.
 */
__STATIC_INLINE void _ConfigureUsart(uint32_t baudrate, uint32_t rxTimeout)
{
	uint32_t mode = 0
				| US_MR_USART_MODE_HW_HANDSHAKING
				| US_MR_USCLKS_MCK
				| US_MR_CHRL_8_BIT
				| US_MR_PAR_NO
				| US_MR_NBSTOP_1_BIT
				| US_MR_CHMODE_NORMAL;

	/* Reset the Tx and Rx Channel */
	memset(&UsartTx, 0, sizeof(UsartChannel));
	memset(&UsartRx, 0, sizeof(UsartChannel));

	/* Initialize the Rx DMA channel of USART*/
	UsartRx.BuffSize= BUFFER_SIZE;
	UsartRx.pBuff = pRxBuffer;
	UsartRx.callback = _DmaRxCallback;
	UsartRx.dmaProgrammingMode = XDMAD_LLI;
	UsartRx.dmaBlockSize = USART_DMA_LLI;
	UsartRx.dmaRingBuffer = 1;
	UsartRx.dmaProgress = 1;

	/* Initialize the Rx DMA channel of USART*/
#ifdef FULL_DUPLEX
	UsartTx.BuffSize= APP_BUFFER;
	UsartTx.pBuff = FirstAppBuff;
	UsartTx.callback = _DmaTxCallback;
	UsartTx.dmaProgrammingMode = XDMAD_SINGLE;
	UsartTx.dmaBlockSize =  0;
	UsartTx.dmaRingBuffer = 0;
#endif
	UsartTx.dmaProgress = 1;

	Usartd.pXdmad = &ChDma;
	Usartd.pRxChannel = &UsartRx;
	Usartd.pTxChannel = &UsartTx;
	USARTD_Configure(&Usartd, ID_USART, mode, baudrate, BOARD_MCK);

	NVIC_ClearPendingIRQ(BASE_USART_IRQ);
	NVIC_SetPriority( BASE_USART_IRQ , USART_NVIC_PRIO);

	USART_EnableIt(BASE_USART, US_IER_TIMEOUT);

	NVIC_EnableIRQ(BASE_USART_IRQ);
	USART_EnableRecvTimeOut( BASE_USART, rxTimeout);
	TRACE_INFO("Baudrate is set to %u and TimeOut is %f Sec",
			(unsigned)baudrate, (float)((float)rxTimeout / baudrate));
}

/**
* \brief Ring buffer management
* This function copies data from ring buffer to application buffer with a given length.
* \param pBuff          Usart Rx DMA ring buffer
* \param pDestination   Usart application buffer
* \param Len            Num of dat to copy from ring buffer
* \return function returns number of bytes read from ringbuffer
*
*/
static uint32_t RingBufferRead(RignBuffer_t *pBuff, uint8_t *pDestination, uint32_t Len)
{
	uint32_t EndAddrs = ((uint32_t)pBuff->pBuffer + pBuff->BuffSize);
	uint32_t UnreadCount = 0;
	uint32_t EnableRTS = 0;
	uint32_t TotalLen = 0;
	uint32_t TailAddrs, BytesLeft;

	/* If timeout has occurred then re calculate the unread number of bytes */
	if (dmaflush) {
		mutexTimeout = 0x7FF;
		BASE_USART->US_CR = US_CR_RTSEN;            // disable transmission
		__disable_irq();
		while (LockMutex(semaphore, mutexTimeout));           // lock mutex
		_UpdateCount();
		/* If Circular buffer has still free space to fill */
		if (pBuff->Count < MAX_FREE_BYTES)
			EnableRTS = US_CR_RTSDIS;
		dmaflush = 0;
		memory_sync();
		ReleaseMutex(semaphore);
		BASE_USART->US_CR = EnableRTS;
		__enable_irq();
	}

	/* If there are unread bytes in ringbuffer then copy them to application
		buffer */
	if (pBuff->Count) {
		UnreadCount = __LDREXW(&pBuff->Count);          // unread bytes count
		memory_barrier();
		TotalLen = (Len > UnreadCount) ? UnreadCount : Len;

		// if read length surpasses the ring buffer boundary, then loop over
		if ((pBuff->pTail + TotalLen) >= EndAddrs) {
			BytesLeft = (EndAddrs - pBuff->pTail);
			memcpy( pDestination , (uint32_t *)pBuff->pTail, BytesLeft );

			memcpy( (pDestination +(EndAddrs - pBuff->pTail)),
				(uint32_t *)(pBuff->pBuffer), TotalLen - BytesLeft);
			TailAddrs = ( (uint32_t)pBuff->pBuffer + (TotalLen - BytesLeft));
		} else {
			memcpy( pDestination , (uint32_t *)pBuff->pTail, TotalLen);
			TailAddrs = pBuff->pTail + TotalLen;
		}
		/* In this part function enable the RTS signal to stop all reception
		disable irq to enter in critical part gets a lock on semaphore
		updates Tail pointer and count of ring buffer
		check if RTS need to be disable to accept the data from host
		frees the semaphore and enable irq*/
		BASE_USART->US_CR = US_CR_RTSEN;            // disable transmission
		__disable_irq();
		mutexTimeout = 0x7FF;
		while (LockMutex(semaphore, mutexTimeout));  // lock mutex
		pBuff->pTail = TailAddrs;
		pBuff->Count -=TotalLen;                   // update count of ring buffer
		TotalbytesReceived +=TotalLen;
		memory_sync();
#ifdef FULL_DUPLEX
		TimeOutTimer = GetTicks();
#endif
		/* If Circular buffer is read completely */
		if (pUsartBuffer->Count < MAX_FREE_BYTES)
			EnableRTS = US_CR_RTSDIS;
		ReleaseMutex(semaphore);
		BASE_USART->US_CR = EnableRTS;
		__enable_irq();

		printf("\r Total bytes received 0x%x (%u)", \
			(unsigned)TotalbytesReceived, (unsigned)TotalbytesReceived);

		return TotalLen;      // return the number of bytes
	} else
		return 0;
}


/*------------------------------------------------------------------------------*/
/*         Global functions                                                     */
/*------------------------------------------------------------------------------*/

/**
 *  \brief usart-hw-handshaking Application entry point..
 *
 *  Configures USART in hardware handshaking mode and
 *  Timer Counter 0 to generate an interrupt every second. Then, start the first
 *  transfer on the USART and wait in an endless loop.
 *
 *  \return Unused (ANSI-C compatibility).
 */
int main( void )
{
	char pbaud_time[8];
	uint32_t BytesRead, BytesToRead, baudrate, timeout, TxBytesLeft;
	uint8_t AppBufferRollOver = 0;
	uint8_t *pTxBuff;

	/* Disable watchdog*/
	WDT_Disable(WDT);

	printf("-- USART Hardware Handshaking Example %s --\n\r", SOFTPACK_VERSION);
	printf("-- %s\n\r", BOARD_NAME);
	printf("-- Compiled: %s %s With %s--\n\r", __DATE__, __TIME__, COMPILER_NAME);

	/* Enable I and D cache */
	SCB_EnableICache();
	SCB_EnableDCache();

	/* Configure USART pins*/
	PIO_Configure(pins, PIO_LISTSIZE(pins));

	/* Configure systick for 1 ms. */
	TimeTick_Configure();

	NVIC_SetPriority(XDMAC_IRQn , XDMA_NVIC_PRIO);


	printf("\n\rEnter required baudrate:");
	gets(pbaud_time);
	baudrate = (atoi(pbaud_time)) ? (atoi(pbaud_time)): 921600;
	printf("\n\rEnter required timeout (in microsec):");
	gets(pbaud_time);

	timeout = atoi(pbaud_time);
	if (timeout > 1000) {
		timeout /= 1000;
		timeout = ((timeout * baudrate) / 1000);
	} else {
		timeout = (timeout * baudrate) / 1000000;
	}
	timeout = (timeout) ? ((timeout > MAX_RX_TIMEOUT) ? MAX_RX_TIMEOUT : timeout) \
		: MAX_RX_TIMEOUT;
	printf("\n\r");
	/* Configure USART */
	_ConfigureUsart(baudrate, timeout);
	printf("\n\r");

	/*Enable Rx channel of USART */
	USARTD_EnableRxChannels(&Usartd, &UsartRx);

#ifdef FULL_DUPLEX
	/*Enable Tx channel of USART */
	USARTD_EnableTxChannels(&Usartd, &UsartTx);
#endif

	/* Start receiving data and start timer*/
	USARTD_RcvData(&Usartd);

	/*Initialize Ring buffer */
	pUsartBuffer = (RignBuffer_t *)malloc(sizeof(RignBuffer_t));
	_initCircularBuffer(pUsartBuffer);

	pTxBuff = &FirstAppBuff[0];

	TxBytesLeft = 0;

#ifdef USE_MD5_CHECK
	md5_init(&pms);
#endif //USE_MD5_CHECK

#ifdef FULL_DUPLEX
	printf( "\n\r-I- USART is in Full Duplex mode \n\r");
#else
	printf( "\n\r-I- USART is in Half Duplex mode \n\r");
#endif
	printf( "\n\r-I- Please send a file to serial port (USART0) \n\r");
	BytesToRead = MIN_FREE_BYTES; // Bytes to read from ring-buffer

	while (1) {
#ifdef USE_MD5_CHECK
		if (DBG_IsRxReady()) {
			ch = DBG_GetChar();
			if (ch == 'm') {
				uint8_t i;
				md5_finish(&pms, md5);
				printf("\r\nmd5:");
				for (i = 0; i < sizeof(md5);i++)
					printf("%.2x",md5[i]);
				printf("\r\n");
				md5_init(&pms);
				TotalbytesReceived = 0;
			}
		}
#endif
		/* Check Application buffer (100 KB)overflow */
		if (((PingPongBufferFlag == 0) &&
			(pTxBuff+BytesToRead) >= &FirstAppBuff[APP_BUFFER]) ||
			(( PingPongBufferFlag == 1) && (pTxBuff+BytesToRead) >=
			&SecondAppBuff[APP_BUFFER])) {
			AppBufferRollOver = 1;
			// Roll over and start copying to the beginning of Application buffer to avoid errors
			if (PingPongBufferFlag)
				BytesToRead = (&SecondAppBuff[APP_BUFFER] - pTxBuff);
			else
				BytesToRead = (&FirstAppBuff[APP_BUFFER] - pTxBuff);
			memory_barrier();
		}
		/* Read ring buffer */
		BytesRead = RingBufferRead(pUsartBuffer, pTxBuff, BytesToRead);
		memory_sync();
		TxBytesLeft += BytesRead;       // number of bytes to send via USART Tx

#ifdef USE_MD5_CHECK
		if (BytesRead > 0)
			md5_append(&pms,pTxBuff,BytesRead);
#endif

		/* check if one of the application buffer is full and ready to send */
		if (AppBufferRollOver && (TxBytesLeft == APP_BUFFER)) {
			AppBufferRollOver = 0;
			TxBytesLeft = 0;
			BytesRead = 0;
			BytesToRead = MIN_FREE_BYTES; // Bytes to read from ring-buffer
			while (!UsartTx.dmaProgress);
			if (PingPongBufferFlag) {
				PingPongBufferFlag = 0;
				pTxBuff = &FirstAppBuff[0];
			} else {
				PingPongBufferFlag = 1;
				pTxBuff = &SecondAppBuff[0];
			}
			memory_sync();
#ifdef FULL_DUPLEX
			USARTD_SendData(&Usartd);
#endif
		}
		/* otherwise keep storing in same application buffer from Rx DMA's ring
			buffer */
		else {
			BytesToRead = MIN_FREE_BYTES; // Bytes to read from ring-buffer
			pTxBuff += BytesRead;

#ifdef FULL_DUPLEX
			/* Check for Tx timeout, if there is timeout then send the bytes left
				(less than 100 KB) in application buffer */
			if ((GetDelayInTicks(TimeOutTimer, GetTicks()) == USART_TX_TIMEOUT)
				&& TxBytesLeft) {
				// wait for any eventual USART Tx in progress
				while (!UsartTx.dmaProgress);
				FlushTxBuffer(TxBytesLeft);
				TimeOutTimer = GetTicks();
				PingPongBufferFlag = 0;
				TxBytesLeft = 0;
				BytesRead = 0;
				BytesToRead = MIN_FREE_BYTES; // Bytes to read from ring-buffer
				pTxBuff = &FirstAppBuff[0];
				_UpdateTxConfig((uint32_t)&FirstAppBuff[0], APP_BUFFER);
				TRACE_INFO_WP(" TX Tiemout \n\r");
			}
#endif
		}
	}
}
/** \endcond */
