<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SAME70 Xplained Software Package: libraries/liblwip/source/lwip_1.3.2/src/core/tcp.c File Reference</title>
<link href="common/style.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
    <div id="body">
        <div id="title">  SAME70 Xplained Software Package 1.5</div>
        <div id="banner"></div>

<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="dir_81818f1c1b01098ad6d8389f2aaf9f72.html">libraries</a>      </li>
      <li><a class="el" href="dir_f9d6af8b0767ec29e003eb404f55b2ba.html">liblwip</a>      </li>
      <li><a class="el" href="dir_a4b90551bcebf72d44580c734ab11c86.html">source</a>      </li>
      <li><a class="el" href="dir_7fff4700eae15a55204f316974611e6c.html">lwip_1.3.2</a>      </li>
      <li><a class="el" href="dir_6c5a4da2b38a7354841e985f92489e70.html">src</a>      </li>
      <li><a class="el" href="dir_edf09da46bb12db6367452bd0397000e.html">core</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>tcp.c File Reference</h1>  </div>
</div>
<div class="contents">
<code>#include &quot;<a class="el" href="opt_8h_source.html">lwip/opt.h</a>&quot;</code><br/>
<code>#include &quot;lwip/def.h&quot;</code><br/>
<code>#include &quot;lwip/mem.h&quot;</code><br/>
<code>#include &quot;lwip/memp.h&quot;</code><br/>
<code>#include &quot;lwip/snmp.h&quot;</code><br/>
<code>#include &quot;lwip/tcp.h&quot;</code><br/>
<code>#include &quot;lwip/debug.h&quot;</code><br/>
<code>#include &quot;lwip/stats.h&quot;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>

<p><a href="tcp_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae26970fd4b14a155c7708360fd7f1685"></a><!-- doxytag: member="tcp.c::TCP_LOCAL_PORT_RANGE_START" ref="ae26970fd4b14a155c7708360fd7f1685" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>TCP_LOCAL_PORT_RANGE_START</b>&nbsp;&nbsp;&nbsp;4096</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71d5febc42e59b1e8c7d5f0799531a89"></a><!-- doxytag: member="tcp.c::TCP_LOCAL_PORT_RANGE_END" ref="a71d5febc42e59b1e8c7d5f0799531a89" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>TCP_LOCAL_PORT_RANGE_END</b>&nbsp;&nbsp;&nbsp;0x7fff</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#a3846a756b13214ed88ea47d0ff8279eb">tcp_tmr</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">err_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#a87093e137fcc53ea82a134a3f5b33623">tcp_close</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#ae4f0f1ca01dbccd680eaa2d8433cd7fe">tcp_abandon</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, int reset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">err_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#a5f7cf3b3975c4d414e91456959f01233">tcp_bind</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, struct <a class="el" href="structip__addr.html">ip_addr</a> *ipaddr, <a class="el" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> port)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#aeff14f321d1eecd0431611f382fcd338">tcp_listen_with_backlog</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="el" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> backlog)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#a6d2c254b779db4e517cb34e41301588d">tcp_update_rcv_ann_wnd</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#abdac0856a52b5789dc897d4c7137ec44">tcp_recved</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="el" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">err_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#ad01b1fc0d4a44b934c75441c73569b81">tcp_connect</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, struct <a class="el" href="structip__addr.html">ip_addr</a> *ipaddr, <a class="el" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> port, err_t(*connected)(void *arg, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *tpcb, err_t err))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#a421fb42ef919018e14ae413adfee9905">tcp_slowtmr</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#abf446b07e52161b8a53cea07bc6c366d">tcp_fasttmr</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#a1f6d5f868cfaf1a4d843f030d61c58ae">tcp_segs_free</a> (struct <a class="el" href="structtcp__seg.html">tcp_seg</a> *seg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#a404539c2e8a6e38e2d57042225a96b40">tcp_seg_free</a> (struct <a class="el" href="structtcp__seg.html">tcp_seg</a> *seg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#a2c4234f1e95b6bde0e84d4ea97ae95bc">tcp_setprio</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="el" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> prio)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__seg.html">tcp_seg</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#a569d79451d2570e4ef406775725ef6ef">tcp_seg_copy</a> (struct <a class="el" href="structtcp__seg.html">tcp_seg</a> *seg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">err_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#a0cb3f604fc8d20870d8cab291da5701c">tcp_recv_null</a> (void *arg, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, struct <a class="el" href="structpbuf.html">pbuf</a> *p, err_t err)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#a1dd6830a42b3c464b5a72f62ae312d0a">tcp_alloc</a> (<a class="el" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> prio)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#a7427c5d237fe66a8097bfa8d24ceb943">tcp_new</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#ac10926e6f76f73e17c0d37aaab3e56b6">tcp_arg</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, void *arg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#af58be9006b4ddb720113f03d56bc6e52">tcp_recv</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, err_t(*recv)(void *arg, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *tpcb, struct <a class="el" href="structpbuf.html">pbuf</a> *p, err_t err))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#a030f298925f742108af2c85f22ce25da">tcp_sent</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, err_t(*sent)(void *arg, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *tpcb, <a class="el" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> len))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#ab7d51d5a2637ef6c48c7365a269947c1">tcp_err</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, void(*errf)(void *arg, err_t err))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#ae77434b264a469ee4124ff945feac490">tcp_accept</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, err_t(*accept)(void *arg, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *newpcb, err_t err))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#a501ef46b87d7e4784e41c66e4b9aef2c">tcp_poll</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb, err_t(*poll)(void *arg, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *tpcb), <a class="el" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> interval)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#a44fc672b9d14a65e61040707c45302ba">tcp_pcb_purge</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#aaaef096f6a03bf5b778329bb66ee06f6">tcp_pcb_remove</a> (struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> **pcblist, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *pcb)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#af5427fc45c0694592419b03694b95af7">tcp_next_iss</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#add8d3e84e2018e42cc60d8dee2773bd5">tcp_eff_send_mss</a> (<a class="el" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> sendmss, struct <a class="el" href="structip__addr.html">ip_addr</a> *addr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeab91a0537b95a4307ffcdc4b31b55c4"></a><!-- doxytag: member="tcp.c::tcp_debug_state_str" ref="aeab91a0537b95a4307ffcdc4b31b55c4" args="(enum tcp_state s)" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>tcp_debug_state_str</b> (enum tcp_state s)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>tcp_state_str</b> []</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a551543caef1e4d2a5b3368445720262d"></a><!-- doxytag: member="tcp.c::tcp_ticks" ref="a551543caef1e4d2a5b3368445720262d" args="" -->
u32_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>tcp_ticks</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>tcp_backoff</b> [13]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7397dc7a5ac9191a7b44dd1c891c629"></a><!-- doxytag: member="tcp.c::tcp_persist_backoff" ref="ad7397dc7a5ac9191a7b44dd1c891c629" args="[7]" -->
const <a class="el" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>tcp_persist_backoff</b> [7] = { 3, 6, 12, 24, 48, 96, 120 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#a1b42a7ac0fc173a42d575f86853d32a8">tcp_bound_pcbs</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union <a class="el" href="uniontcp__listen__pcbs__t.html">tcp_listen_pcbs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#a96fe1350e510d4308ac9969ffb4c9c81">tcp_listen_pcbs</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#a78c09dbae67ccc06b659d9f1a388f911">tcp_active_pcbs</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tcp_8c.html#a9a522a66c5e1f1a4e28fe7a672cc64e3">tcp_tw_pcbs</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5ba0fd03d297b097808b45437face0c"></a><!-- doxytag: member="tcp.c::tcp_tmp_pcb" ref="ad5ba0fd03d297b097808b45437face0c" args="" -->
struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>tcp_tmp_pcb</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Transmission Control Protocol for IP</p>
<p>This file contains common functions for the TCP implementation, such as functinos for manipulating the data structures and the TCP timer functions. TCP functions related to input and output is found in <a class="el" href="tcp__in_8c.html">tcp_in.c</a> and <a class="el" href="tcp__out_8c.html">tcp_out.c</a> respectively. </p>

<p>Definition in file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ae4f0f1ca01dbccd680eaa2d8433cd7fe"></a><!-- doxytag: member="tcp.c::tcp_abandon" ref="ae4f0f1ca01dbccd680eaa2d8433cd7fe" args="(struct tcp_pcb *pcb, int reset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_abandon </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&nbsp;</td>
          <td class="paramname"> <em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Abandons a connection and optionally sends a RST to the remote host. Deletes the local protocol control block. This is done when a connection is killed because of shortage of memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pcb</em>&nbsp;</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> to abort </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reset</em>&nbsp;</td><td>boolean to indicate whether a reset should be sent </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l00213">213</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="tcp_8c_ae4f0f1ca01dbccd680eaa2d8433cd7fe_cgraph.gif" border="0" usemap="#tcp_8c_ae4f0f1ca01dbccd680eaa2d8433cd7fe_cgraph" alt=""/></div>
<map name="tcp_8c_ae4f0f1ca01dbccd680eaa2d8433cd7fe_cgraph" id="tcp_8c_ae4f0f1ca01dbccd680eaa2d8433cd7fe_cgraph">
<area shape="rect" id="node3" href="memp_8c.html#aecd94926b7c2a0e23ae195f4ae97581f" title="memp_free" alt="" coords="715,85,819,117"/><area shape="rect" id="node5" href="tcp_8c.html#aaaef096f6a03bf5b778329bb66ee06f6" title="tcp_pcb_remove" alt="" coords="172,65,313,97"/><area shape="rect" id="node14" href="tcp_8c.html#a1f6d5f868cfaf1a4d843f030d61c58ae" title="tcp_segs_free" alt="" coords="541,67,667,99"/><area shape="rect" id="node16" href="tcp__out_8c.html#a168fa0bb172bb0bd29bd58e31f804147" title="tcp_rst" alt="" coords="208,261,277,293"/><area shape="rect" id="node7" href="tcp__out_8c.html#a0cbcc6d628f644a530daf629fa3e5f7f" title="tcp_output" alt="" coords="380,65,476,97"/><area shape="rect" id="node9" href="tcp_8c.html#a44fc672b9d14a65e61040707c45302ba" title="tcp_pcb_purge" alt="" coords="363,121,493,153"/><area shape="rect" id="node11" href="pbuf_8c.html#ab0dd696fb4b6bc65e548944584f1738b" title="pbuf_free" alt="" coords="559,207,649,239"/><area shape="rect" id="node18" href="inet_8c.html#aed84a49b499a0d09a1237113b85ad0ab" title="htonl" alt="" coords="400,177,456,209"/><area shape="rect" id="node20" href="group__uipconvfunc.html#gaa22b04cac8cf283ca12f028578bebc06" title="htons" alt="" coords="397,233,459,265"/><area shape="rect" id="node22" href="ip_8c.html#aabccfd6ab4e3c73350c4014158cd4d2b" title="ip_output" alt="" coords="384,289,472,321"/><area shape="rect" id="node24" href="pbuf_8c.html#acfcb0a2af918658ba0afe36499c65f47" title="pbuf_alloc" alt="" coords="380,345,476,377"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae77434b264a469ee4124ff945feac490"></a><!-- doxytag: member="tcp.c::tcp_accept" ref="ae77434b264a469ee4124ff945feac490" args="(struct tcp_pcb *pcb, err_t(*accept)(void *arg, struct tcp_pcb *newpcb, err_t err))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_accept </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&nbsp;</td>
          <td class="paramname"> <em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">err_t(*)(void *arg, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *newpcb, err_t err)&nbsp;</td>
          <td class="paramname"> <em>accept</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Used for specifying the function that should be called when a LISTENing connection has been connected to another host.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pcb</em>&nbsp;</td><td><a class="el" href="structtcp__pcb.html">tcp_pcb</a> to set the accept callback </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>accept</em>&nbsp;</td><td>callback function to call for this pcb when LISTENing connection has been connected to another host </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l01160">1160</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

</div>
</div>
<a class="anchor" id="a1dd6830a42b3c464b5a72f62ae312d0a"></a><!-- doxytag: member="tcp.c::tcp_alloc" ref="a1dd6830a42b3c464b5a72f62ae312d0a" args="(u8_t prio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a>* tcp_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a>&nbsp;</td>
          <td class="paramname"> <em>prio</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a new <a class="el" href="structtcp__pcb.html">tcp_pcb</a> structure.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>prio</em>&nbsp;</td><td>priority for the new pcb </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new <a class="el" href="structtcp__pcb.html">tcp_pcb</a> that initially is in state CLOSED </dd></dl>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l01005">1005</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="tcp_8c_a1dd6830a42b3c464b5a72f62ae312d0a_cgraph.gif" border="0" usemap="#tcp_8c_a1dd6830a42b3c464b5a72f62ae312d0a_cgraph" alt=""/></div>
<map name="tcp_8c_a1dd6830a42b3c464b5a72f62ae312d0a_cgraph" id="tcp_8c_a1dd6830a42b3c464b5a72f62ae312d0a_cgraph">
<area shape="rect" id="node3" href="memp_8c.html#a2b00593d086313c267b54a976bf67aa5" title="memp_malloc" alt="" coords="143,5,263,37"/><area shape="rect" id="node5" href="tcp_8c.html#af5427fc45c0694592419b03694b95af7" title="tcp_next_iss" alt="" coords="148,61,257,93"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac10926e6f76f73e17c0d37aaab3e56b6"></a><!-- doxytag: member="tcp.c::tcp_arg" ref="ac10926e6f76f73e17c0d37aaab3e56b6" args="(struct tcp_pcb *pcb, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_arg </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&nbsp;</td>
          <td class="paramname"> <em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Used to specify the argument that should be passed callback functions.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pcb</em>&nbsp;</td><td><a class="el" href="structtcp__pcb.html">tcp_pcb</a> to set the callback argument </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>void pointer argument to pass to callback functions </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l01102">1102</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

</div>
</div>
<a class="anchor" id="a5f7cf3b3975c4d414e91456959f01233"></a><!-- doxytag: member="tcp.c::tcp_bind" ref="a5f7cf3b3975c4d414e91456959f01233" args="(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">err_t tcp_bind </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&nbsp;</td>
          <td class="paramname"> <em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structip__addr.html">ip_addr</a> *&nbsp;</td>
          <td class="paramname"> <em>ipaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a>&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Binds the connection to a local portnumber and IP address. If the IP address is not given (i.e., ipaddr == NULL), the IP address of the outgoing network interface is used instead.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pcb</em>&nbsp;</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> to bind (no check is done whether this pcb is already bound!) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ipaddr</em>&nbsp;</td><td>the local ip address to bind to (use IP_ADDR_ANY to bind to any local address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>the local port to bind to </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ERR_USE if the port is already in use ERR_OK if bound </dd></dl>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l00276">276</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

</div>
</div>
<a class="anchor" id="a87093e137fcc53ea82a134a3f5b33623"></a><!-- doxytag: member="tcp.c::tcp_close" ref="a87093e137fcc53ea82a134a3f5b33623" args="(struct tcp_pcb *pcb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">err_t tcp_close </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&nbsp;</td>
          <td class="paramname"> <em>pcb</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Closes the connection held by the PCB.</p>
<p>Listening pcbs are freed and may not be referenced any more. Connection pcbs are freed if not yet connected and may not be referenced any more. If a connection is established (at least SYN received or in a closing state), the connection is closed, and put in a closing state. The pcb is then automatically freed in <a class="el" href="tcp_8c.html#a421fb42ef919018e14ae413adfee9905">tcp_slowtmr()</a>. It is therefore unsafe to reference it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pcb</em>&nbsp;</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> to close </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ERR_OK if connection has been closed another err_t if closing failed and pcb is not freed </dd></dl>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l00127">127</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="tcp_8c_a87093e137fcc53ea82a134a3f5b33623_cgraph.gif" border="0" usemap="#tcp_8c_a87093e137fcc53ea82a134a3f5b33623_cgraph" alt=""/></div>
<map name="tcp_8c_a87093e137fcc53ea82a134a3f5b33623_cgraph" id="tcp_8c_a87093e137fcc53ea82a134a3f5b33623_cgraph">
<area shape="rect" id="node3" href="memp_8c.html#aecd94926b7c2a0e23ae195f4ae97581f" title="memp_free" alt="" coords="739,32,843,64"/><area shape="rect" id="node5" href="tcp__out_8c.html#a0cbcc6d628f644a530daf629fa3e5f7f" title="tcp_output" alt="" coords="353,58,449,90"/><area shape="rect" id="node14" href="tcp_8c.html#aaaef096f6a03bf5b778329bb66ee06f6" title="tcp_pcb_remove" alt="" coords="145,112,287,144"/><area shape="rect" id="node19" href="tcp__out_8c.html#ac8e4dca2a2e04c5073f09901742d1146" title="tcp_send_ctrl" alt="" coords="157,169,275,201"/><area shape="rect" id="node7" href="inet_8c.html#ab3ef2c882ab42295feaa7cd7d5ca8b34" title="ntohl" alt="" coords="575,144,631,176"/><area shape="rect" id="node9" href="tcp_8c.html#a404539c2e8a6e38e2d57042225a96b40" title="tcp_seg_free" alt="" coords="544,32,661,64"/><area shape="rect" id="node12" href="tcp__out_8c.html#aefde3e34b2cc8df9654986484c44a996" title="tcp_send_empty_ack" alt="" coords="515,88,691,120"/><area shape="rect" id="node17" href="tcp_8c.html#a44fc672b9d14a65e61040707c45302ba" title="tcp_pcb_purge" alt="" coords="336,114,467,146"/><area shape="rect" id="node21" href="tcp__out_8c.html#a94dcf0b53c8a8e627c14b5cb01836bdb" title="tcp_enqueue" alt="" coords="344,170,459,202"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ad01b1fc0d4a44b934c75441c73569b81"></a><!-- doxytag: member="tcp.c::tcp_connect" ref="ad01b1fc0d4a44b934c75441c73569b81" args="(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port, err_t(*connected)(void *arg, struct tcp_pcb *tpcb, err_t err))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">err_t tcp_connect </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&nbsp;</td>
          <td class="paramname"> <em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structip__addr.html">ip_addr</a> *&nbsp;</td>
          <td class="paramname"> <em>ipaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a>&nbsp;</td>
          <td class="paramname"> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">err_t(*)(void *arg, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *tpcb, err_t err)&nbsp;</td>
          <td class="paramname"> <em>connected</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Connects to another host. The function given as the "connected" argument will be called when the connection has been established.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pcb</em>&nbsp;</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> used to establish the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ipaddr</em>&nbsp;</td><td>the remote ip address to connect to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>the remote tcp port to connect to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>connected</em>&nbsp;</td><td>callback function to call when connected (or on error) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ERR_VAL if invalid arguments are given ERR_OK if connect request has been sent other err_t values if connect request couldn't be sent </dd></dl>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l00514">514</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="tcp_8c_ad01b1fc0d4a44b934c75441c73569b81_cgraph.gif" border="0" usemap="#tcp_8c_ad01b1fc0d4a44b934c75441c73569b81_cgraph" alt=""/></div>
<map name="tcp_8c_ad01b1fc0d4a44b934c75441c73569b81_cgraph" id="tcp_8c_ad01b1fc0d4a44b934c75441c73569b81_cgraph">
<area shape="rect" id="node3" href="tcp_8c.html#add8d3e84e2018e42cc60d8dee2773bd5" title="tcp_eff_send_mss" alt="" coords="165,135,320,167"/><area shape="rect" id="node7" href="tcp__out_8c.html#a94dcf0b53c8a8e627c14b5cb01836bdb" title="tcp_enqueue" alt="" coords="185,320,300,352"/><area shape="rect" id="node39" href="tcp_8c.html#af5427fc45c0694592419b03694b95af7" title="tcp_next_iss" alt="" coords="188,376,297,408"/><area shape="rect" id="node41" href="tcp__out_8c.html#a0cbcc6d628f644a530daf629fa3e5f7f" title="tcp_output" alt="" coords="195,567,291,599"/><area shape="rect" id="node5" href="ip_8c.html#a27aecc05841bdece5d6bed810cc0ce71" title="ip_route" alt="" coords="416,5,496,37"/><area shape="rect" id="node9" href="inet_8c.html#aed84a49b499a0d09a1237113b85ad0ab" title="htonl" alt="" coords="623,539,679,571"/><area shape="rect" id="node11" href="group__uipconvfunc.html#gaa22b04cac8cf283ca12f028578bebc06" title="htons" alt="" coords="425,112,487,144"/><area shape="rect" id="node13" href="memp_8c.html#aecd94926b7c2a0e23ae195f4ae97581f" title="memp_free" alt="" coords="928,353,1032,385"/><area shape="rect" id="node15" href="memp_8c.html#a2b00593d086313c267b54a976bf67aa5" title="memp_malloc" alt="" coords="759,192,879,224"/><area shape="rect" id="node17" href="inet_8c.html#ab3ef2c882ab42295feaa7cd7d5ca8b34" title="ntohl" alt="" coords="428,539,484,571"/><area shape="rect" id="node20" href="pbuf_8c.html#acfcb0a2af918658ba0afe36499c65f47" title="pbuf_alloc" alt="" coords="603,219,699,251"/><area shape="rect" id="node23" href="pbuf_8c.html#ab0dd696fb4b6bc65e548944584f1738b" title="pbuf_free" alt="" coords="773,353,864,385"/><area shape="rect" id="node26" href="pbuf_8c.html#a82429084fe29015509c9b4a072707cd4" title="pbuf_cat" alt="" coords="413,320,499,352"/><area shape="rect" id="node28" href="pbuf_8c.html#a949a13a7cfdf9241c9e7b859af1bd15c" title="pbuf_clen" alt="" coords="409,376,503,408"/><area shape="rect" id="node31" href="pbuf_8c.html#a0f81deff4a0e6e8e0ff161a7b9871449" title="pbuf_header" alt="" coords="399,432,513,464"/><area shape="rect" id="node33" href="tcp_8c.html#a1f6d5f868cfaf1a4d843f030d61c58ae" title="tcp_segs_free" alt="" coords="393,651,519,683"/><area shape="rect" id="node35" href="tcp_8c.html#a404539c2e8a6e38e2d57042225a96b40" title="tcp_seg_free" alt="" coords="592,647,709,679"/><area shape="rect" id="node45" href="tcp__out_8c.html#aefde3e34b2cc8df9654986484c44a996" title="tcp_send_empty_ack" alt="" coords="368,595,544,627"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="add8d3e84e2018e42cc60d8dee2773bd5"></a><!-- doxytag: member="tcp.c::tcp_eff_send_mss" ref="add8d3e84e2018e42cc60d8dee2773bd5" args="(u16_t sendmss, struct ip_addr *addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> tcp_eff_send_mss </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a>&nbsp;</td>
          <td class="paramname"> <em>sendmss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structip__addr.html">ip_addr</a> *&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calcluates the effective send mss that can be used for a specific IP address by using ip_route to determin the netif used to send to the address and calculating the minimum of TCP_MSS and that netif's mtu (if set). </p>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l01304">1304</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="tcp_8c_add8d3e84e2018e42cc60d8dee2773bd5_cgraph.gif" border="0" usemap="#tcp_8c_add8d3e84e2018e42cc60d8dee2773bd5_cgraph" alt=""/></div>
<map name="tcp_8c_add8d3e84e2018e42cc60d8dee2773bd5_cgraph" id="tcp_8c_add8d3e84e2018e42cc60d8dee2773bd5_cgraph">
<area shape="rect" id="node3" href="ip_8c.html#a27aecc05841bdece5d6bed810cc0ce71" title="ip_route" alt="" coords="209,5,289,37"/><area shape="rect" id="node5" href="netif_8c.html#a27f5900eaf1a19d9ce2b7517d480b4d3" title="netif_is_up" alt="" coords="339,5,440,37"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab7d51d5a2637ef6c48c7365a269947c1"></a><!-- doxytag: member="tcp.c::tcp_err" ref="ab7d51d5a2637ef6c48c7365a269947c1" args="(struct tcp_pcb *pcb, void(*errf)(void *arg, err_t err))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_err </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&nbsp;</td>
          <td class="paramname"> <em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *arg, err_t err)&nbsp;</td>
          <td class="paramname"> <em>errf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Used to specify the function that should be called when a fatal error has occured on the connection.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pcb</em>&nbsp;</td><td><a class="el" href="structtcp__pcb.html">tcp_pcb</a> to set the err callback </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>errf</em>&nbsp;</td><td>callback function to call for this pcb when a fatal error has occured on the connection </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l01145">1145</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

</div>
</div>
<a class="anchor" id="abf446b07e52161b8a53cea07bc6c366d"></a><!-- doxytag: member="tcp.c::tcp_fasttmr" ref="abf446b07e52161b8a53cea07bc6c366d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_fasttmr </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Is called every TCP_FAST_INTERVAL (250 ms) and process data previously "refused" by upper layer (application) and sends delayed ACKs.</p>
<p>Automatically called from <a class="el" href="tcp_8c.html#a3846a756b13214ed88ea47d0ff8279eb">tcp_tmr()</a>. </p>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l00817">817</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

</div>
</div>
<a class="anchor" id="aeff14f321d1eecd0431611f382fcd338"></a><!-- doxytag: member="tcp.c::tcp_listen_with_backlog" ref="aeff14f321d1eecd0431611f382fcd338" args="(struct tcp_pcb *pcb, u8_t backlog)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a>* tcp_listen_with_backlog </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&nbsp;</td>
          <td class="paramname"> <em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a>&nbsp;</td>
          <td class="paramname"> <em>backlog</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the state of the connection to be LISTEN, which means that it is able to accept incoming connections. The protocol control block is reallocated in order to consume less memory. Setting the connection to LISTEN is an irreversible process.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pcb</em>&nbsp;</td><td>the original <a class="el" href="structtcp__pcb.html">tcp_pcb</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>backlog</em>&nbsp;</td><td>the incoming connections queue limit </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="structtcp__pcb.html">tcp_pcb</a> used for listening, consumes less memory.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The original <a class="el" href="structtcp__pcb.html">tcp_pcb</a> is freed. This function therefore has to be called like this: tpcb = tcp_listen(tpcb); </dd></dl>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l00366">366</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="tcp_8c_aeff14f321d1eecd0431611f382fcd338_cgraph.gif" border="0" usemap="#tcp_8c_aeff14f321d1eecd0431611f382fcd338_cgraph" alt=""/></div>
<map name="tcp_8c_aeff14f321d1eecd0431611f382fcd338_cgraph" id="tcp_8c_aeff14f321d1eecd0431611f382fcd338_cgraph">
<area shape="rect" id="node3" href="memp_8c.html#aecd94926b7c2a0e23ae195f4ae97581f" title="memp_free" alt="" coords="255,5,359,37"/><area shape="rect" id="node5" href="memp_8c.html#a2b00593d086313c267b54a976bf67aa5" title="memp_malloc" alt="" coords="247,61,367,93"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a7427c5d237fe66a8097bfa8d24ceb943"></a><!-- doxytag: member="tcp.c::tcp_new" ref="a7427c5d237fe66a8097bfa8d24ceb943" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a>* tcp_new </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new TCP protocol control block but doesn't place it on any of the TCP PCB lists. The pcb is not put on any list until binding using <a class="el" href="tcp_8c.html#a5f7cf3b3975c4d414e91456959f01233">tcp_bind()</a>. </p>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l01089">1089</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="tcp_8c_a7427c5d237fe66a8097bfa8d24ceb943_cgraph.gif" border="0" usemap="#tcp_8c_a7427c5d237fe66a8097bfa8d24ceb943_cgraph" alt=""/></div>
<map name="tcp_8c_a7427c5d237fe66a8097bfa8d24ceb943_cgraph" id="tcp_8c_a7427c5d237fe66a8097bfa8d24ceb943_cgraph">
<area shape="rect" id="node3" href="tcp_8c.html#a1dd6830a42b3c464b5a72f62ae312d0a" title="tcp_alloc" alt="" coords="137,33,223,65"/><area shape="rect" id="node5" href="memp_8c.html#a2b00593d086313c267b54a976bf67aa5" title="memp_malloc" alt="" coords="273,5,393,37"/><area shape="rect" id="node7" href="tcp_8c.html#af5427fc45c0694592419b03694b95af7" title="tcp_next_iss" alt="" coords="279,61,388,93"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="af5427fc45c0694592419b03694b95af7"></a><!-- doxytag: member="tcp.c::tcp_next_iss" ref="af5427fc45c0694592419b03694b95af7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32_t tcp_next_iss </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculates a new initial sequence number for new connections.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>u32_t pseudo random sequence number </dd></dl>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l01289">1289</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

</div>
</div>
<a class="anchor" id="a44fc672b9d14a65e61040707c45302ba"></a><!-- doxytag: member="tcp.c::tcp_pcb_purge" ref="a44fc672b9d14a65e61040707c45302ba" args="(struct tcp_pcb *pcb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_pcb_purge </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&nbsp;</td>
          <td class="paramname"> <em>pcb</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Purges a TCP PCB. Removes any buffered data and frees the buffer memory (pcb-&gt;ooseq, pcb-&gt;unsent and pcb-&gt;unacked are freed).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pcb</em>&nbsp;</td><td><a class="el" href="structtcp__pcb.html">tcp_pcb</a> to purge. The pcb itself is not deallocated! </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l01191">1191</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="tcp_8c_a44fc672b9d14a65e61040707c45302ba_cgraph.gif" border="0" usemap="#tcp_8c_a44fc672b9d14a65e61040707c45302ba_cgraph" alt=""/></div>
<map name="tcp_8c_a44fc672b9d14a65e61040707c45302ba_cgraph" id="tcp_8c_a44fc672b9d14a65e61040707c45302ba_cgraph">
<area shape="rect" id="node3" href="pbuf_8c.html#ab0dd696fb4b6bc65e548944584f1738b" title="pbuf_free" alt="" coords="524,8,615,40"/><area shape="rect" id="node9" href="tcp_8c.html#a1f6d5f868cfaf1a4d843f030d61c58ae" title="tcp_segs_free" alt="" coords="184,61,309,93"/><area shape="rect" id="node5" href="mem_8c.html#a65169147c44e9db60d997819af9b455c" title="mem_free" alt="" coords="669,5,763,37"/><area shape="rect" id="node7" href="memp_8c.html#aecd94926b7c2a0e23ae195f4ae97581f" title="memp_free" alt="" coords="664,61,768,93"/><area shape="rect" id="node11" href="tcp_8c.html#a404539c2e8a6e38e2d57042225a96b40" title="tcp_seg_free" alt="" coords="357,61,475,93"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aaaef096f6a03bf5b778329bb66ee06f6"></a><!-- doxytag: member="tcp.c::tcp_pcb_remove" ref="aaaef096f6a03bf5b778329bb66ee06f6" args="(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_pcb_remove </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> **&nbsp;</td>
          <td class="paramname"> <em>pcblist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&nbsp;</td>
          <td class="paramname"> <em>pcb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Purges the PCB and removes it from a PCB list. Any delayed ACKs are sent first.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pcblist</em>&nbsp;</td><td>PCB list to purge. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pcb</em>&nbsp;</td><td><a class="el" href="structtcp__pcb.html">tcp_pcb</a> to purge. The pcb itself is NOT deallocated! </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l01256">1256</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="tcp_8c_aaaef096f6a03bf5b778329bb66ee06f6_cgraph.gif" border="0" usemap="#tcp_8c_aaaef096f6a03bf5b778329bb66ee06f6_cgraph" alt=""/></div>
<map name="tcp_8c_aaaef096f6a03bf5b778329bb66ee06f6_cgraph" id="tcp_8c_aaaef096f6a03bf5b778329bb66ee06f6_cgraph">
<area shape="rect" id="node3" href="tcp__out_8c.html#a0cbcc6d628f644a530daf629fa3e5f7f" title="tcp_output" alt="" coords="391,61,487,93"/><area shape="rect" id="node14" href="tcp_8c.html#a44fc672b9d14a65e61040707c45302ba" title="tcp_pcb_purge" alt="" coords="197,117,328,149"/><area shape="rect" id="node5" href="inet_8c.html#ab3ef2c882ab42295feaa7cd7d5ca8b34" title="ntohl" alt="" coords="609,5,665,37"/><area shape="rect" id="node7" href="tcp_8c.html#a404539c2e8a6e38e2d57042225a96b40" title="tcp_seg_free" alt="" coords="579,117,696,149"/><area shape="rect" id="node11" href="tcp__out_8c.html#aefde3e34b2cc8df9654986484c44a996" title="tcp_send_empty_ack" alt="" coords="549,61,725,93"/><area shape="rect" id="node9" href="pbuf_8c.html#ab0dd696fb4b6bc65e548944584f1738b" title="pbuf_free" alt="" coords="775,117,865,149"/><area shape="rect" id="node17" href="tcp_8c.html#a1f6d5f868cfaf1a4d843f030d61c58ae" title="tcp_segs_free" alt="" coords="376,117,501,149"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a501ef46b87d7e4784e41c66e4b9aef2c"></a><!-- doxytag: member="tcp.c::tcp_poll" ref="a501ef46b87d7e4784e41c66e4b9aef2c" args="(struct tcp_pcb *pcb, err_t(*poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_poll </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&nbsp;</td>
          <td class="paramname"> <em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">err_t(*)(void *arg, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *tpcb)&nbsp;</td>
          <td class="paramname"> <em>poll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a>&nbsp;</td>
          <td class="paramname"> <em>interval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Used to specify the function that should be called periodically from TCP. The interval is specified in terms of the TCP coarse timer interval, which is called twice a second. </p>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l01175">1175</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

</div>
</div>
<a class="anchor" id="af58be9006b4ddb720113f03d56bc6e52"></a><!-- doxytag: member="tcp.c::tcp_recv" ref="af58be9006b4ddb720113f03d56bc6e52" args="(struct tcp_pcb *pcb, err_t(*recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_recv </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&nbsp;</td>
          <td class="paramname"> <em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">err_t(*)(void *arg, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *tpcb, struct <a class="el" href="structpbuf.html">pbuf</a> *p, err_t err)&nbsp;</td>
          <td class="paramname"> <em>recv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Used to specify the function that should be called when a TCP connection receives data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pcb</em>&nbsp;</td><td><a class="el" href="structtcp__pcb.html">tcp_pcb</a> to set the recv callback </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>recv</em>&nbsp;</td><td>callback function to call for this pcb when data is received </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l01116">1116</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

</div>
</div>
<a class="anchor" id="a0cb3f604fc8d20870d8cab291da5701c"></a><!-- doxytag: member="tcp.c::tcp_recv_null" ref="a0cb3f604fc8d20870d8cab291da5701c" args="(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">err_t tcp_recv_null </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&nbsp;</td>
          <td class="paramname"> <em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">err_t&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Default receive callback that is called if the user didn't register a recv callback for the pcb. </p>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l00925">925</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="tcp_8c_a0cb3f604fc8d20870d8cab291da5701c_cgraph.gif" border="0" usemap="#tcp_8c_a0cb3f604fc8d20870d8cab291da5701c_cgraph" alt=""/></div>
<map name="tcp_8c_a0cb3f604fc8d20870d8cab291da5701c_cgraph" id="tcp_8c_a0cb3f604fc8d20870d8cab291da5701c_cgraph">
<area shape="rect" id="node3" href="pbuf_8c.html#ab0dd696fb4b6bc65e548944584f1738b" title="pbuf_free" alt="" coords="177,61,268,93"/><area shape="rect" id="node9" href="tcp_8c.html#a87093e137fcc53ea82a134a3f5b33623" title="tcp_close" alt="" coords="177,143,268,175"/><area shape="rect" id="node19" href="tcp_8c.html#abdac0856a52b5789dc897d4c7137ec44" title="tcp_recved" alt="" coords="172,227,273,259"/><area shape="rect" id="node5" href="mem_8c.html#a65169147c44e9db60d997819af9b455c" title="mem_free" alt="" coords="380,5,473,37"/><area shape="rect" id="node7" href="memp_8c.html#aecd94926b7c2a0e23ae195f4ae97581f" title="memp_free" alt="" coords="375,61,479,93"/><area shape="rect" id="node12" href="tcp__out_8c.html#a0cbcc6d628f644a530daf629fa3e5f7f" title="tcp_output" alt="" coords="580,141,676,173"/><area shape="rect" id="node14" href="tcp_8c.html#aaaef096f6a03bf5b778329bb66ee06f6" title="tcp_pcb_remove" alt="" coords="356,168,497,200"/><area shape="rect" id="node17" href="tcp__out_8c.html#ac8e4dca2a2e04c5073f09901742d1146" title="tcp_send_ctrl" alt="" coords="368,224,485,256"/><area shape="rect" id="node21" href="tcp_8c.html#a6d2c254b779db4e517cb34e41301588d" title="tcp_update_rcv_ann_wnd" alt="" coords="324,280,529,312"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="abdac0856a52b5789dc897d4c7137ec44"></a><!-- doxytag: member="tcp.c::tcp_recved" ref="abdac0856a52b5789dc897d4c7137ec44" args="(struct tcp_pcb *pcb, u16_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_recved </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&nbsp;</td>
          <td class="paramname"> <em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a>&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function should be called by the application when it has processed the data. The purpose is to advertise a larger window when the data has been processed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pcb</em>&nbsp;</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> for which data is read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>the amount of bytes that have been read by the application </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l00438">438</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="tcp_8c_abdac0856a52b5789dc897d4c7137ec44_cgraph.gif" border="0" usemap="#tcp_8c_abdac0856a52b5789dc897d4c7137ec44_cgraph" alt=""/></div>
<map name="tcp_8c_abdac0856a52b5789dc897d4c7137ec44_cgraph" id="tcp_8c_abdac0856a52b5789dc897d4c7137ec44_cgraph">
<area shape="rect" id="node3" href="tcp_8c.html#a6d2c254b779db4e517cb34e41301588d" title="tcp_update_rcv_ann_wnd" alt="" coords="159,5,364,37"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a569d79451d2570e4ef406775725ef6ef"></a><!-- doxytag: member="tcp.c::tcp_seg_copy" ref="a569d79451d2570e4ef406775725ef6ef" args="(struct tcp_seg *seg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__seg.html">tcp_seg</a>* tcp_seg_copy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__seg.html">tcp_seg</a> *&nbsp;</td>
          <td class="paramname"> <em>seg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a copy of the given TCP segment. The pbuf and data are not copied, only the pointers</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>seg</em>&nbsp;</td><td>the old <a class="el" href="structtcp__seg.html">tcp_seg</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a copy of seg </dd></dl>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l00905">905</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="tcp_8c_a569d79451d2570e4ef406775725ef6ef_cgraph.gif" border="0" usemap="#tcp_8c_a569d79451d2570e4ef406775725ef6ef_cgraph" alt=""/></div>
<map name="tcp_8c_a569d79451d2570e4ef406775725ef6ef_cgraph" id="tcp_8c_a569d79451d2570e4ef406775725ef6ef_cgraph">
<area shape="rect" id="node3" href="memp_8c.html#a2b00593d086313c267b54a976bf67aa5" title="memp_malloc" alt="" coords="180,5,300,37"/><area shape="rect" id="node5" href="pbuf_8c.html#a77f6bbd69e45e542014d9c547c7da74e" title="pbuf_ref" alt="" coords="199,61,281,93"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a404539c2e8a6e38e2d57042225a96b40"></a><!-- doxytag: member="tcp.c::tcp_seg_free" ref="a404539c2e8a6e38e2d57042225a96b40" args="(struct tcp_seg *seg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> tcp_seg_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__seg.html">tcp_seg</a> *&nbsp;</td>
          <td class="paramname"> <em>seg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Frees a TCP segment (<a class="el" href="structtcp__seg.html">tcp_seg</a> structure).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>seg</em>&nbsp;</td><td>single <a class="el" href="structtcp__seg.html">tcp_seg</a> to free </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of pbufs that were deallocated </dd></dl>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l00868">868</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="tcp_8c_a404539c2e8a6e38e2d57042225a96b40_cgraph.gif" border="0" usemap="#tcp_8c_a404539c2e8a6e38e2d57042225a96b40_cgraph" alt=""/></div>
<map name="tcp_8c_a404539c2e8a6e38e2d57042225a96b40_cgraph" id="tcp_8c_a404539c2e8a6e38e2d57042225a96b40_cgraph">
<area shape="rect" id="node3" href="memp_8c.html#aecd94926b7c2a0e23ae195f4ae97581f" title="memp_free" alt="" coords="312,5,416,37"/><area shape="rect" id="node5" href="pbuf_8c.html#ab0dd696fb4b6bc65e548944584f1738b" title="pbuf_free" alt="" coords="172,59,263,91"/><area shape="rect" id="node7" href="mem_8c.html#a65169147c44e9db60d997819af9b455c" title="mem_free" alt="" coords="317,61,411,93"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a1f6d5f868cfaf1a4d843f030d61c58ae"></a><!-- doxytag: member="tcp.c::tcp_segs_free" ref="a1f6d5f868cfaf1a4d843f030d61c58ae" args="(struct tcp_seg *seg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> tcp_segs_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__seg.html">tcp_seg</a> *&nbsp;</td>
          <td class="paramname"> <em>seg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deallocates a list of TCP segments (<a class="el" href="structtcp__seg.html">tcp_seg</a> structures).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>seg</em>&nbsp;</td><td><a class="el" href="structtcp__seg.html">tcp_seg</a> list of TCP segments to free </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of pbufs that were deallocated </dd></dl>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l00849">849</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="tcp_8c_a1f6d5f868cfaf1a4d843f030d61c58ae_cgraph.gif" border="0" usemap="#tcp_8c_a1f6d5f868cfaf1a4d843f030d61c58ae_cgraph" alt=""/></div>
<map name="tcp_8c_a1f6d5f868cfaf1a4d843f030d61c58ae_cgraph" id="tcp_8c_a1f6d5f868cfaf1a4d843f030d61c58ae_cgraph">
<area shape="rect" id="node3" href="tcp_8c.html#a404539c2e8a6e38e2d57042225a96b40" title="tcp_seg_free" alt="" coords="179,5,296,37"/><area shape="rect" id="node5" href="memp_8c.html#aecd94926b7c2a0e23ae195f4ae97581f" title="memp_free" alt="" coords="485,5,589,37"/><area shape="rect" id="node7" href="pbuf_8c.html#ab0dd696fb4b6bc65e548944584f1738b" title="pbuf_free" alt="" coords="345,32,436,64"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a030f298925f742108af2c85f22ce25da"></a><!-- doxytag: member="tcp.c::tcp_sent" ref="a030f298925f742108af2c85f22ce25da" args="(struct tcp_pcb *pcb, err_t(*sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_sent </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&nbsp;</td>
          <td class="paramname"> <em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">err_t(*)(void *arg, struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *tpcb, <a class="el" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> len)&nbsp;</td>
          <td class="paramname"> <em>sent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Used to specify the function that should be called when TCP data has been successfully delivered to the remote host.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pcb</em>&nbsp;</td><td><a class="el" href="structtcp__pcb.html">tcp_pcb</a> to set the sent callback </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sent</em>&nbsp;</td><td>callback function to call for this pcb when data is successfully sent </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l01130">1130</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

</div>
</div>
<a class="anchor" id="a2c4234f1e95b6bde0e84d4ea97ae95bc"></a><!-- doxytag: member="tcp.c::tcp_setprio" ref="a2c4234f1e95b6bde0e84d4ea97ae95bc" args="(struct tcp_pcb *pcb, u8_t prio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_setprio </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&nbsp;</td>
          <td class="paramname"> <em>pcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a>&nbsp;</td>
          <td class="paramname"> <em>prio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the priority of a connection.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pcb</em>&nbsp;</td><td>the <a class="el" href="structtcp__pcb.html">tcp_pcb</a> to manipulate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prio</em>&nbsp;</td><td>new priority </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l00891">891</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

</div>
</div>
<a class="anchor" id="a421fb42ef919018e14ae413adfee9905"></a><!-- doxytag: member="tcp.c::tcp_slowtmr" ref="a421fb42ef919018e14ae413adfee9905" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_slowtmr </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called every 500 ms and implements the retransmission timer and the timer that removes PCBs that have been in TIME-WAIT for enough time. It also increments various timers such as the inactivity timer in each PCB.</p>
<p>Automatically called from <a class="el" href="tcp_8c.html#a3846a756b13214ed88ea47d0ff8279eb">tcp_tmr()</a>. </p>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l00577">577</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="tcp_8c_a421fb42ef919018e14ae413adfee9905_cgraph.gif" border="0" usemap="#tcp_8c_a421fb42ef919018e14ae413adfee9905_cgraph" alt=""/></div>
<map name="tcp_8c_a421fb42ef919018e14ae413adfee9905_cgraph" id="tcp_8c_a421fb42ef919018e14ae413adfee9905_cgraph">
<area shape="rect" id="node3" href="memp_8c.html#aecd94926b7c2a0e23ae195f4ae97581f" title="memp_free" alt="" coords="1067,45,1171,77"/><area shape="rect" id="node5" href="tcp__out_8c.html#a13fd5160cf75d19d6696c27d7becf3d9" title="tcp_keepalive" alt="" coords="552,370,672,402"/><area shape="rect" id="node17" href="tcp__out_8c.html#a0cbcc6d628f644a530daf629fa3e5f7f" title="tcp_output" alt="" coords="353,202,449,234"/><area shape="rect" id="node32" href="tcp_8c.html#a44fc672b9d14a65e61040707c45302ba" title="tcp_pcb_purge" alt="" coords="160,98,291,130"/><area shape="rect" id="node35" href="tcp_8c.html#a1f6d5f868cfaf1a4d843f030d61c58ae" title="tcp_segs_free" alt="" coords="339,45,464,77"/><area shape="rect" id="node38" href="tcp__out_8c.html#ab5ef9c8ab4629eb721987ae316b9f30f" title="tcp_rexmit_rto" alt="" coords="164,230,287,262"/><area shape="rect" id="node41" href="tcp__out_8c.html#a168fa0bb172bb0bd29bd58e31f804147" title="tcp_rst" alt="" coords="577,314,647,346"/><area shape="rect" id="node50" href="tcp__out_8c.html#a5f0813be2b0fe0852da63d55660c722c" title="tcp_zero_window_probe" alt="" coords="513,426,711,458"/><area shape="rect" id="node7" href="inet_8c.html#aed84a49b499a0d09a1237113b85ad0ab" title="htonl" alt="" coords="791,202,847,234"/><area shape="rect" id="node9" href="ip_8c.html#aabccfd6ab4e3c73350c4014158cd4d2b" title="ip_output" alt="" coords="775,365,863,397"/><area shape="rect" id="node11" href="pbuf_8c.html#acfcb0a2af918658ba0afe36499c65f47" title="pbuf_alloc" alt="" coords="771,421,867,453"/><area shape="rect" id="node13" href="pbuf_8c.html#ab0dd696fb4b6bc65e548944584f1738b" title="pbuf_free" alt="" coords="927,202,1017,234"/><area shape="rect" id="node19" href="inet_8c.html#ab3ef2c882ab42295feaa7cd7d5ca8b34" title="ntohl" alt="" coords="584,202,640,234"/><area shape="rect" id="node22" href="tcp_8c.html#a404539c2e8a6e38e2d57042225a96b40" title="tcp_seg_free" alt="" coords="760,45,877,77"/><area shape="rect" id="node26" href="tcp__out_8c.html#aefde3e34b2cc8df9654986484c44a996" title="tcp_send_empty_ack" alt="" coords="524,258,700,290"/><area shape="rect" id="node44" href="group__uipconvfunc.html#gaa22b04cac8cf283ca12f028578bebc06" title="htons" alt="" coords="788,309,849,341"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a3846a756b13214ed88ea47d0ff8279eb"></a><!-- doxytag: member="tcp.c::tcp_tmr" ref="a3846a756b13214ed88ea47d0ff8279eb" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_tmr </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called periodically to dispatch TCP timers. </p>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l00100">100</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="tcp_8c_a3846a756b13214ed88ea47d0ff8279eb_cgraph.gif" border="0" usemap="#tcp_8c_a3846a756b13214ed88ea47d0ff8279eb_cgraph" alt=""/></div>
<map name="tcp_8c_a3846a756b13214ed88ea47d0ff8279eb_cgraph" id="tcp_8c_a3846a756b13214ed88ea47d0ff8279eb_cgraph">
<area shape="rect" id="node3" href="tcp_8c.html#abf446b07e52161b8a53cea07bc6c366d" title="tcp_fasttmr" alt="" coords="133,140,235,172"/><area shape="rect" id="node5" href="tcp_8c.html#a421fb42ef919018e14ae413adfee9905" title="tcp_slowtmr" alt="" coords="131,196,237,228"/><area shape="rect" id="node7" href="memp_8c.html#aecd94926b7c2a0e23ae195f4ae97581f" title="memp_free" alt="" coords="333,5,437,37"/><area shape="rect" id="node9" href="tcp__out_8c.html#a13fd5160cf75d19d6696c27d7becf3d9" title="tcp_keepalive" alt="" coords="325,61,445,93"/><area shape="rect" id="node11" href="tcp__out_8c.html#a0cbcc6d628f644a530daf629fa3e5f7f" title="tcp_output" alt="" coords="548,155,644,187"/><area shape="rect" id="node13" href="tcp_8c.html#a44fc672b9d14a65e61040707c45302ba" title="tcp_pcb_purge" alt="" coords="320,224,451,256"/><area shape="rect" id="node15" href="tcp_8c.html#a1f6d5f868cfaf1a4d843f030d61c58ae" title="tcp_segs_free" alt="" coords="533,237,659,269"/><area shape="rect" id="node17" href="tcp__out_8c.html#ab5ef9c8ab4629eb721987ae316b9f30f" title="tcp_rexmit_rto" alt="" coords="324,168,447,200"/><area shape="rect" id="node20" href="tcp__out_8c.html#a168fa0bb172bb0bd29bd58e31f804147" title="tcp_rst" alt="" coords="351,331,420,363"/><area shape="rect" id="node23" href="tcp__out_8c.html#a5f0813be2b0fe0852da63d55660c722c" title="tcp_zero_window_probe" alt="" coords="287,387,484,419"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a6d2c254b779db4e517cb34e41301588d"></a><!-- doxytag: member="tcp.c::tcp_update_rcv_ann_wnd" ref="a6d2c254b779db4e517cb34e41301588d" args="(struct tcp_pcb *pcb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32_t tcp_update_rcv_ann_wnd </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a> *&nbsp;</td>
          <td class="paramname"> <em>pcb</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Update the state that tracks the available window space to advertise.</p>
<p>Returns how much extra window would be advertised if we sent an update now. </p>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l00408">408</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a78c09dbae67ccc06b659d9f1a388f911"></a><!-- doxytag: member="tcp.c::tcp_active_pcbs" ref="a78c09dbae67ccc06b659d9f1a388f911" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a>* <a class="el" href="tcp_8c.html#a78c09dbae67ccc06b659d9f1a388f911">tcp_active_pcbs</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>List of all TCP PCBs that are in a state in which they accept or send data. </p>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l00086">86</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

</div>
</div>
<a class="anchor" id="ac6a6c7d191a0af9b8e2e323cfd3d89b4"></a><!-- doxytag: member="tcp.c::tcp_backoff" ref="ac6a6c7d191a0af9b8e2e323cfd3d89b4" args="[13]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> tcp_backoff[13]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
    { 1, 2, 3, 4, 5, 6, 7, 7, 7, 7, 7, 7, 7}
</pre></div>
<p>Definition at line <a class="el" href="tcp_8c_source.html#l00073">73</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

</div>
</div>
<a class="anchor" id="a1b42a7ac0fc173a42d575f86853d32a8"></a><!-- doxytag: member="tcp.c::tcp_bound_pcbs" ref="a1b42a7ac0fc173a42d575f86853d32a8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a>* <a class="el" href="tcp_8c.html#a1b42a7ac0fc173a42d575f86853d32a8">tcp_bound_pcbs</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>List of all TCP PCBs bound but not yet (connected || listening) </p>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l00081">81</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

</div>
</div>
<a class="anchor" id="a96fe1350e510d4308ac9969ffb4c9c81"></a><!-- doxytag: member="tcp.c::tcp_listen_pcbs" ref="a96fe1350e510d4308ac9969ffb4c9c81" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union <a class="el" href="uniontcp__listen__pcbs__t.html">tcp_listen_pcbs_t</a> <a class="el" href="tcp_8c.html#a96fe1350e510d4308ac9969ffb4c9c81">tcp_listen_pcbs</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>List of all TCP PCBs in LISTEN state </p>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l00083">83</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

</div>
</div>
<a class="anchor" id="a5a4fff32d6e6af37e38aea97d1f0135f"></a><!-- doxytag: member="tcp.c::tcp_state_str" ref="a5a4fff32d6e6af37e38aea97d1f0135f" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* tcp_state_str[]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
  <span class="stringliteral">&quot;CLOSED&quot;</span>,      
  <span class="stringliteral">&quot;LISTEN&quot;</span>,      
  <span class="stringliteral">&quot;SYN_SENT&quot;</span>,    
  <span class="stringliteral">&quot;SYN_RCVD&quot;</span>,    
  <span class="stringliteral">&quot;ESTABLISHED&quot;</span>, 
  <span class="stringliteral">&quot;FIN_WAIT_1&quot;</span>,  
  <span class="stringliteral">&quot;FIN_WAIT_2&quot;</span>,  
  <span class="stringliteral">&quot;CLOSE_WAIT&quot;</span>,  
  <span class="stringliteral">&quot;CLOSING&quot;</span>,     
  <span class="stringliteral">&quot;LAST_ACK&quot;</span>,    
  <span class="stringliteral">&quot;TIME_WAIT&quot;</span>   
}
</pre></div>
<p>Definition at line <a class="el" href="tcp_8c_source.html#l00057">57</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

</div>
</div>
<a class="anchor" id="a9a522a66c5e1f1a4e28fe7a672cc64e3"></a><!-- doxytag: member="tcp.c::tcp_tw_pcbs" ref="a9a522a66c5e1f1a4e28fe7a672cc64e3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtcp__pcb.html">tcp_pcb</a>* <a class="el" href="tcp_8c.html#a9a522a66c5e1f1a4e28fe7a672cc64e3">tcp_tw_pcbs</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>List of all TCP PCBs in TIME-WAIT state </p>

<p>Definition at line <a class="el" href="tcp_8c_source.html#l00088">88</a> of file <a class="el" href="tcp_8c_source.html">tcp.c</a>.</p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
