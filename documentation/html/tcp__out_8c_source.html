<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SAME70 Xplained Software Package: libraries/liblwip/source/lwip_1.3.2/src/core/tcp_out.c Source File</title>
<link href="common/style.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
    <div id="body">
        <div id="title">  SAME70 Xplained Software Package 1.5</div>
        <div id="banner"></div>

<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="dir_81818f1c1b01098ad6d8389f2aaf9f72.html">libraries</a>      </li>
      <li><a class="el" href="dir_f9d6af8b0767ec29e003eb404f55b2ba.html">liblwip</a>      </li>
      <li><a class="el" href="dir_a4b90551bcebf72d44580c734ab11c86.html">source</a>      </li>
      <li><a class="el" href="dir_7fff4700eae15a55204f316974611e6c.html">lwip_1.3.2</a>      </li>
      <li><a class="el" href="dir_6c5a4da2b38a7354841e985f92489e70.html">src</a>      </li>
      <li><a class="el" href="dir_edf09da46bb12db6367452bd0397000e.html">core</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>tcp_out.c</h1>  </div>
</div>
<div class="contents">
<a href="tcp__out_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment"> /**</span>
<a name="l00002"></a>00002 <span class="comment"> * @file</span>
<a name="l00003"></a>00003 <span class="comment"> * Transmission Control Protocol, outgoing traffic</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * The output functions of TCP.</span>
<a name="l00006"></a>00006 <span class="comment"> *</span>
<a name="l00007"></a>00007 <span class="comment"> */</span>
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 <span class="comment">/*</span>
<a name="l00010"></a>00010 <span class="comment"> * Copyright (c) 2001-2004 Swedish Institute of Computer Science.</span>
<a name="l00011"></a>00011 <span class="comment"> * All rights reserved.</span>
<a name="l00012"></a>00012 <span class="comment"> *</span>
<a name="l00013"></a>00013 <span class="comment"> * Redistribution and use in source and binary forms, with or without modification,</span>
<a name="l00014"></a>00014 <span class="comment"> * are permitted provided that the following conditions are met:</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * 1. Redistributions of source code must retain the above copyright notice,</span>
<a name="l00017"></a>00017 <span class="comment"> *    this list of conditions and the following disclaimer.</span>
<a name="l00018"></a>00018 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<a name="l00019"></a>00019 <span class="comment"> *    this list of conditions and the following disclaimer in the documentation</span>
<a name="l00020"></a>00020 <span class="comment"> *    and/or other materials provided with the distribution.</span>
<a name="l00021"></a>00021 <span class="comment"> * 3. The name of the author may not be used to endorse or promote products</span>
<a name="l00022"></a>00022 <span class="comment"> *    derived from this software without specific prior written permission.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS&#39;&#39; AND ANY EXPRESS OR IMPLIED</span>
<a name="l00025"></a>00025 <span class="comment"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
<a name="l00026"></a>00026 <span class="comment"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT</span>
<a name="l00027"></a>00027 <span class="comment"> * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,</span>
<a name="l00028"></a>00028 <span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT</span>
<a name="l00029"></a>00029 <span class="comment"> * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<a name="l00030"></a>00030 <span class="comment"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<a name="l00031"></a>00031 <span class="comment"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING</span>
<a name="l00032"></a>00032 <span class="comment"> * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY</span>
<a name="l00033"></a>00033 <span class="comment"> * OF SUCH DAMAGE.</span>
<a name="l00034"></a>00034 <span class="comment"> *</span>
<a name="l00035"></a>00035 <span class="comment"> * This file is part of the lwIP TCP/IP stack.</span>
<a name="l00036"></a>00036 <span class="comment"> *</span>
<a name="l00037"></a>00037 <span class="comment"> * Author: Adam Dunkels &lt;adam@sics.se&gt;</span>
<a name="l00038"></a>00038 <span class="comment"> *</span>
<a name="l00039"></a>00039 <span class="comment"> */</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;<a class="code" href="opt_8h.html">lwip/opt.h</a>&quot;</span>
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="preprocessor">#if LWIP_TCP </span><span class="comment">/* don&#39;t build if not configured for use in lwipopts.h */</span>
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 <span class="preprocessor">#include &quot;lwip/tcp.h&quot;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &quot;lwip/def.h&quot;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &quot;lwip/mem.h&quot;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;lwip/memp.h&quot;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &quot;lwip/sys.h&quot;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &quot;lwip/ip_addr.h&quot;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &quot;lwip/netif.h&quot;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &quot;lwip/inet.h&quot;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &quot;lwip/inet_chksum.h&quot;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &quot;lwip/stats.h&quot;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &quot;lwip/snmp.h&quot;</span>
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 <span class="comment">/* Forward declarations.*/</span>
<a name="l00060"></a>00060 <span class="keyword">static</span> <span class="keywordtype">void</span> tcp_output_segment(<span class="keyword">struct</span> <a class="code" href="structtcp__seg.html">tcp_seg</a> *seg, <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structtcp__hdr.html">tcp_hdr</a> *
<a name="l00063"></a>00063 tcp_output_set_header(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p, <span class="keywordtype">int</span> optlen,
<a name="l00064"></a>00064                       u32_t seqno_be <span class="comment">/* already in network byte order */</span>)
<a name="l00065"></a>00065 {
<a name="l00066"></a>00066   <span class="keyword">struct </span><a class="code" href="structtcp__hdr.html">tcp_hdr</a> *<a class="code" href="structtcphdr.html">tcphdr</a> = p-&gt;<a class="code" href="structpbuf.html#a8d32dc3e964369d4eec638fc37fbc460">payload</a>;
<a name="l00067"></a>00067   tcphdr-&gt;src = <a class="code" href="group__uipconvfunc.html#gaa22b04cac8cf283ca12f028578bebc06">htons</a>(pcb-&gt;local_port);
<a name="l00068"></a>00068   tcphdr-&gt;dest = <a class="code" href="group__uipconvfunc.html#gaa22b04cac8cf283ca12f028578bebc06">htons</a>(pcb-&gt;remote_port);
<a name="l00069"></a>00069   tcphdr-&gt;seqno = seqno_be;
<a name="l00070"></a>00070   tcphdr-&gt;ackno = <a class="code" href="inet_8c.html#aed84a49b499a0d09a1237113b85ad0ab">htonl</a>(pcb-&gt;rcv_nxt);
<a name="l00071"></a>00071   TCPH_FLAGS_SET(tcphdr, TCP_ACK);
<a name="l00072"></a>00072   tcphdr-&gt;wnd = <a class="code" href="group__uipconvfunc.html#gaa22b04cac8cf283ca12f028578bebc06">htons</a>(pcb-&gt;rcv_ann_wnd);
<a name="l00073"></a>00073   tcphdr-&gt;urgp = 0;
<a name="l00074"></a>00074   TCPH_HDRLEN_SET(tcphdr, (5 + optlen / 4));
<a name="l00075"></a>00075   tcphdr-&gt;chksum = 0;
<a name="l00076"></a>00076 
<a name="l00077"></a>00077   <span class="comment">/* If we&#39;re sending a packet, update the announced right window edge */</span>
<a name="l00078"></a>00078   pcb-&gt;rcv_ann_right_edge = pcb-&gt;rcv_nxt + pcb-&gt;rcv_ann_wnd;
<a name="l00079"></a>00079 
<a name="l00080"></a>00080   <span class="keywordflow">return</span> tcphdr;
<a name="l00081"></a>00081 }
<a name="l00082"></a>00082 <span class="comment"></span>
<a name="l00083"></a>00083 <span class="comment">/**</span>
<a name="l00084"></a>00084 <span class="comment"> * Called by tcp_close() to send a segment including flags but not data.</span>
<a name="l00085"></a>00085 <span class="comment"> *</span>
<a name="l00086"></a>00086 <span class="comment"> * @param pcb the tcp_pcb over which to send a segment</span>
<a name="l00087"></a>00087 <span class="comment"> * @param flags the flags to set in the segment header</span>
<a name="l00088"></a>00088 <span class="comment"> * @return ERR_OK if sent, another err_t otherwise</span>
<a name="l00089"></a>00089 <span class="comment"> */</span>
<a name="l00090"></a>00090 err_t
<a name="l00091"></a><a class="code" href="tcp__out_8c.html#ac8e4dca2a2e04c5073f09901742d1146">00091</a> <a class="code" href="tcp__out_8c.html#ac8e4dca2a2e04c5073f09901742d1146">tcp_send_ctrl</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> flags)
<a name="l00092"></a>00092 {
<a name="l00093"></a>00093   <span class="comment">/* no data, no length, flags, copy=1, no optdata */</span>
<a name="l00094"></a>00094   <span class="keywordflow">return</span> <a class="code" href="tcp__out_8c.html#a94dcf0b53c8a8e627c14b5cb01836bdb">tcp_enqueue</a>(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, 0);
<a name="l00095"></a>00095 }
<a name="l00096"></a>00096 <span class="comment"></span>
<a name="l00097"></a>00097 <span class="comment">/**</span>
<a name="l00098"></a>00098 <span class="comment"> * Write data for sending (but does not send it immediately).</span>
<a name="l00099"></a>00099 <span class="comment"> *</span>
<a name="l00100"></a>00100 <span class="comment"> * It waits in the expectation of more data being sent soon (as</span>
<a name="l00101"></a>00101 <span class="comment"> * it can send them more efficiently by combining them together).</span>
<a name="l00102"></a>00102 <span class="comment"> * To prompt the system to send data now, call tcp_output() after</span>
<a name="l00103"></a>00103 <span class="comment"> * calling tcp_write().</span>
<a name="l00104"></a>00104 <span class="comment"> * </span>
<a name="l00105"></a>00105 <span class="comment"> * @param pcb Protocol control block of the TCP connection to enqueue data for.</span>
<a name="l00106"></a>00106 <span class="comment"> * @param data pointer to the data to send</span>
<a name="l00107"></a>00107 <span class="comment"> * @param len length (in bytes) of the data to send</span>
<a name="l00108"></a>00108 <span class="comment"> * @param apiflags combination of following flags :</span>
<a name="l00109"></a>00109 <span class="comment"> * - TCP_WRITE_FLAG_COPY (0x01) data will be copied into memory belonging to the stack</span>
<a name="l00110"></a>00110 <span class="comment"> * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,</span>
<a name="l00111"></a>00111 <span class="comment"> * @return ERR_OK if enqueued, another err_t on error</span>
<a name="l00112"></a>00112 <span class="comment"> * </span>
<a name="l00113"></a>00113 <span class="comment"> * @see tcp_write()</span>
<a name="l00114"></a>00114 <span class="comment"> */</span>
<a name="l00115"></a>00115 err_t
<a name="l00116"></a><a class="code" href="tcp__out_8c.html#adf2da5506f6cded5fdd6ff6a2f4c6929">00116</a> <a class="code" href="tcp__out_8c.html#adf2da5506f6cded5fdd6ff6a2f4c6929">tcp_write</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <span class="keyword">const</span> <span class="keywordtype">void</span> *<a class="code" href="examples__storage_2hsmci__sdcard__fatfs_2main_8c.html#a8250065f3d0322b7b57f57ed5ed94e5a">data</a>, <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> len, <a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> apiflags)
<a name="l00117"></a>00117 {
<a name="l00118"></a>00118   LWIP_DEBUGF(<a class="code" href="opt_8h.html#a9f70601fdc1feee490772bf7fcdb74fb">TCP_OUTPUT_DEBUG</a>, (<span class="stringliteral">&quot;tcp_write(pcb=%p, data=%p, len=%&quot;</span>U16_F<span class="stringliteral">&quot;, apiflags=%&quot;</span>U16_F<span class="stringliteral">&quot;)\n&quot;</span>, (<span class="keywordtype">void</span> *)pcb,
<a name="l00119"></a>00119     data, len, (<a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a>)apiflags));
<a name="l00120"></a>00120   <span class="comment">/* connection is in valid state for data transmission? */</span>
<a name="l00121"></a>00121   <span class="keywordflow">if</span> (pcb-&gt;state == ESTABLISHED ||
<a name="l00122"></a>00122      pcb-&gt;state == CLOSE_WAIT ||
<a name="l00123"></a>00123      pcb-&gt;state == SYN_SENT ||
<a name="l00124"></a>00124      pcb-&gt;state == SYN_RCVD) {
<a name="l00125"></a>00125     <span class="keywordflow">if</span> (len &gt; 0) {
<a name="l00126"></a>00126 <span class="preprocessor">#if LWIP_TCP_TIMESTAMPS</span>
<a name="l00127"></a>00127 <span class="preprocessor"></span>      <span class="keywordflow">return</span> <a class="code" href="tcp__out_8c.html#a94dcf0b53c8a8e627c14b5cb01836bdb">tcp_enqueue</a>(pcb, (<span class="keywordtype">void</span> *)data, len, 0, apiflags, 
<a name="l00128"></a>00128                          pcb-&gt;flags &amp; TF_TIMESTAMP ? TF_SEG_OPTS_TS : 0);
<a name="l00129"></a>00129 <span class="preprocessor">#else</span>
<a name="l00130"></a>00130 <span class="preprocessor"></span>      <span class="keywordflow">return</span> <a class="code" href="tcp__out_8c.html#a94dcf0b53c8a8e627c14b5cb01836bdb">tcp_enqueue</a>(pcb, (<span class="keywordtype">void</span> *)data, len, 0, apiflags, 0);
<a name="l00131"></a>00131 <span class="preprocessor">#endif</span>
<a name="l00132"></a>00132 <span class="preprocessor"></span>    }
<a name="l00133"></a>00133     <span class="keywordflow">return</span> ERR_OK;
<a name="l00134"></a>00134   } <span class="keywordflow">else</span> {
<a name="l00135"></a>00135     LWIP_DEBUGF(<a class="code" href="opt_8h.html#a9f70601fdc1feee490772bf7fcdb74fb">TCP_OUTPUT_DEBUG</a> | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, (<span class="stringliteral">&quot;tcp_write() called in invalid state\n&quot;</span>));
<a name="l00136"></a>00136     <span class="keywordflow">return</span> ERR_CONN;
<a name="l00137"></a>00137   }
<a name="l00138"></a>00138 }
<a name="l00139"></a>00139 <span class="comment"></span>
<a name="l00140"></a>00140 <span class="comment">/**</span>
<a name="l00141"></a>00141 <span class="comment"> * Enqueue data and/or TCP options for transmission</span>
<a name="l00142"></a>00142 <span class="comment"> *</span>
<a name="l00143"></a>00143 <span class="comment"> * Called by tcp_connect(), tcp_listen_input(), tcp_send_ctrl() and tcp_write().</span>
<a name="l00144"></a>00144 <span class="comment"> *</span>
<a name="l00145"></a>00145 <span class="comment"> * @param pcb Protocol control block for the TCP connection to enqueue data for.</span>
<a name="l00146"></a>00146 <span class="comment"> * @param arg Pointer to the data to be enqueued for sending.</span>
<a name="l00147"></a>00147 <span class="comment"> * @param len Data length in bytes</span>
<a name="l00148"></a>00148 <span class="comment"> * @param flags tcp header flags to set in the outgoing segment</span>
<a name="l00149"></a>00149 <span class="comment"> * @param apiflags combination of following flags :</span>
<a name="l00150"></a>00150 <span class="comment"> * - TCP_WRITE_FLAG_COPY (0x01) data will be copied into memory belonging to the stack</span>
<a name="l00151"></a>00151 <span class="comment"> * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,</span>
<a name="l00152"></a>00152 <span class="comment"> * @param optflags options to include in segment later on (see definition of struct tcp_seg)</span>
<a name="l00153"></a>00153 <span class="comment"> */</span>
<a name="l00154"></a>00154 err_t
<a name="l00155"></a><a class="code" href="tcp__out_8c.html#a94dcf0b53c8a8e627c14b5cb01836bdb">00155</a> <a class="code" href="tcp__out_8c.html#a94dcf0b53c8a8e627c14b5cb01836bdb">tcp_enqueue</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <span class="keywordtype">void</span> *arg, <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> len,
<a name="l00156"></a>00156             <a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> flags, <a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> apiflags, <a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> optflags)
<a name="l00157"></a>00157 {
<a name="l00158"></a>00158   <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *p;
<a name="l00159"></a>00159   <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> *seg, *useg, *queue;
<a name="l00160"></a>00160   u32_t seqno;
<a name="l00161"></a>00161   <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> left, seglen;
<a name="l00162"></a>00162   <span class="keywordtype">void</span> *ptr;
<a name="l00163"></a>00163   <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> queuelen;
<a name="l00164"></a>00164   <a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> optlen;
<a name="l00165"></a>00165 
<a name="l00166"></a>00166   LWIP_DEBUGF(<a class="code" href="opt_8h.html#a9f70601fdc1feee490772bf7fcdb74fb">TCP_OUTPUT_DEBUG</a>, 
<a name="l00167"></a>00167               (<span class="stringliteral">&quot;tcp_enqueue(pcb=%p, arg=%p, len=%&quot;</span>U16_F<span class="stringliteral">&quot;, flags=%&quot;</span>X16_F<span class="stringliteral">&quot;, apiflags=%&quot;</span>U16_F<span class="stringliteral">&quot;)\n&quot;</span>,
<a name="l00168"></a>00168                (<span class="keywordtype">void</span> *)pcb, arg, len, (<a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a>)flags, (<a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a>)apiflags));
<a name="l00169"></a>00169   LWIP_ERROR(<span class="stringliteral">&quot;tcp_enqueue: packet needs payload, options, or SYN/FIN (programmer violates API)&quot;</span>,
<a name="l00170"></a>00170              ((len != 0) || (optflags != 0) || ((flags &amp; (TCP_SYN | TCP_FIN)) != 0)),
<a name="l00171"></a>00171              <span class="keywordflow">return</span> ERR_ARG;);
<a name="l00172"></a>00172   LWIP_ERROR(<span class="stringliteral">&quot;tcp_enqueue: len != 0 || arg == NULL (programmer violates API)&quot;</span>, 
<a name="l00173"></a>00173              ((len != 0) || (arg == NULL)), <span class="keywordflow">return</span> ERR_ARG;);
<a name="l00174"></a>00174 
<a name="l00175"></a>00175   <span class="comment">/* fail on too much data */</span>
<a name="l00176"></a>00176   <span class="keywordflow">if</span> (len &gt; pcb-&gt;snd_buf) {
<a name="l00177"></a>00177     LWIP_DEBUGF(<a class="code" href="opt_8h.html#a9f70601fdc1feee490772bf7fcdb74fb">TCP_OUTPUT_DEBUG</a> | LWIP_DBG_LEVEL_WARNING,
<a name="l00178"></a>00178       (<span class="stringliteral">&quot;tcp_enqueue: too much data (len=%&quot;</span>U16_F<span class="stringliteral">&quot; &gt; snd_buf=%&quot;</span>U16_F<span class="stringliteral">&quot;)\n&quot;</span>, len, pcb-&gt;snd_buf));
<a name="l00179"></a>00179     pcb-&gt;flags |= TF_NAGLEMEMERR;
<a name="l00180"></a>00180     <span class="keywordflow">return</span> ERR_MEM;
<a name="l00181"></a>00181   }
<a name="l00182"></a>00182   left = len;
<a name="l00183"></a>00183   ptr = arg;
<a name="l00184"></a>00184 
<a name="l00185"></a>00185   optlen = LWIP_TCP_OPT_LENGTH(optflags);
<a name="l00186"></a>00186 
<a name="l00187"></a>00187   <span class="comment">/* seqno will be the sequence number of the first segment enqueued</span>
<a name="l00188"></a>00188 <span class="comment">   * by the call to this function. */</span>
<a name="l00189"></a>00189   seqno = pcb-&gt;snd_lbb;
<a name="l00190"></a>00190 
<a name="l00191"></a>00191   LWIP_DEBUGF(<a class="code" href="opt_8h.html#ae7980c7f8eb45cd411bf410ff0a3fc55">TCP_QLEN_DEBUG</a>, (<span class="stringliteral">&quot;tcp_enqueue: queuelen: %&quot;</span>U16_F<span class="stringliteral">&quot;\n&quot;</span>, (<a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a>)pcb-&gt;snd_queuelen));
<a name="l00192"></a>00192 
<a name="l00193"></a>00193   <span class="comment">/* If total number of pbufs on the unsent/unacked queues exceeds the</span>
<a name="l00194"></a>00194 <span class="comment">   * configured maximum, return an error */</span>
<a name="l00195"></a>00195   queuelen = pcb-&gt;snd_queuelen;
<a name="l00196"></a>00196   <span class="comment">/* check for configured max queuelen and possible overflow */</span>
<a name="l00197"></a>00197   <span class="keywordflow">if</span> ((queuelen &gt;= <a class="code" href="opt_8h.html#a9beaa47832ead4180981bfbf71074904">TCP_SND_QUEUELEN</a>) || (queuelen &gt; TCP_SNDQUEUELEN_OVERFLOW)) {
<a name="l00198"></a>00198     LWIP_DEBUGF(<a class="code" href="opt_8h.html#a9f70601fdc1feee490772bf7fcdb74fb">TCP_OUTPUT_DEBUG</a> | LWIP_DBG_LEVEL_WARNING,
<a name="l00199"></a>00199       (<span class="stringliteral">&quot;tcp_enqueue: too long queue %&quot;</span>U16_F<span class="stringliteral">&quot; (max %&quot;</span>U16_F<span class="stringliteral">&quot;)\n&quot;</span>, queuelen, <a class="code" href="opt_8h.html#a9beaa47832ead4180981bfbf71074904">TCP_SND_QUEUELEN</a>));
<a name="l00200"></a>00200     TCP_STATS_INC(tcp.memerr);
<a name="l00201"></a>00201     pcb-&gt;flags |= TF_NAGLEMEMERR;
<a name="l00202"></a>00202     <span class="keywordflow">return</span> ERR_MEM;
<a name="l00203"></a>00203   }
<a name="l00204"></a>00204   <span class="keywordflow">if</span> (queuelen != 0) {
<a name="l00205"></a>00205     LWIP_ASSERT(<span class="stringliteral">&quot;tcp_enqueue: pbufs on queue =&gt; at least one queue non-empty&quot;</span>,
<a name="l00206"></a>00206       pcb-&gt;unacked != NULL || pcb-&gt;unsent != NULL);
<a name="l00207"></a>00207   } <span class="keywordflow">else</span> {
<a name="l00208"></a>00208     LWIP_ASSERT(<span class="stringliteral">&quot;tcp_enqueue: no pbufs on queue =&gt; both queues empty&quot;</span>,
<a name="l00209"></a>00209       pcb-&gt;unacked == NULL &amp;&amp; pcb-&gt;unsent == NULL);
<a name="l00210"></a>00210   }
<a name="l00211"></a>00211 
<a name="l00212"></a>00212   <span class="comment">/* First, break up the data into segments and tuck them together in</span>
<a name="l00213"></a>00213 <span class="comment">   * the local &quot;queue&quot; variable. */</span>
<a name="l00214"></a>00214   useg = queue = seg = NULL;
<a name="l00215"></a>00215   seglen = 0;
<a name="l00216"></a>00216   <span class="keywordflow">while</span> (queue == NULL || left &gt; 0) {
<a name="l00217"></a>00217     <span class="comment">/* The segment length (including options) should be at most the MSS */</span>
<a name="l00218"></a>00218     seglen = left &gt; (pcb-&gt;mss - optlen) ? (pcb-&gt;mss - optlen) : left;
<a name="l00219"></a>00219 
<a name="l00220"></a>00220     <span class="comment">/* Allocate memory for tcp_seg, and fill in fields. */</span>
<a name="l00221"></a>00221     seg = <a class="code" href="memp_8c.html#a2b00593d086313c267b54a976bf67aa5">memp_malloc</a>(MEMP_TCP_SEG);
<a name="l00222"></a>00222     <span class="keywordflow">if</span> (seg == NULL) {
<a name="l00223"></a>00223       LWIP_DEBUGF(<a class="code" href="opt_8h.html#a9f70601fdc1feee490772bf7fcdb74fb">TCP_OUTPUT_DEBUG</a> | LWIP_DBG_LEVEL_SERIOUS, 
<a name="l00224"></a>00224                   (<span class="stringliteral">&quot;tcp_enqueue: could not allocate memory for tcp_seg\n&quot;</span>));
<a name="l00225"></a>00225       <span class="keywordflow">goto</span> memerr;
<a name="l00226"></a>00226     }
<a name="l00227"></a>00227     seg-&gt;next = NULL;
<a name="l00228"></a>00228     seg-&gt;p = NULL;
<a name="l00229"></a>00229 
<a name="l00230"></a>00230     <span class="comment">/* first segment of to-be-queued data? */</span>
<a name="l00231"></a>00231     <span class="keywordflow">if</span> (queue == NULL) {
<a name="l00232"></a>00232       queue = seg;
<a name="l00233"></a>00233     }
<a name="l00234"></a>00234     <span class="comment">/* subsequent segments of to-be-queued data */</span>
<a name="l00235"></a>00235     <span class="keywordflow">else</span> {
<a name="l00236"></a>00236       <span class="comment">/* Attach the segment to the end of the queued segments */</span>
<a name="l00237"></a>00237       LWIP_ASSERT(<span class="stringliteral">&quot;useg != NULL&quot;</span>, useg != NULL);
<a name="l00238"></a>00238       useg-&gt;next = seg;
<a name="l00239"></a>00239     }
<a name="l00240"></a>00240     <span class="comment">/* remember last segment of to-be-queued data for next iteration */</span>
<a name="l00241"></a>00241     useg = seg;
<a name="l00242"></a>00242 
<a name="l00243"></a>00243     <span class="comment">/* If copy is set, memory should be allocated</span>
<a name="l00244"></a>00244 <span class="comment">     * and data copied into pbuf, otherwise data comes from</span>
<a name="l00245"></a>00245 <span class="comment">     * ROM or other static memory, and need not be copied.  */</span>
<a name="l00246"></a>00246     <span class="keywordflow">if</span> (apiflags &amp; TCP_WRITE_FLAG_COPY) {
<a name="l00247"></a>00247       <span class="keywordflow">if</span> ((seg-&gt;p = <a class="code" href="pbuf_8c.html#acfcb0a2af918658ba0afe36499c65f47">pbuf_alloc</a>(PBUF_TRANSPORT, seglen + optlen, PBUF_RAM)) == NULL) {
<a name="l00248"></a>00248         LWIP_DEBUGF(<a class="code" href="opt_8h.html#a9f70601fdc1feee490772bf7fcdb74fb">TCP_OUTPUT_DEBUG</a> | LWIP_DBG_LEVEL_SERIOUS, 
<a name="l00249"></a>00249                     (<span class="stringliteral">&quot;tcp_enqueue : could not allocate memory for pbuf copy size %&quot;</span>U16_F<span class="stringliteral">&quot;\n&quot;</span>, seglen));
<a name="l00250"></a>00250         <span class="keywordflow">goto</span> memerr;
<a name="l00251"></a>00251       }
<a name="l00252"></a>00252       LWIP_ASSERT(<span class="stringliteral">&quot;check that first pbuf can hold the complete seglen&quot;</span>,
<a name="l00253"></a>00253                   (seg-&gt;p-&gt;<a class="code" href="structpbuf.html#a6f82449625e36e294f5d210268c0703f">len</a> &gt;= seglen + optlen));
<a name="l00254"></a>00254       queuelen += <a class="code" href="pbuf_8c.html#a949a13a7cfdf9241c9e7b859af1bd15c">pbuf_clen</a>(seg-&gt;p);
<a name="l00255"></a>00255       <span class="keywordflow">if</span> (arg != NULL) {
<a name="l00256"></a>00256         <a class="code" href="opt_8h.html#aa1dd57a66b6de8c0593e9e3e8d1411f6">MEMCPY</a>((<span class="keywordtype">char</span> *)seg-&gt;p-&gt;<a class="code" href="structpbuf.html#a8d32dc3e964369d4eec638fc37fbc460">payload</a> + optlen, ptr, seglen);
<a name="l00257"></a>00257       }
<a name="l00258"></a>00258       seg-&gt;dataptr = seg-&gt;p-&gt;<a class="code" href="structpbuf.html#a8d32dc3e964369d4eec638fc37fbc460">payload</a>;
<a name="l00259"></a>00259     }
<a name="l00260"></a>00260     <span class="comment">/* do not copy data */</span>
<a name="l00261"></a>00261     <span class="keywordflow">else</span> {
<a name="l00262"></a>00262       <span class="comment">/* First, allocate a pbuf for the headers. */</span>
<a name="l00263"></a>00263       <span class="keywordflow">if</span> ((seg-&gt;p = <a class="code" href="pbuf_8c.html#acfcb0a2af918658ba0afe36499c65f47">pbuf_alloc</a>(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
<a name="l00264"></a>00264         LWIP_DEBUGF(<a class="code" href="opt_8h.html#a9f70601fdc1feee490772bf7fcdb74fb">TCP_OUTPUT_DEBUG</a> | LWIP_DBG_LEVEL_SERIOUS, 
<a name="l00265"></a>00265                     (<span class="stringliteral">&quot;tcp_enqueue: could not allocate memory for header pbuf\n&quot;</span>));
<a name="l00266"></a>00266         <span class="keywordflow">goto</span> memerr;
<a name="l00267"></a>00267       }
<a name="l00268"></a>00268       queuelen += <a class="code" href="pbuf_8c.html#a949a13a7cfdf9241c9e7b859af1bd15c">pbuf_clen</a>(seg-&gt;p);
<a name="l00269"></a>00269 
<a name="l00270"></a>00270       <span class="comment">/* Second, allocate a pbuf for holding the data.</span>
<a name="l00271"></a>00271 <span class="comment">       * since the referenced data is available at least until it is sent out on the</span>
<a name="l00272"></a>00272 <span class="comment">       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM</span>
<a name="l00273"></a>00273 <span class="comment">       * instead of PBUF_REF here.</span>
<a name="l00274"></a>00274 <span class="comment">       */</span>
<a name="l00275"></a>00275       <span class="keywordflow">if</span> (left &gt; 0) {
<a name="l00276"></a>00276         <span class="keywordflow">if</span> ((p = <a class="code" href="pbuf_8c.html#acfcb0a2af918658ba0afe36499c65f47">pbuf_alloc</a>(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
<a name="l00277"></a>00277           <span class="comment">/* If allocation fails, we have to deallocate the header pbuf as well. */</span>
<a name="l00278"></a>00278           <a class="code" href="pbuf_8c.html#ab0dd696fb4b6bc65e548944584f1738b">pbuf_free</a>(seg-&gt;p);
<a name="l00279"></a>00279           seg-&gt;p = NULL;
<a name="l00280"></a>00280           LWIP_DEBUGF(<a class="code" href="opt_8h.html#a9f70601fdc1feee490772bf7fcdb74fb">TCP_OUTPUT_DEBUG</a> | LWIP_DBG_LEVEL_SERIOUS, 
<a name="l00281"></a>00281                       (<span class="stringliteral">&quot;tcp_enqueue: could not allocate memory for zero-copy pbuf\n&quot;</span>));
<a name="l00282"></a>00282           <span class="keywordflow">goto</span> memerr;
<a name="l00283"></a>00283         }
<a name="l00284"></a>00284         ++queuelen;
<a name="l00285"></a>00285         <span class="comment">/* reference the non-volatile payload data */</span>
<a name="l00286"></a>00286         p-&gt;<a class="code" href="structpbuf.html#a8d32dc3e964369d4eec638fc37fbc460">payload</a> = ptr;
<a name="l00287"></a>00287         seg-&gt;dataptr = ptr;
<a name="l00288"></a>00288 
<a name="l00289"></a>00289         <span class="comment">/* Concatenate the headers and data pbufs together. */</span>
<a name="l00290"></a>00290         <a class="code" href="pbuf_8c.html#a82429084fe29015509c9b4a072707cd4">pbuf_cat</a>(seg-&gt;p<span class="comment">/*header*/</span>, p<span class="comment">/*data*/</span>);
<a name="l00291"></a>00291         p = NULL;
<a name="l00292"></a>00292       }
<a name="l00293"></a>00293     }
<a name="l00294"></a>00294 
<a name="l00295"></a>00295     <span class="comment">/* Now that there are more segments queued, we check again if the</span>
<a name="l00296"></a>00296 <span class="comment">    length of the queue exceeds the configured maximum or overflows. */</span>
<a name="l00297"></a>00297     <span class="keywordflow">if</span> ((queuelen &gt; <a class="code" href="opt_8h.html#a9beaa47832ead4180981bfbf71074904">TCP_SND_QUEUELEN</a>) || (queuelen &gt; TCP_SNDQUEUELEN_OVERFLOW)) {
<a name="l00298"></a>00298       LWIP_DEBUGF(<a class="code" href="opt_8h.html#a9f70601fdc1feee490772bf7fcdb74fb">TCP_OUTPUT_DEBUG</a> | LWIP_DBG_LEVEL_SERIOUS,
<a name="l00299"></a>00299         (<span class="stringliteral">&quot;tcp_enqueue: queue too long %&quot;</span>U16_F<span class="stringliteral">&quot; (%&quot;</span>U16_F<span class="stringliteral">&quot;)\n&quot;</span>, queuelen, <a class="code" href="opt_8h.html#a9beaa47832ead4180981bfbf71074904">TCP_SND_QUEUELEN</a>));
<a name="l00300"></a>00300       <span class="keywordflow">goto</span> memerr;
<a name="l00301"></a>00301     }
<a name="l00302"></a>00302 
<a name="l00303"></a>00303     seg-&gt;len = seglen;
<a name="l00304"></a>00304 
<a name="l00305"></a>00305     <span class="comment">/* build TCP header */</span>
<a name="l00306"></a>00306     <span class="keywordflow">if</span> (<a class="code" href="pbuf_8c.html#a0f81deff4a0e6e8e0ff161a7b9871449">pbuf_header</a>(seg-&gt;p, TCP_HLEN)) {
<a name="l00307"></a>00307       LWIP_DEBUGF(<a class="code" href="opt_8h.html#a9f70601fdc1feee490772bf7fcdb74fb">TCP_OUTPUT_DEBUG</a> | LWIP_DBG_LEVEL_SERIOUS, (<span class="stringliteral">&quot;tcp_enqueue: no room for TCP header in pbuf.\n&quot;</span>));
<a name="l00308"></a>00308       TCP_STATS_INC(tcp.err);
<a name="l00309"></a>00309       <span class="keywordflow">goto</span> memerr;
<a name="l00310"></a>00310     }
<a name="l00311"></a>00311     seg-&gt;tcphdr = seg-&gt;p-&gt;<a class="code" href="structpbuf.html#a8d32dc3e964369d4eec638fc37fbc460">payload</a>;
<a name="l00312"></a>00312     seg-&gt;tcphdr-&gt;src = <a class="code" href="group__uipconvfunc.html#gaa22b04cac8cf283ca12f028578bebc06">htons</a>(pcb-&gt;local_port);
<a name="l00313"></a>00313     seg-&gt;tcphdr-&gt;dest = <a class="code" href="group__uipconvfunc.html#gaa22b04cac8cf283ca12f028578bebc06">htons</a>(pcb-&gt;remote_port);
<a name="l00314"></a>00314     seg-&gt;tcphdr-&gt;seqno = <a class="code" href="inet_8c.html#aed84a49b499a0d09a1237113b85ad0ab">htonl</a>(seqno);
<a name="l00315"></a>00315     seg-&gt;tcphdr-&gt;urgp = 0;
<a name="l00316"></a>00316     TCPH_FLAGS_SET(seg-&gt;tcphdr, flags);
<a name="l00317"></a>00317     <span class="comment">/* don&#39;t fill in tcphdr-&gt;ackno and tcphdr-&gt;wnd until later */</span>
<a name="l00318"></a>00318 
<a name="l00319"></a>00319     seg-&gt;flags = optflags;
<a name="l00320"></a>00320 
<a name="l00321"></a>00321     <span class="comment">/* Set the length of the header */</span>
<a name="l00322"></a>00322     TCPH_HDRLEN_SET(seg-&gt;tcphdr, (5 + optlen / 4));
<a name="l00323"></a>00323     LWIP_DEBUGF(<a class="code" href="opt_8h.html#a9f70601fdc1feee490772bf7fcdb74fb">TCP_OUTPUT_DEBUG</a> | LWIP_DBG_TRACE, (<span class="stringliteral">&quot;tcp_enqueue: queueing %&quot;</span>U32_F<span class="stringliteral">&quot;:%&quot;</span>U32_F<span class="stringliteral">&quot; (0x%&quot;</span>X16_F<span class="stringliteral">&quot;)\n&quot;</span>,
<a name="l00324"></a>00324       <a class="code" href="inet_8c.html#ab3ef2c882ab42295feaa7cd7d5ca8b34">ntohl</a>(seg-&gt;tcphdr-&gt;seqno),
<a name="l00325"></a>00325       <a class="code" href="inet_8c.html#ab3ef2c882ab42295feaa7cd7d5ca8b34">ntohl</a>(seg-&gt;tcphdr-&gt;seqno) + TCP_TCPLEN(seg),
<a name="l00326"></a>00326       (<a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a>)flags));
<a name="l00327"></a>00327 
<a name="l00328"></a>00328     left -= seglen;
<a name="l00329"></a>00329     seqno += seglen;
<a name="l00330"></a>00330     ptr = (<span class="keywordtype">void</span> *)((<a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> *)ptr + seglen);
<a name="l00331"></a>00331   }
<a name="l00332"></a>00332 
<a name="l00333"></a>00333   <span class="comment">/* Now that the data to be enqueued has been broken up into TCP</span>
<a name="l00334"></a>00334 <span class="comment">  segments in the queue variable, we add them to the end of the</span>
<a name="l00335"></a>00335 <span class="comment">  pcb-&gt;unsent queue. */</span>
<a name="l00336"></a>00336   <span class="keywordflow">if</span> (pcb-&gt;unsent == NULL) {
<a name="l00337"></a>00337     useg = NULL;
<a name="l00338"></a>00338   }
<a name="l00339"></a>00339   <span class="keywordflow">else</span> {
<a name="l00340"></a>00340     <span class="keywordflow">for</span> (useg = pcb-&gt;unsent; useg-&gt;next != NULL; useg = useg-&gt;next);
<a name="l00341"></a>00341   }
<a name="l00342"></a>00342   <span class="comment">/* { useg is last segment on the unsent queue, NULL if list is empty } */</span>
<a name="l00343"></a>00343 
<a name="l00344"></a>00344   <span class="comment">/* If there is room in the last pbuf on the unsent queue,</span>
<a name="l00345"></a>00345 <span class="comment">  chain the first pbuf on the queue together with that. */</span>
<a name="l00346"></a>00346   <span class="keywordflow">if</span> (useg != NULL &amp;&amp;
<a name="l00347"></a>00347     TCP_TCPLEN(useg) != 0 &amp;&amp;
<a name="l00348"></a>00348     !(TCPH_FLAGS(useg-&gt;tcphdr) &amp; (TCP_SYN | TCP_FIN)) &amp;&amp;
<a name="l00349"></a>00349     (!(flags &amp; (TCP_SYN | TCP_FIN)) || (flags == TCP_FIN)) &amp;&amp;
<a name="l00350"></a>00350     <span class="comment">/* fit within max seg size */</span>
<a name="l00351"></a>00351     (useg-&gt;len + queue-&gt;len &lt;= pcb-&gt;mss) &amp;&amp;
<a name="l00352"></a>00352     <span class="comment">/* only concatenate segments with the same options */</span>
<a name="l00353"></a>00353     (useg-&gt;flags == queue-&gt;flags) &amp;&amp;
<a name="l00354"></a>00354     <span class="comment">/* segments are consecutive */</span>
<a name="l00355"></a>00355     (<a class="code" href="inet_8c.html#ab3ef2c882ab42295feaa7cd7d5ca8b34">ntohl</a>(useg-&gt;tcphdr-&gt;seqno) + useg-&gt;len == <a class="code" href="inet_8c.html#ab3ef2c882ab42295feaa7cd7d5ca8b34">ntohl</a>(queue-&gt;tcphdr-&gt;seqno)) ) {
<a name="l00356"></a>00356     <span class="comment">/* Remove TCP header from first segment of our to-be-queued list */</span>
<a name="l00357"></a>00357     <span class="keywordflow">if</span>(<a class="code" href="pbuf_8c.html#a0f81deff4a0e6e8e0ff161a7b9871449">pbuf_header</a>(queue-&gt;p, -(TCP_HLEN + optlen))) {
<a name="l00358"></a>00358       <span class="comment">/* Can we cope with this failing?  Just assert for now */</span>
<a name="l00359"></a>00359       LWIP_ASSERT(<span class="stringliteral">&quot;pbuf_header failed\n&quot;</span>, 0);
<a name="l00360"></a>00360       TCP_STATS_INC(tcp.err);
<a name="l00361"></a>00361       <span class="keywordflow">goto</span> memerr;
<a name="l00362"></a>00362     }
<a name="l00363"></a>00363     <span class="keywordflow">if</span> (queue-&gt;p-&gt;<a class="code" href="structpbuf.html#a6f82449625e36e294f5d210268c0703f">len</a> == 0) {
<a name="l00364"></a>00364       <span class="comment">/* free the first (header-only) pbuf if it is now empty (contained only headers) */</span>
<a name="l00365"></a>00365       <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *old_q = queue-&gt;p;
<a name="l00366"></a>00366       queue-&gt;p = queue-&gt;p-&gt;<a class="code" href="structpbuf.html#a5e5763c94fd18d78937b0b58ce7df341">next</a>;
<a name="l00367"></a>00367       old_q-&gt;<a class="code" href="structpbuf.html#a5e5763c94fd18d78937b0b58ce7df341">next</a> = NULL;
<a name="l00368"></a>00368       queuelen--;
<a name="l00369"></a>00369       <a class="code" href="pbuf_8c.html#ab0dd696fb4b6bc65e548944584f1738b">pbuf_free</a>(old_q);
<a name="l00370"></a>00370     }
<a name="l00371"></a>00371     <span class="keywordflow">if</span> (flags &amp; TCP_FIN) {
<a name="l00372"></a>00372       <span class="comment">/* the new segment contains only FIN, no data -&gt; put the FIN into the last segment */</span>
<a name="l00373"></a>00373       LWIP_ASSERT(<span class="stringliteral">&quot;FIN enqueued together with data&quot;</span>, queue-&gt;p == NULL &amp;&amp; queue-&gt;len == 0);
<a name="l00374"></a>00374       TCPH_SET_FLAG(useg-&gt;tcphdr, TCP_FIN);
<a name="l00375"></a>00375     } <span class="keywordflow">else</span> {
<a name="l00376"></a>00376       LWIP_ASSERT(<span class="stringliteral">&quot;zero-length pbuf&quot;</span>, (queue-&gt;p != NULL) &amp;&amp; (queue-&gt;p-&gt;<a class="code" href="structpbuf.html#a6f82449625e36e294f5d210268c0703f">len</a> &gt; 0));
<a name="l00377"></a>00377       <a class="code" href="pbuf_8c.html#a82429084fe29015509c9b4a072707cd4">pbuf_cat</a>(useg-&gt;p, queue-&gt;p);
<a name="l00378"></a>00378       useg-&gt;len += queue-&gt;len;
<a name="l00379"></a>00379       useg-&gt;next = queue-&gt;next;
<a name="l00380"></a>00380     }
<a name="l00381"></a>00381 
<a name="l00382"></a>00382     LWIP_DEBUGF(<a class="code" href="opt_8h.html#a9f70601fdc1feee490772bf7fcdb74fb">TCP_OUTPUT_DEBUG</a> | LWIP_DBG_TRACE | LWIP_DBG_STATE, (<span class="stringliteral">&quot;tcp_enqueue: chaining segments, new len %&quot;</span>U16_F<span class="stringliteral">&quot;\n&quot;</span>, useg-&gt;len));
<a name="l00383"></a>00383     <span class="keywordflow">if</span> (seg == queue) {
<a name="l00384"></a>00384       seg = useg;
<a name="l00385"></a>00385       seglen = useg-&gt;len;
<a name="l00386"></a>00386     }
<a name="l00387"></a>00387     <a class="code" href="memp_8c.html#aecd94926b7c2a0e23ae195f4ae97581f">memp_free</a>(MEMP_TCP_SEG, queue);
<a name="l00388"></a>00388   }
<a name="l00389"></a>00389   <span class="keywordflow">else</span> {
<a name="l00390"></a>00390     <span class="comment">/* empty list */</span>
<a name="l00391"></a>00391     <span class="keywordflow">if</span> (useg == NULL) {
<a name="l00392"></a>00392       <span class="comment">/* initialize list with this segment */</span>
<a name="l00393"></a>00393       pcb-&gt;unsent = queue;
<a name="l00394"></a>00394     }
<a name="l00395"></a>00395     <span class="comment">/* enqueue segment */</span>
<a name="l00396"></a>00396     <span class="keywordflow">else</span> {
<a name="l00397"></a>00397       useg-&gt;next = queue;
<a name="l00398"></a>00398     }
<a name="l00399"></a>00399   }
<a name="l00400"></a>00400   <span class="keywordflow">if</span> ((flags &amp; TCP_SYN) || (flags &amp; TCP_FIN)) {
<a name="l00401"></a>00401     ++len;
<a name="l00402"></a>00402   }
<a name="l00403"></a>00403   <span class="keywordflow">if</span> (flags &amp; TCP_FIN) {
<a name="l00404"></a>00404     pcb-&gt;flags |= TF_FIN;
<a name="l00405"></a>00405   }
<a name="l00406"></a>00406   pcb-&gt;snd_lbb += len;
<a name="l00407"></a>00407 
<a name="l00408"></a>00408   pcb-&gt;snd_buf -= len;
<a name="l00409"></a>00409 
<a name="l00410"></a>00410   <span class="comment">/* update number of segments on the queues */</span>
<a name="l00411"></a>00411   pcb-&gt;snd_queuelen = queuelen;
<a name="l00412"></a>00412   LWIP_DEBUGF(<a class="code" href="opt_8h.html#ae7980c7f8eb45cd411bf410ff0a3fc55">TCP_QLEN_DEBUG</a>, (<span class="stringliteral">&quot;tcp_enqueue: %&quot;</span>S16_F<span class="stringliteral">&quot; (after enqueued)\n&quot;</span>, pcb-&gt;snd_queuelen));
<a name="l00413"></a>00413   <span class="keywordflow">if</span> (pcb-&gt;snd_queuelen != 0) {
<a name="l00414"></a>00414     LWIP_ASSERT(<span class="stringliteral">&quot;tcp_enqueue: valid queue length&quot;</span>,
<a name="l00415"></a>00415       pcb-&gt;unacked != NULL || pcb-&gt;unsent != NULL);
<a name="l00416"></a>00416   }
<a name="l00417"></a>00417 
<a name="l00418"></a>00418   <span class="comment">/* Set the PSH flag in the last segment that we enqueued, but only</span>
<a name="l00419"></a>00419 <span class="comment">  if the segment has data (indicated by seglen &gt; 0). */</span>
<a name="l00420"></a>00420   <span class="keywordflow">if</span> (seg != NULL &amp;&amp; seglen &gt; 0 &amp;&amp; seg-&gt;tcphdr != NULL &amp;&amp; ((apiflags &amp; TCP_WRITE_FLAG_MORE)==0)) {
<a name="l00421"></a>00421     TCPH_SET_FLAG(seg-&gt;tcphdr, TCP_PSH);
<a name="l00422"></a>00422   }
<a name="l00423"></a>00423 
<a name="l00424"></a>00424   <span class="keywordflow">return</span> ERR_OK;
<a name="l00425"></a>00425 memerr:
<a name="l00426"></a>00426   pcb-&gt;flags |= TF_NAGLEMEMERR;
<a name="l00427"></a>00427   TCP_STATS_INC(tcp.memerr);
<a name="l00428"></a>00428 
<a name="l00429"></a>00429   <span class="keywordflow">if</span> (queue != NULL) {
<a name="l00430"></a>00430     <a class="code" href="tcp_8c.html#a1f6d5f868cfaf1a4d843f030d61c58ae">tcp_segs_free</a>(queue);
<a name="l00431"></a>00431   }
<a name="l00432"></a>00432   <span class="keywordflow">if</span> (pcb-&gt;snd_queuelen != 0) {
<a name="l00433"></a>00433     LWIP_ASSERT(<span class="stringliteral">&quot;tcp_enqueue: valid queue length&quot;</span>, pcb-&gt;unacked != NULL ||
<a name="l00434"></a>00434       pcb-&gt;unsent != NULL);
<a name="l00435"></a>00435   }
<a name="l00436"></a>00436   LWIP_DEBUGF(<a class="code" href="opt_8h.html#ae7980c7f8eb45cd411bf410ff0a3fc55">TCP_QLEN_DEBUG</a> | LWIP_DBG_STATE, (<span class="stringliteral">&quot;tcp_enqueue: %&quot;</span>S16_F<span class="stringliteral">&quot; (with mem err)\n&quot;</span>, pcb-&gt;snd_queuelen));
<a name="l00437"></a>00437   <span class="keywordflow">return</span> ERR_MEM;
<a name="l00438"></a>00438 }
<a name="l00439"></a>00439 
<a name="l00440"></a>00440 
<a name="l00441"></a>00441 <span class="preprocessor">#if LWIP_TCP_TIMESTAMPS</span>
<a name="l00442"></a>00442 <span class="preprocessor"></span><span class="comment">/* Build a timestamp option (12 bytes long) at the specified options pointer)</span>
<a name="l00443"></a>00443 <span class="comment"> *</span>
<a name="l00444"></a>00444 <span class="comment"> * @param pcb tcp_pcb</span>
<a name="l00445"></a>00445 <span class="comment"> * @param opts option pointer where to store the timestamp option</span>
<a name="l00446"></a>00446 <span class="comment"> */</span>
<a name="l00447"></a>00447 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00448"></a>00448 tcp_build_timestamp_option(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, u32_t *opts)
<a name="l00449"></a>00449 {
<a name="l00450"></a>00450   <span class="comment">/* Pad with two NOP options to make everything nicely aligned */</span>
<a name="l00451"></a>00451   opts[0] = <a class="code" href="inet_8c.html#aed84a49b499a0d09a1237113b85ad0ab">htonl</a>(0x0101080A);
<a name="l00452"></a>00452   opts[1] = <a class="code" href="inet_8c.html#aed84a49b499a0d09a1237113b85ad0ab">htonl</a>(sys_now());
<a name="l00453"></a>00453   opts[2] = <a class="code" href="inet_8c.html#aed84a49b499a0d09a1237113b85ad0ab">htonl</a>(pcb-&gt;ts_recent);
<a name="l00454"></a>00454 }
<a name="l00455"></a>00455 <span class="preprocessor">#endif</span>
<a name="l00456"></a>00456 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00457"></a>00457 <span class="comment">/** Send an ACK without data.</span>
<a name="l00458"></a>00458 <span class="comment"> *</span>
<a name="l00459"></a>00459 <span class="comment"> * @param pcb Protocol control block for the TCP connection to send the ACK</span>
<a name="l00460"></a>00460 <span class="comment"> */</span>
<a name="l00461"></a>00461 err_t
<a name="l00462"></a><a class="code" href="tcp__out_8c.html#aefde3e34b2cc8df9654986484c44a996">00462</a> <a class="code" href="tcp__out_8c.html#aefde3e34b2cc8df9654986484c44a996">tcp_send_empty_ack</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb)
<a name="l00463"></a>00463 {
<a name="l00464"></a>00464   <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *p;
<a name="l00465"></a>00465   <span class="keyword">struct </span><a class="code" href="structtcp__hdr.html">tcp_hdr</a> *tcphdr;
<a name="l00466"></a>00466   <a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> optlen = 0;
<a name="l00467"></a>00467 
<a name="l00468"></a>00468 <span class="preprocessor">#if LWIP_TCP_TIMESTAMPS</span>
<a name="l00469"></a>00469 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (pcb-&gt;flags &amp; TF_TIMESTAMP) {
<a name="l00470"></a>00470     optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
<a name="l00471"></a>00471   }
<a name="l00472"></a>00472 <span class="preprocessor">#endif</span>
<a name="l00473"></a>00473 <span class="preprocessor"></span>  p = <a class="code" href="pbuf_8c.html#acfcb0a2af918658ba0afe36499c65f47">pbuf_alloc</a>(PBUF_IP, TCP_HLEN + optlen, PBUF_RAM);
<a name="l00474"></a>00474   <span class="keywordflow">if</span> (p == NULL) {
<a name="l00475"></a>00475     LWIP_DEBUGF(<a class="code" href="opt_8h.html#a9f70601fdc1feee490772bf7fcdb74fb">TCP_OUTPUT_DEBUG</a>, (<span class="stringliteral">&quot;tcp_output: (ACK) could not allocate pbuf\n&quot;</span>));
<a name="l00476"></a>00476     <span class="keywordflow">return</span> ERR_BUF;
<a name="l00477"></a>00477   }
<a name="l00478"></a>00478   LWIP_DEBUGF(<a class="code" href="opt_8h.html#a9f70601fdc1feee490772bf7fcdb74fb">TCP_OUTPUT_DEBUG</a>, 
<a name="l00479"></a>00479               (<span class="stringliteral">&quot;tcp_output: sending ACK for %&quot;</span>U32_F<span class="stringliteral">&quot;\n&quot;</span>, pcb-&gt;rcv_nxt));
<a name="l00480"></a>00480   <span class="comment">/* remove ACK flags from the PCB, as we send an empty ACK now */</span>
<a name="l00481"></a>00481   pcb-&gt;flags &amp;= ~(TF_ACK_DELAY | TF_ACK_NOW);
<a name="l00482"></a>00482 
<a name="l00483"></a>00483   tcphdr = tcp_output_set_header(pcb, p, optlen, <a class="code" href="inet_8c.html#aed84a49b499a0d09a1237113b85ad0ab">htonl</a>(pcb-&gt;snd_nxt));
<a name="l00484"></a>00484 
<a name="l00485"></a>00485   <span class="comment">/* NB. MSS option is only sent on SYNs, so ignore it here */</span>
<a name="l00486"></a>00486 <span class="preprocessor">#if LWIP_TCP_TIMESTAMPS</span>
<a name="l00487"></a>00487 <span class="preprocessor"></span>  pcb-&gt;ts_lastacksent = pcb-&gt;rcv_nxt;
<a name="l00488"></a>00488 
<a name="l00489"></a>00489   <span class="keywordflow">if</span> (pcb-&gt;flags &amp; TF_TIMESTAMP) {
<a name="l00490"></a>00490     tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
<a name="l00491"></a>00491   }
<a name="l00492"></a>00492 <span class="preprocessor">#endif </span>
<a name="l00493"></a>00493 <span class="preprocessor"></span>
<a name="l00494"></a>00494 <span class="preprocessor">#if CHECKSUM_GEN_TCP</span>
<a name="l00495"></a>00495 <span class="preprocessor"></span>  tcphdr-&gt;chksum = inet_chksum_pseudo(p, &amp;(pcb-&gt;local_ip), &amp;(pcb-&gt;remote_ip),
<a name="l00496"></a>00496         IP_PROTO_TCP, p-&gt;<a class="code" href="structpbuf.html#a5259e7ec29bab9c0999b64f2e86b411f">tot_len</a>);
<a name="l00497"></a>00497 <span class="preprocessor">#endif</span>
<a name="l00498"></a>00498 <span class="preprocessor"></span><span class="preprocessor">#if LWIP_NETIF_HWADDRHINT</span>
<a name="l00499"></a>00499 <span class="preprocessor"></span>  ip_output_hinted(p, &amp;(pcb-&gt;local_ip), &amp;(pcb-&gt;remote_ip), pcb-&gt;ttl, pcb-&gt;tos,
<a name="l00500"></a>00500       IP_PROTO_TCP, &amp;(pcb-&gt;addr_hint));
<a name="l00501"></a>00501 <span class="preprocessor">#else </span><span class="comment">/* LWIP_NETIF_HWADDRHINT*/</span>
<a name="l00502"></a>00502   <a class="code" href="ip_8c.html#aabccfd6ab4e3c73350c4014158cd4d2b">ip_output</a>(p, &amp;(pcb-&gt;local_ip), &amp;(pcb-&gt;remote_ip), pcb-&gt;ttl, pcb-&gt;tos,
<a name="l00503"></a>00503       IP_PROTO_TCP);
<a name="l00504"></a>00504 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_NETIF_HWADDRHINT*/</span>
<a name="l00505"></a>00505   <a class="code" href="pbuf_8c.html#ab0dd696fb4b6bc65e548944584f1738b">pbuf_free</a>(p);
<a name="l00506"></a>00506 
<a name="l00507"></a>00507   <span class="keywordflow">return</span> ERR_OK;
<a name="l00508"></a>00508 }
<a name="l00509"></a>00509 <span class="comment"></span>
<a name="l00510"></a>00510 <span class="comment">/**</span>
<a name="l00511"></a>00511 <span class="comment"> * Find out what we can send and send it</span>
<a name="l00512"></a>00512 <span class="comment"> *</span>
<a name="l00513"></a>00513 <span class="comment"> * @param pcb Protocol control block for the TCP connection to send data</span>
<a name="l00514"></a>00514 <span class="comment"> * @return ERR_OK if data has been sent or nothing to send</span>
<a name="l00515"></a>00515 <span class="comment"> *         another err_t on error</span>
<a name="l00516"></a>00516 <span class="comment"> */</span>
<a name="l00517"></a>00517 err_t
<a name="l00518"></a><a class="code" href="tcp__out_8c.html#a0cbcc6d628f644a530daf629fa3e5f7f">00518</a> <a class="code" href="tcp__out_8c.html#a0cbcc6d628f644a530daf629fa3e5f7f">tcp_output</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb)
<a name="l00519"></a>00519 {
<a name="l00520"></a>00520   <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> *seg, *useg;
<a name="l00521"></a>00521   u32_t wnd, snd_nxt;
<a name="l00522"></a>00522 <span class="preprocessor">#if TCP_CWND_DEBUG</span>
<a name="l00523"></a>00523 <span class="preprocessor"></span>  s16_t i = 0;
<a name="l00524"></a>00524 <span class="preprocessor">#endif </span><span class="comment">/* TCP_CWND_DEBUG */</span>
<a name="l00525"></a>00525 
<a name="l00526"></a>00526   <span class="comment">/* First, check if we are invoked by the TCP input processing</span>
<a name="l00527"></a>00527 <span class="comment">     code. If so, we do not output anything. Instead, we rely on the</span>
<a name="l00528"></a>00528 <span class="comment">     input processing code to call us when input processing is done</span>
<a name="l00529"></a>00529 <span class="comment">     with. */</span>
<a name="l00530"></a>00530   <span class="keywordflow">if</span> (tcp_input_pcb == pcb) {
<a name="l00531"></a>00531     <span class="keywordflow">return</span> ERR_OK;
<a name="l00532"></a>00532   }
<a name="l00533"></a>00533 
<a name="l00534"></a>00534   wnd = LWIP_MIN(pcb-&gt;snd_wnd, pcb-&gt;cwnd);
<a name="l00535"></a>00535 
<a name="l00536"></a>00536   seg = pcb-&gt;unsent;
<a name="l00537"></a>00537 
<a name="l00538"></a>00538   <span class="comment">/* If the TF_ACK_NOW flag is set and no data will be sent (either</span>
<a name="l00539"></a>00539 <span class="comment">   * because the -&gt;unsent queue is empty or because the window does</span>
<a name="l00540"></a>00540 <span class="comment">   * not allow it), construct an empty ACK segment and send it.</span>
<a name="l00541"></a>00541 <span class="comment">   *</span>
<a name="l00542"></a>00542 <span class="comment">   * If data is to be sent, we will just piggyback the ACK (see below).</span>
<a name="l00543"></a>00543 <span class="comment">   */</span>
<a name="l00544"></a>00544   <span class="keywordflow">if</span> (pcb-&gt;flags &amp; TF_ACK_NOW &amp;&amp;
<a name="l00545"></a>00545      (seg == NULL ||
<a name="l00546"></a>00546       <a class="code" href="inet_8c.html#ab3ef2c882ab42295feaa7cd7d5ca8b34">ntohl</a>(seg-&gt;tcphdr-&gt;seqno) - pcb-&gt;lastack + seg-&gt;len &gt; wnd)) {
<a name="l00547"></a>00547      <span class="keywordflow">return</span> <a class="code" href="tcp__out_8c.html#aefde3e34b2cc8df9654986484c44a996">tcp_send_empty_ack</a>(pcb);
<a name="l00548"></a>00548   }
<a name="l00549"></a>00549 
<a name="l00550"></a>00550   <span class="comment">/* useg should point to last segment on unacked queue */</span>
<a name="l00551"></a>00551   useg = pcb-&gt;unacked;
<a name="l00552"></a>00552   <span class="keywordflow">if</span> (useg != NULL) {
<a name="l00553"></a>00553     <span class="keywordflow">for</span> (; useg-&gt;next != NULL; useg = useg-&gt;next);
<a name="l00554"></a>00554   }
<a name="l00555"></a>00555 
<a name="l00556"></a>00556 <span class="preprocessor">#if TCP_OUTPUT_DEBUG</span>
<a name="l00557"></a>00557 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (seg == NULL) {
<a name="l00558"></a>00558     LWIP_DEBUGF(<a class="code" href="opt_8h.html#a9f70601fdc1feee490772bf7fcdb74fb">TCP_OUTPUT_DEBUG</a>, (<span class="stringliteral">&quot;tcp_output: nothing to send (%p)\n&quot;</span>,
<a name="l00559"></a>00559                                    (<span class="keywordtype">void</span>*)pcb-&gt;unsent));
<a name="l00560"></a>00560   }
<a name="l00561"></a>00561 <span class="preprocessor">#endif </span><span class="comment">/* TCP_OUTPUT_DEBUG */</span>
<a name="l00562"></a>00562 <span class="preprocessor">#if TCP_CWND_DEBUG</span>
<a name="l00563"></a>00563 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (seg == NULL) {
<a name="l00564"></a>00564     LWIP_DEBUGF(<a class="code" href="opt_8h.html#a66df03d8192cd978d3321a9d68bf5411">TCP_CWND_DEBUG</a>, (<span class="stringliteral">&quot;tcp_output: snd_wnd %&quot;</span>U16_F
<a name="l00565"></a>00565                                  <span class="stringliteral">&quot;, cwnd %&quot;</span>U16_F<span class="stringliteral">&quot;, wnd %&quot;</span>U32_F
<a name="l00566"></a>00566                                  <span class="stringliteral">&quot;, seg == NULL, ack %&quot;</span>U32_F<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00567"></a>00567                                  pcb-&gt;snd_wnd, pcb-&gt;cwnd, wnd, pcb-&gt;lastack));
<a name="l00568"></a>00568   } <span class="keywordflow">else</span> {
<a name="l00569"></a>00569     LWIP_DEBUGF(<a class="code" href="opt_8h.html#a66df03d8192cd978d3321a9d68bf5411">TCP_CWND_DEBUG</a>, 
<a name="l00570"></a>00570                 (<span class="stringliteral">&quot;tcp_output: snd_wnd %&quot;</span>U16_F<span class="stringliteral">&quot;, cwnd %&quot;</span>U16_F<span class="stringliteral">&quot;, wnd %&quot;</span>U32_F
<a name="l00571"></a>00571                  <span class="stringliteral">&quot;, effwnd %&quot;</span>U32_F<span class="stringliteral">&quot;, seq %&quot;</span>U32_F<span class="stringliteral">&quot;, ack %&quot;</span>U32_F<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00572"></a>00572                  pcb-&gt;snd_wnd, pcb-&gt;cwnd, wnd,
<a name="l00573"></a>00573                  <a class="code" href="inet_8c.html#ab3ef2c882ab42295feaa7cd7d5ca8b34">ntohl</a>(seg-&gt;tcphdr-&gt;seqno) - pcb-&gt;lastack + seg-&gt;len,
<a name="l00574"></a>00574                  <a class="code" href="inet_8c.html#ab3ef2c882ab42295feaa7cd7d5ca8b34">ntohl</a>(seg-&gt;tcphdr-&gt;seqno), pcb-&gt;lastack));
<a name="l00575"></a>00575   }
<a name="l00576"></a>00576 <span class="preprocessor">#endif </span><span class="comment">/* TCP_CWND_DEBUG */</span>
<a name="l00577"></a>00577   <span class="comment">/* data available and window allows it to be sent? */</span>
<a name="l00578"></a>00578   <span class="keywordflow">while</span> (seg != NULL &amp;&amp;
<a name="l00579"></a>00579          <a class="code" href="inet_8c.html#ab3ef2c882ab42295feaa7cd7d5ca8b34">ntohl</a>(seg-&gt;tcphdr-&gt;seqno) - pcb-&gt;lastack + seg-&gt;len &lt;= wnd) {
<a name="l00580"></a>00580     LWIP_ASSERT(<span class="stringliteral">&quot;RST not expected here!&quot;</span>, 
<a name="l00581"></a>00581                 (TCPH_FLAGS(seg-&gt;tcphdr) &amp; TCP_RST) == 0);
<a name="l00582"></a>00582     <span class="comment">/* Stop sending if the nagle algorithm would prevent it</span>
<a name="l00583"></a>00583 <span class="comment">     * Don&#39;t stop:</span>
<a name="l00584"></a>00584 <span class="comment">     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or</span>
<a name="l00585"></a>00585 <span class="comment">     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -</span>
<a name="l00586"></a>00586 <span class="comment">     *   either seg-&gt;next != NULL or pcb-&gt;unacked == NULL;</span>
<a name="l00587"></a>00587 <span class="comment">     *   RST is no sent using tcp_enqueue/tcp_output.</span>
<a name="l00588"></a>00588 <span class="comment">     */</span>
<a name="l00589"></a>00589     <span class="keywordflow">if</span>((tcp_do_output_nagle(pcb) == 0) &amp;&amp;
<a name="l00590"></a>00590       ((pcb-&gt;flags &amp; (TF_NAGLEMEMERR | TF_FIN)) == 0)){
<a name="l00591"></a>00591       <span class="keywordflow">break</span>;
<a name="l00592"></a>00592     }
<a name="l00593"></a>00593 <span class="preprocessor">#if TCP_CWND_DEBUG</span>
<a name="l00594"></a>00594 <span class="preprocessor"></span>    LWIP_DEBUGF(<a class="code" href="opt_8h.html#a66df03d8192cd978d3321a9d68bf5411">TCP_CWND_DEBUG</a>, (<span class="stringliteral">&quot;tcp_output: snd_wnd %&quot;</span>U16_F<span class="stringliteral">&quot;, cwnd %&quot;</span>U16_F<span class="stringliteral">&quot;, wnd %&quot;</span>U32_F<span class="stringliteral">&quot;, effwnd %&quot;</span>U32_F<span class="stringliteral">&quot;, seq %&quot;</span>U32_F<span class="stringliteral">&quot;, ack %&quot;</span>U32_F<span class="stringliteral">&quot;, i %&quot;</span>S16_F<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00595"></a>00595                             pcb-&gt;snd_wnd, pcb-&gt;cwnd, wnd,
<a name="l00596"></a>00596                             <a class="code" href="inet_8c.html#ab3ef2c882ab42295feaa7cd7d5ca8b34">ntohl</a>(seg-&gt;tcphdr-&gt;seqno) + seg-&gt;len -
<a name="l00597"></a>00597                             pcb-&gt;lastack,
<a name="l00598"></a>00598                             <a class="code" href="inet_8c.html#ab3ef2c882ab42295feaa7cd7d5ca8b34">ntohl</a>(seg-&gt;tcphdr-&gt;seqno), pcb-&gt;lastack, i));
<a name="l00599"></a>00599     ++i;
<a name="l00600"></a>00600 <span class="preprocessor">#endif </span><span class="comment">/* TCP_CWND_DEBUG */</span>
<a name="l00601"></a>00601 
<a name="l00602"></a>00602     pcb-&gt;unsent = seg-&gt;next;
<a name="l00603"></a>00603 
<a name="l00604"></a>00604     <span class="keywordflow">if</span> (pcb-&gt;state != SYN_SENT) {
<a name="l00605"></a>00605       TCPH_SET_FLAG(seg-&gt;tcphdr, TCP_ACK);
<a name="l00606"></a>00606       pcb-&gt;flags &amp;= ~(TF_ACK_DELAY | TF_ACK_NOW);
<a name="l00607"></a>00607     }
<a name="l00608"></a>00608 
<a name="l00609"></a>00609     tcp_output_segment(seg, pcb);
<a name="l00610"></a>00610     snd_nxt = <a class="code" href="inet_8c.html#ab3ef2c882ab42295feaa7cd7d5ca8b34">ntohl</a>(seg-&gt;tcphdr-&gt;seqno) + TCP_TCPLEN(seg);
<a name="l00611"></a>00611     <span class="keywordflow">if</span> (TCP_SEQ_LT(pcb-&gt;snd_nxt, snd_nxt)) {
<a name="l00612"></a>00612       pcb-&gt;snd_nxt = snd_nxt;
<a name="l00613"></a>00613     }
<a name="l00614"></a>00614     <span class="comment">/* put segment on unacknowledged list if length &gt; 0 */</span>
<a name="l00615"></a>00615     <span class="keywordflow">if</span> (TCP_TCPLEN(seg) &gt; 0) {
<a name="l00616"></a>00616       seg-&gt;next = NULL;
<a name="l00617"></a>00617       <span class="comment">/* unacked list is empty? */</span>
<a name="l00618"></a>00618       <span class="keywordflow">if</span> (pcb-&gt;unacked == NULL) {
<a name="l00619"></a>00619         pcb-&gt;unacked = seg;
<a name="l00620"></a>00620         useg = seg;
<a name="l00621"></a>00621       <span class="comment">/* unacked list is not empty? */</span>
<a name="l00622"></a>00622       } <span class="keywordflow">else</span> {
<a name="l00623"></a>00623         <span class="comment">/* In the case of fast retransmit, the packet should not go to the tail</span>
<a name="l00624"></a>00624 <span class="comment">         * of the unacked queue, but rather somewhere before it. We need to check for</span>
<a name="l00625"></a>00625 <span class="comment">         * this case. -STJ Jul 27, 2004 */</span>
<a name="l00626"></a>00626         <span class="keywordflow">if</span> (TCP_SEQ_LT(<a class="code" href="inet_8c.html#ab3ef2c882ab42295feaa7cd7d5ca8b34">ntohl</a>(seg-&gt;tcphdr-&gt;seqno), <a class="code" href="inet_8c.html#ab3ef2c882ab42295feaa7cd7d5ca8b34">ntohl</a>(useg-&gt;tcphdr-&gt;seqno))){
<a name="l00627"></a>00627           <span class="comment">/* add segment to before tail of unacked list, keeping the list sorted */</span>
<a name="l00628"></a>00628           <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> **cur_seg = &amp;(pcb-&gt;unacked);
<a name="l00629"></a>00629           <span class="keywordflow">while</span> (*cur_seg &amp;&amp;
<a name="l00630"></a>00630             TCP_SEQ_LT(<a class="code" href="inet_8c.html#ab3ef2c882ab42295feaa7cd7d5ca8b34">ntohl</a>((*cur_seg)-&gt;tcphdr-&gt;seqno), <a class="code" href="inet_8c.html#ab3ef2c882ab42295feaa7cd7d5ca8b34">ntohl</a>(seg-&gt;tcphdr-&gt;seqno))) {
<a name="l00631"></a>00631               cur_seg = &amp;((*cur_seg)-&gt;next );
<a name="l00632"></a>00632           }
<a name="l00633"></a>00633           seg-&gt;next = (*cur_seg);
<a name="l00634"></a>00634           (*cur_seg) = seg;
<a name="l00635"></a>00635         } <span class="keywordflow">else</span> {
<a name="l00636"></a>00636           <span class="comment">/* add segment to tail of unacked list */</span>
<a name="l00637"></a>00637           useg-&gt;next = seg;
<a name="l00638"></a>00638           useg = useg-&gt;next;
<a name="l00639"></a>00639         }
<a name="l00640"></a>00640       }
<a name="l00641"></a>00641     <span class="comment">/* do not queue empty segments on the unacked list */</span>
<a name="l00642"></a>00642     } <span class="keywordflow">else</span> {
<a name="l00643"></a>00643       <a class="code" href="tcp_8c.html#a404539c2e8a6e38e2d57042225a96b40">tcp_seg_free</a>(seg);
<a name="l00644"></a>00644     }
<a name="l00645"></a>00645     seg = pcb-&gt;unsent;
<a name="l00646"></a>00646   }
<a name="l00647"></a>00647 
<a name="l00648"></a>00648   <span class="keywordflow">if</span> (seg != NULL &amp;&amp; pcb-&gt;persist_backoff == 0 &amp;&amp; 
<a name="l00649"></a>00649       <a class="code" href="inet_8c.html#ab3ef2c882ab42295feaa7cd7d5ca8b34">ntohl</a>(seg-&gt;tcphdr-&gt;seqno) - pcb-&gt;lastack + seg-&gt;len &gt; pcb-&gt;snd_wnd) {
<a name="l00650"></a>00650     <span class="comment">/* prepare for persist timer */</span>
<a name="l00651"></a>00651     pcb-&gt;persist_cnt = 0;
<a name="l00652"></a>00652     pcb-&gt;persist_backoff = 1;
<a name="l00653"></a>00653   }
<a name="l00654"></a>00654 
<a name="l00655"></a>00655   pcb-&gt;flags &amp;= ~TF_NAGLEMEMERR;
<a name="l00656"></a>00656   <span class="keywordflow">return</span> ERR_OK;
<a name="l00657"></a>00657 }
<a name="l00658"></a>00658 <span class="comment"></span>
<a name="l00659"></a>00659 <span class="comment">/**</span>
<a name="l00660"></a>00660 <span class="comment"> * Called by tcp_output() to actually send a TCP segment over IP.</span>
<a name="l00661"></a>00661 <span class="comment"> *</span>
<a name="l00662"></a>00662 <span class="comment"> * @param seg the tcp_seg to send</span>
<a name="l00663"></a>00663 <span class="comment"> * @param pcb the tcp_pcb for the TCP connection used to send the segment</span>
<a name="l00664"></a>00664 <span class="comment"> */</span>
<a name="l00665"></a>00665 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00666"></a>00666 tcp_output_segment(<span class="keyword">struct</span> <a class="code" href="structtcp__seg.html">tcp_seg</a> *seg, <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb)
<a name="l00667"></a>00667 {
<a name="l00668"></a>00668   <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> len;
<a name="l00669"></a>00669   <span class="keyword">struct </span><a class="code" href="structnetif.html">netif</a> *<a class="code" href="structnetif.html">netif</a>;
<a name="l00670"></a>00670   u32_t *opts;
<a name="l00671"></a>00671 <span class="comment"></span>
<a name="l00672"></a>00672 <span class="comment">  /** @bug Exclude retransmitted segments from this count. */</span>
<a name="l00673"></a>00673   snmp_inc_tcpoutsegs();
<a name="l00674"></a>00674 
<a name="l00675"></a>00675   <span class="comment">/* The TCP header has already been constructed, but the ackno and</span>
<a name="l00676"></a>00676 <span class="comment">   wnd fields remain. */</span>
<a name="l00677"></a>00677   seg-&gt;tcphdr-&gt;ackno = <a class="code" href="inet_8c.html#aed84a49b499a0d09a1237113b85ad0ab">htonl</a>(pcb-&gt;rcv_nxt);
<a name="l00678"></a>00678 
<a name="l00679"></a>00679   <span class="comment">/* advertise our receive window size in this TCP segment */</span>
<a name="l00680"></a>00680   seg-&gt;tcphdr-&gt;wnd = <a class="code" href="group__uipconvfunc.html#gaa22b04cac8cf283ca12f028578bebc06">htons</a>(pcb-&gt;rcv_ann_wnd);
<a name="l00681"></a>00681 
<a name="l00682"></a>00682   pcb-&gt;rcv_ann_right_edge = pcb-&gt;rcv_nxt + pcb-&gt;rcv_ann_wnd;
<a name="l00683"></a>00683 
<a name="l00684"></a>00684   <span class="comment">/* Add any requested options.  NB MSS option is only set on SYN</span>
<a name="l00685"></a>00685 <span class="comment">     packets, so ignore it here */</span>
<a name="l00686"></a>00686   opts = (u32_t *)(seg-&gt;tcphdr + 1);
<a name="l00687"></a>00687   <span class="keywordflow">if</span> (seg-&gt;flags &amp; TF_SEG_OPTS_MSS) {
<a name="l00688"></a>00688     TCP_BUILD_MSS_OPTION(*opts);
<a name="l00689"></a>00689     opts += 1;
<a name="l00690"></a>00690   }
<a name="l00691"></a>00691 <span class="preprocessor">#if LWIP_TCP_TIMESTAMPS</span>
<a name="l00692"></a>00692 <span class="preprocessor"></span>  pcb-&gt;ts_lastacksent = pcb-&gt;rcv_nxt;
<a name="l00693"></a>00693 
<a name="l00694"></a>00694   <span class="keywordflow">if</span> (seg-&gt;flags &amp; TF_SEG_OPTS_TS) {
<a name="l00695"></a>00695     tcp_build_timestamp_option(pcb, opts);
<a name="l00696"></a>00696     opts += 3;
<a name="l00697"></a>00697   }
<a name="l00698"></a>00698 <span class="preprocessor">#endif</span>
<a name="l00699"></a>00699 <span class="preprocessor"></span>
<a name="l00700"></a>00700   <span class="comment">/* If we don&#39;t have a local IP address, we get one by</span>
<a name="l00701"></a>00701 <span class="comment">     calling ip_route(). */</span>
<a name="l00702"></a>00702   <span class="keywordflow">if</span> (ip_addr_isany(&amp;(pcb-&gt;local_ip))) {
<a name="l00703"></a>00703     netif = <a class="code" href="ip_8c.html#a27aecc05841bdece5d6bed810cc0ce71">ip_route</a>(&amp;(pcb-&gt;remote_ip));
<a name="l00704"></a>00704     <span class="keywordflow">if</span> (netif == NULL) {
<a name="l00705"></a>00705       <span class="keywordflow">return</span>;
<a name="l00706"></a>00706     }
<a name="l00707"></a>00707     ip_addr_set(&amp;(pcb-&gt;local_ip), &amp;(netif-&gt;<a class="code" href="structnetif.html#ad666097c02e7d7e82ea838b0c721470d">ip_addr</a>));
<a name="l00708"></a>00708   }
<a name="l00709"></a>00709 
<a name="l00710"></a>00710   <span class="comment">/* Set retransmission timer running if it is not currently enabled */</span>
<a name="l00711"></a>00711   <span class="keywordflow">if</span>(pcb-&gt;rtime == -1)
<a name="l00712"></a>00712     pcb-&gt;rtime = 0;
<a name="l00713"></a>00713 
<a name="l00714"></a>00714   <span class="keywordflow">if</span> (pcb-&gt;rttest == 0) {
<a name="l00715"></a>00715     pcb-&gt;rttest = tcp_ticks;
<a name="l00716"></a>00716     pcb-&gt;rtseq = <a class="code" href="inet_8c.html#ab3ef2c882ab42295feaa7cd7d5ca8b34">ntohl</a>(seg-&gt;tcphdr-&gt;seqno);
<a name="l00717"></a>00717 
<a name="l00718"></a>00718     LWIP_DEBUGF(<a class="code" href="opt_8h.html#ad6e52e37415d0d0cbe4931a28f5a9662">TCP_RTO_DEBUG</a>, (<span class="stringliteral">&quot;tcp_output_segment: rtseq %&quot;</span>U32_F<span class="stringliteral">&quot;\n&quot;</span>, pcb-&gt;rtseq));
<a name="l00719"></a>00719   }
<a name="l00720"></a>00720   LWIP_DEBUGF(<a class="code" href="opt_8h.html#a9f70601fdc1feee490772bf7fcdb74fb">TCP_OUTPUT_DEBUG</a>, (<span class="stringliteral">&quot;tcp_output_segment: %&quot;</span>U32_F<span class="stringliteral">&quot;:%&quot;</span>U32_F<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00721"></a>00721           <a class="code" href="inet_8c.html#aed84a49b499a0d09a1237113b85ad0ab">htonl</a>(seg-&gt;tcphdr-&gt;seqno), <a class="code" href="inet_8c.html#aed84a49b499a0d09a1237113b85ad0ab">htonl</a>(seg-&gt;tcphdr-&gt;seqno) +
<a name="l00722"></a>00722           seg-&gt;len));
<a name="l00723"></a>00723 
<a name="l00724"></a>00724   len = (u16_t)((<a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> *)seg-&gt;tcphdr - (<a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> *)seg-&gt;p-&gt;<a class="code" href="structpbuf.html#a8d32dc3e964369d4eec638fc37fbc460">payload</a>);
<a name="l00725"></a>00725 
<a name="l00726"></a>00726   seg-&gt;p-&gt;<a class="code" href="structpbuf.html#a6f82449625e36e294f5d210268c0703f">len</a> -= len;
<a name="l00727"></a>00727   seg-&gt;p-&gt;<a class="code" href="structpbuf.html#a5259e7ec29bab9c0999b64f2e86b411f">tot_len</a> -= len;
<a name="l00728"></a>00728 
<a name="l00729"></a>00729   seg-&gt;p-&gt;<a class="code" href="structpbuf.html#a8d32dc3e964369d4eec638fc37fbc460">payload</a> = seg-&gt;tcphdr;
<a name="l00730"></a>00730 
<a name="l00731"></a>00731   seg-&gt;tcphdr-&gt;chksum = 0;
<a name="l00732"></a>00732 <span class="preprocessor">#if CHECKSUM_GEN_TCP</span>
<a name="l00733"></a>00733 <span class="preprocessor"></span>  seg-&gt;tcphdr-&gt;chksum = inet_chksum_pseudo(seg-&gt;p,
<a name="l00734"></a>00734              &amp;(pcb-&gt;local_ip),
<a name="l00735"></a>00735              &amp;(pcb-&gt;remote_ip),
<a name="l00736"></a>00736              IP_PROTO_TCP, seg-&gt;p-&gt;<a class="code" href="structpbuf.html#a5259e7ec29bab9c0999b64f2e86b411f">tot_len</a>);
<a name="l00737"></a>00737 <span class="preprocessor">#endif</span>
<a name="l00738"></a>00738 <span class="preprocessor"></span>  TCP_STATS_INC(tcp.xmit);
<a name="l00739"></a>00739 
<a name="l00740"></a>00740 <span class="preprocessor">#if LWIP_NETIF_HWADDRHINT</span>
<a name="l00741"></a>00741 <span class="preprocessor"></span>  ip_output_hinted(seg-&gt;p, &amp;(pcb-&gt;local_ip), &amp;(pcb-&gt;remote_ip), pcb-&gt;ttl, pcb-&gt;tos,
<a name="l00742"></a>00742       IP_PROTO_TCP, &amp;(pcb-&gt;addr_hint));
<a name="l00743"></a>00743 <span class="preprocessor">#else </span><span class="comment">/* LWIP_NETIF_HWADDRHINT*/</span>
<a name="l00744"></a>00744   <a class="code" href="ip_8c.html#aabccfd6ab4e3c73350c4014158cd4d2b">ip_output</a>(seg-&gt;p, &amp;(pcb-&gt;local_ip), &amp;(pcb-&gt;remote_ip), pcb-&gt;ttl, pcb-&gt;tos,
<a name="l00745"></a>00745       IP_PROTO_TCP);
<a name="l00746"></a>00746 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_NETIF_HWADDRHINT*/</span>
<a name="l00747"></a>00747 }
<a name="l00748"></a>00748 <span class="comment"></span>
<a name="l00749"></a>00749 <span class="comment">/**</span>
<a name="l00750"></a>00750 <span class="comment"> * Send a TCP RESET packet (empty segment with RST flag set) either to</span>
<a name="l00751"></a>00751 <span class="comment"> * abort a connection or to show that there is no matching local connection</span>
<a name="l00752"></a>00752 <span class="comment"> * for a received segment.</span>
<a name="l00753"></a>00753 <span class="comment"> *</span>
<a name="l00754"></a>00754 <span class="comment"> * Called by tcp_abort() (to abort a local connection), tcp_input() (if no</span>
<a name="l00755"></a>00755 <span class="comment"> * matching local pcb was found), tcp_listen_input() (if incoming segment</span>
<a name="l00756"></a>00756 <span class="comment"> * has ACK flag set) and tcp_process() (received segment in the wrong state)</span>
<a name="l00757"></a>00757 <span class="comment"> *</span>
<a name="l00758"></a>00758 <span class="comment"> * Since a RST segment is in most cases not sent for an active connection,</span>
<a name="l00759"></a>00759 <span class="comment"> * tcp_rst() has a number of arguments that are taken from a tcp_pcb for</span>
<a name="l00760"></a>00760 <span class="comment"> * most other segment output functions.</span>
<a name="l00761"></a>00761 <span class="comment"> *</span>
<a name="l00762"></a>00762 <span class="comment"> * @param seqno the sequence number to use for the outgoing segment</span>
<a name="l00763"></a>00763 <span class="comment"> * @param ackno the acknowledge number to use for the outgoing segment</span>
<a name="l00764"></a>00764 <span class="comment"> * @param local_ip the local IP address to send the segment from</span>
<a name="l00765"></a>00765 <span class="comment"> * @param remote_ip the remote IP address to send the segment to</span>
<a name="l00766"></a>00766 <span class="comment"> * @param local_port the local TCP port to send the segment from</span>
<a name="l00767"></a>00767 <span class="comment"> * @param remote_port the remote TCP port to send the segment to</span>
<a name="l00768"></a>00768 <span class="comment"> */</span>
<a name="l00769"></a>00769 <span class="keywordtype">void</span>
<a name="l00770"></a><a class="code" href="tcp__out_8c.html#a168fa0bb172bb0bd29bd58e31f804147">00770</a> <a class="code" href="tcp__out_8c.html#a168fa0bb172bb0bd29bd58e31f804147">tcp_rst</a>(u32_t seqno, u32_t ackno,
<a name="l00771"></a>00771   <span class="keyword">struct</span> <a class="code" href="structip__addr.html">ip_addr</a> *local_ip, <span class="keyword">struct</span> <a class="code" href="structip__addr.html">ip_addr</a> *remote_ip,
<a name="l00772"></a>00772   <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> local_port, <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> remote_port)
<a name="l00773"></a>00773 {
<a name="l00774"></a>00774   <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *p;
<a name="l00775"></a>00775   <span class="keyword">struct </span><a class="code" href="structtcp__hdr.html">tcp_hdr</a> *tcphdr;
<a name="l00776"></a>00776   p = <a class="code" href="pbuf_8c.html#acfcb0a2af918658ba0afe36499c65f47">pbuf_alloc</a>(PBUF_IP, TCP_HLEN, PBUF_RAM);
<a name="l00777"></a>00777   <span class="keywordflow">if</span> (p == NULL) {
<a name="l00778"></a>00778       LWIP_DEBUGF(<a class="code" href="opt_8h.html#a4f43bb8a430c7a52a1ad5086d3f2803c">TCP_DEBUG</a>, (<span class="stringliteral">&quot;tcp_rst: could not allocate memory for pbuf\n&quot;</span>));
<a name="l00779"></a>00779       <span class="keywordflow">return</span>;
<a name="l00780"></a>00780   }
<a name="l00781"></a>00781   LWIP_ASSERT(<span class="stringliteral">&quot;check that first pbuf can hold struct tcp_hdr&quot;</span>,
<a name="l00782"></a>00782               (p-&gt;<a class="code" href="structpbuf.html#a6f82449625e36e294f5d210268c0703f">len</a> &gt;= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structtcp__hdr.html">tcp_hdr</a>)));
<a name="l00783"></a>00783 
<a name="l00784"></a>00784   tcphdr = p-&gt;<a class="code" href="structpbuf.html#a8d32dc3e964369d4eec638fc37fbc460">payload</a>;
<a name="l00785"></a>00785   tcphdr-&gt;src = <a class="code" href="group__uipconvfunc.html#gaa22b04cac8cf283ca12f028578bebc06">htons</a>(local_port);
<a name="l00786"></a>00786   tcphdr-&gt;dest = <a class="code" href="group__uipconvfunc.html#gaa22b04cac8cf283ca12f028578bebc06">htons</a>(remote_port);
<a name="l00787"></a>00787   tcphdr-&gt;seqno = <a class="code" href="inet_8c.html#aed84a49b499a0d09a1237113b85ad0ab">htonl</a>(seqno);
<a name="l00788"></a>00788   tcphdr-&gt;ackno = <a class="code" href="inet_8c.html#aed84a49b499a0d09a1237113b85ad0ab">htonl</a>(ackno);
<a name="l00789"></a>00789   TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
<a name="l00790"></a>00790   tcphdr-&gt;wnd = <a class="code" href="group__uipconvfunc.html#gaa22b04cac8cf283ca12f028578bebc06">htons</a>(<a class="code" href="opt_8h.html#a7f535a6efb5cdf86c3210e35ece1d6a7">TCP_WND</a>);
<a name="l00791"></a>00791   tcphdr-&gt;urgp = 0;
<a name="l00792"></a>00792   TCPH_HDRLEN_SET(tcphdr, 5);
<a name="l00793"></a>00793 
<a name="l00794"></a>00794   tcphdr-&gt;chksum = 0;
<a name="l00795"></a>00795 <span class="preprocessor">#if CHECKSUM_GEN_TCP</span>
<a name="l00796"></a>00796 <span class="preprocessor"></span>  tcphdr-&gt;chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
<a name="l00797"></a>00797               IP_PROTO_TCP, p-&gt;<a class="code" href="structpbuf.html#a5259e7ec29bab9c0999b64f2e86b411f">tot_len</a>);
<a name="l00798"></a>00798 <span class="preprocessor">#endif</span>
<a name="l00799"></a>00799 <span class="preprocessor"></span>  TCP_STATS_INC(tcp.xmit);
<a name="l00800"></a>00800   snmp_inc_tcpoutrsts();
<a name="l00801"></a>00801    <span class="comment">/* Send output with hardcoded TTL since we have no access to the pcb */</span>
<a name="l00802"></a>00802   <a class="code" href="ip_8c.html#aabccfd6ab4e3c73350c4014158cd4d2b">ip_output</a>(p, local_ip, remote_ip, <a class="code" href="opt_8h.html#acd5b25ea81d2894790d25da5393cdab4">TCP_TTL</a>, 0, IP_PROTO_TCP);
<a name="l00803"></a>00803   <a class="code" href="pbuf_8c.html#ab0dd696fb4b6bc65e548944584f1738b">pbuf_free</a>(p);
<a name="l00804"></a>00804   LWIP_DEBUGF(<a class="code" href="opt_8h.html#a37596f7bbb9b7663826244ba54486679">TCP_RST_DEBUG</a>, (<span class="stringliteral">&quot;tcp_rst: seqno %&quot;</span>U32_F<span class="stringliteral">&quot; ackno %&quot;</span>U32_F<span class="stringliteral">&quot;.\n&quot;</span>, seqno, ackno));
<a name="l00805"></a>00805 }
<a name="l00806"></a>00806 <span class="comment"></span>
<a name="l00807"></a>00807 <span class="comment">/**</span>
<a name="l00808"></a>00808 <span class="comment"> * Requeue all unacked segments for retransmission</span>
<a name="l00809"></a>00809 <span class="comment"> *</span>
<a name="l00810"></a>00810 <span class="comment"> * Called by tcp_slowtmr() for slow retransmission.</span>
<a name="l00811"></a>00811 <span class="comment"> *</span>
<a name="l00812"></a>00812 <span class="comment"> * @param pcb the tcp_pcb for which to re-enqueue all unacked segments</span>
<a name="l00813"></a>00813 <span class="comment"> */</span>
<a name="l00814"></a>00814 <span class="keywordtype">void</span>
<a name="l00815"></a><a class="code" href="tcp__out_8c.html#ab5ef9c8ab4629eb721987ae316b9f30f">00815</a> <a class="code" href="tcp__out_8c.html#ab5ef9c8ab4629eb721987ae316b9f30f">tcp_rexmit_rto</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb)
<a name="l00816"></a>00816 {
<a name="l00817"></a>00817   <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> *seg;
<a name="l00818"></a>00818 
<a name="l00819"></a>00819   <span class="keywordflow">if</span> (pcb-&gt;unacked == NULL) {
<a name="l00820"></a>00820     <span class="keywordflow">return</span>;
<a name="l00821"></a>00821   }
<a name="l00822"></a>00822 
<a name="l00823"></a>00823   <span class="comment">/* Move all unacked segments to the head of the unsent queue */</span>
<a name="l00824"></a>00824   <span class="keywordflow">for</span> (seg = pcb-&gt;unacked; seg-&gt;next != NULL; seg = seg-&gt;next);
<a name="l00825"></a>00825   <span class="comment">/* concatenate unsent queue after unacked queue */</span>
<a name="l00826"></a>00826   seg-&gt;next = pcb-&gt;unsent;
<a name="l00827"></a>00827   <span class="comment">/* unsent queue is the concatenated queue (of unacked, unsent) */</span>
<a name="l00828"></a>00828   pcb-&gt;unsent = pcb-&gt;unacked;
<a name="l00829"></a>00829   <span class="comment">/* unacked queue is now empty */</span>
<a name="l00830"></a>00830   pcb-&gt;unacked = NULL;
<a name="l00831"></a>00831 
<a name="l00832"></a>00832   <span class="comment">/* increment number of retransmissions */</span>
<a name="l00833"></a>00833   ++pcb-&gt;nrtx;
<a name="l00834"></a>00834 
<a name="l00835"></a>00835   <span class="comment">/* Don&#39;t take any RTT measurements after retransmitting. */</span>
<a name="l00836"></a>00836   pcb-&gt;rttest = 0;
<a name="l00837"></a>00837 
<a name="l00838"></a>00838   <span class="comment">/* Do the actual retransmission */</span>
<a name="l00839"></a>00839   <a class="code" href="tcp__out_8c.html#a0cbcc6d628f644a530daf629fa3e5f7f">tcp_output</a>(pcb);
<a name="l00840"></a>00840 }
<a name="l00841"></a>00841 <span class="comment"></span>
<a name="l00842"></a>00842 <span class="comment">/**</span>
<a name="l00843"></a>00843 <span class="comment"> * Requeue the first unacked segment for retransmission</span>
<a name="l00844"></a>00844 <span class="comment"> *</span>
<a name="l00845"></a>00845 <span class="comment"> * Called by tcp_receive() for fast retramsmit.</span>
<a name="l00846"></a>00846 <span class="comment"> *</span>
<a name="l00847"></a>00847 <span class="comment"> * @param pcb the tcp_pcb for which to retransmit the first unacked segment</span>
<a name="l00848"></a>00848 <span class="comment"> */</span>
<a name="l00849"></a>00849 <span class="keywordtype">void</span>
<a name="l00850"></a><a class="code" href="tcp__out_8c.html#a0520917abc5f5ae56e39d632131a69b7">00850</a> <a class="code" href="tcp__out_8c.html#a0520917abc5f5ae56e39d632131a69b7">tcp_rexmit</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb)
<a name="l00851"></a>00851 {
<a name="l00852"></a>00852   <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> *seg;
<a name="l00853"></a>00853   <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> **cur_seg;
<a name="l00854"></a>00854 
<a name="l00855"></a>00855   <span class="keywordflow">if</span> (pcb-&gt;unacked == NULL) {
<a name="l00856"></a>00856     <span class="keywordflow">return</span>;
<a name="l00857"></a>00857   }
<a name="l00858"></a>00858 
<a name="l00859"></a>00859   <span class="comment">/* Move the first unacked segment to the unsent queue */</span>
<a name="l00860"></a>00860   <span class="comment">/* Keep the unsent queue sorted. */</span>
<a name="l00861"></a>00861   seg = pcb-&gt;unacked;
<a name="l00862"></a>00862   pcb-&gt;unacked = seg-&gt;next;
<a name="l00863"></a>00863 
<a name="l00864"></a>00864   cur_seg = &amp;(pcb-&gt;unsent);
<a name="l00865"></a>00865   <span class="keywordflow">while</span> (*cur_seg &amp;&amp;
<a name="l00866"></a>00866     TCP_SEQ_LT(<a class="code" href="inet_8c.html#ab3ef2c882ab42295feaa7cd7d5ca8b34">ntohl</a>((*cur_seg)-&gt;tcphdr-&gt;seqno), <a class="code" href="inet_8c.html#ab3ef2c882ab42295feaa7cd7d5ca8b34">ntohl</a>(seg-&gt;tcphdr-&gt;seqno))) {
<a name="l00867"></a>00867       cur_seg = &amp;((*cur_seg)-&gt;next );
<a name="l00868"></a>00868   }
<a name="l00869"></a>00869   seg-&gt;next = *cur_seg;
<a name="l00870"></a>00870   *cur_seg = seg;
<a name="l00871"></a>00871 
<a name="l00872"></a>00872   ++pcb-&gt;nrtx;
<a name="l00873"></a>00873 
<a name="l00874"></a>00874   <span class="comment">/* Don&#39;t take any rtt measurements after retransmitting. */</span>
<a name="l00875"></a>00875   pcb-&gt;rttest = 0;
<a name="l00876"></a>00876 
<a name="l00877"></a>00877   <span class="comment">/* Do the actual retransmission. */</span>
<a name="l00878"></a>00878   snmp_inc_tcpretranssegs();
<a name="l00879"></a>00879   <span class="comment">/* No need to call tcp_output: we are always called from tcp_input()</span>
<a name="l00880"></a>00880 <span class="comment">     and thus tcp_output directly returns. */</span>
<a name="l00881"></a>00881 }
<a name="l00882"></a>00882 
<a name="l00883"></a>00883 <span class="comment"></span>
<a name="l00884"></a>00884 <span class="comment">/**</span>
<a name="l00885"></a>00885 <span class="comment"> * Handle retransmission after three dupacks received</span>
<a name="l00886"></a>00886 <span class="comment"> *</span>
<a name="l00887"></a>00887 <span class="comment"> * @param pcb the tcp_pcb for which to retransmit the first unacked segment</span>
<a name="l00888"></a>00888 <span class="comment"> */</span>
<a name="l00889"></a>00889 <span class="keywordtype">void</span> 
<a name="l00890"></a><a class="code" href="tcp__out_8c.html#adb6ee7b4d59f125cc8bfac3bb5ca3937">00890</a> <a class="code" href="tcp__out_8c.html#adb6ee7b4d59f125cc8bfac3bb5ca3937">tcp_rexmit_fast</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb)
<a name="l00891"></a>00891 {
<a name="l00892"></a>00892   <span class="keywordflow">if</span> (pcb-&gt;unacked != NULL &amp;&amp; !(pcb-&gt;flags &amp; TF_INFR)) {
<a name="l00893"></a>00893     <span class="comment">/* This is fast retransmit. Retransmit the first unacked segment. */</span>
<a name="l00894"></a>00894     LWIP_DEBUGF(<a class="code" href="opt_8h.html#a5895bee26e8e1a0b89d597e0f2580b23">TCP_FR_DEBUG</a>, 
<a name="l00895"></a>00895                 (<span class="stringliteral">&quot;tcp_receive: dupacks %&quot;</span>U16_F<span class="stringliteral">&quot; (%&quot;</span>U32_F
<a name="l00896"></a>00896                  <span class="stringliteral">&quot;), fast retransmit %&quot;</span>U32_F<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00897"></a>00897                  (<a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a>)pcb-&gt;dupacks, pcb-&gt;lastack,
<a name="l00898"></a>00898                  <a class="code" href="inet_8c.html#ab3ef2c882ab42295feaa7cd7d5ca8b34">ntohl</a>(pcb-&gt;unacked-&gt;tcphdr-&gt;seqno)));
<a name="l00899"></a>00899     <a class="code" href="tcp__out_8c.html#a0520917abc5f5ae56e39d632131a69b7">tcp_rexmit</a>(pcb);
<a name="l00900"></a>00900 
<a name="l00901"></a>00901     <span class="comment">/* Set ssthresh to half of the minimum of the current</span>
<a name="l00902"></a>00902 <span class="comment">     * cwnd and the advertised window */</span>
<a name="l00903"></a>00903     <span class="keywordflow">if</span> (pcb-&gt;cwnd &gt; pcb-&gt;snd_wnd)
<a name="l00904"></a>00904       pcb-&gt;ssthresh = pcb-&gt;snd_wnd / 2;
<a name="l00905"></a>00905     <span class="keywordflow">else</span>
<a name="l00906"></a>00906       pcb-&gt;ssthresh = pcb-&gt;cwnd / 2;
<a name="l00907"></a>00907     
<a name="l00908"></a>00908     <span class="comment">/* The minimum value for ssthresh should be 2 MSS */</span>
<a name="l00909"></a>00909     <span class="keywordflow">if</span> (pcb-&gt;ssthresh &lt; 2*pcb-&gt;mss) {
<a name="l00910"></a>00910       LWIP_DEBUGF(<a class="code" href="opt_8h.html#a5895bee26e8e1a0b89d597e0f2580b23">TCP_FR_DEBUG</a>, 
<a name="l00911"></a>00911                   (<span class="stringliteral">&quot;tcp_receive: The minimum value for ssthresh %&quot;</span>U16_F
<a name="l00912"></a>00912                    <span class="stringliteral">&quot; should be min 2 mss %&quot;</span>U16_F<span class="stringliteral">&quot;...\n&quot;</span>,
<a name="l00913"></a>00913                    pcb-&gt;ssthresh, 2*pcb-&gt;mss));
<a name="l00914"></a>00914       pcb-&gt;ssthresh = 2*pcb-&gt;mss;
<a name="l00915"></a>00915     }
<a name="l00916"></a>00916     
<a name="l00917"></a>00917     pcb-&gt;cwnd = pcb-&gt;ssthresh + 3 * pcb-&gt;mss;
<a name="l00918"></a>00918     pcb-&gt;flags |= TF_INFR;
<a name="l00919"></a>00919   } 
<a name="l00920"></a>00920 }
<a name="l00921"></a>00921 
<a name="l00922"></a>00922 <span class="comment"></span>
<a name="l00923"></a>00923 <span class="comment">/**</span>
<a name="l00924"></a>00924 <span class="comment"> * Send keepalive packets to keep a connection active although</span>
<a name="l00925"></a>00925 <span class="comment"> * no data is sent over it.</span>
<a name="l00926"></a>00926 <span class="comment"> *</span>
<a name="l00927"></a>00927 <span class="comment"> * Called by tcp_slowtmr()</span>
<a name="l00928"></a>00928 <span class="comment"> *</span>
<a name="l00929"></a>00929 <span class="comment"> * @param pcb the tcp_pcb for which to send a keepalive packet</span>
<a name="l00930"></a>00930 <span class="comment"> */</span>
<a name="l00931"></a>00931 <span class="keywordtype">void</span>
<a name="l00932"></a><a class="code" href="tcp__out_8c.html#a13fd5160cf75d19d6696c27d7becf3d9">00932</a> <a class="code" href="tcp__out_8c.html#a13fd5160cf75d19d6696c27d7becf3d9">tcp_keepalive</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb)
<a name="l00933"></a>00933 {
<a name="l00934"></a>00934   <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *p;
<a name="l00935"></a>00935   <span class="keyword">struct </span><a class="code" href="structtcp__hdr.html">tcp_hdr</a> *tcphdr;
<a name="l00936"></a>00936 
<a name="l00937"></a>00937   LWIP_DEBUGF(<a class="code" href="opt_8h.html#a4f43bb8a430c7a52a1ad5086d3f2803c">TCP_DEBUG</a>, (<span class="stringliteral">&quot;tcp_keepalive: sending KEEPALIVE probe to %&quot;</span>U16_F<span class="stringliteral">&quot;.%&quot;</span>U16_F<span class="stringliteral">&quot;.%&quot;</span>U16_F<span class="stringliteral">&quot;.%&quot;</span>U16_F<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00938"></a>00938                           ip4_addr1(&amp;pcb-&gt;remote_ip), ip4_addr2(&amp;pcb-&gt;remote_ip),
<a name="l00939"></a>00939                           ip4_addr3(&amp;pcb-&gt;remote_ip), ip4_addr4(&amp;pcb-&gt;remote_ip)));
<a name="l00940"></a>00940 
<a name="l00941"></a>00941   LWIP_DEBUGF(<a class="code" href="opt_8h.html#a4f43bb8a430c7a52a1ad5086d3f2803c">TCP_DEBUG</a>, (<span class="stringliteral">&quot;tcp_keepalive: tcp_ticks %&quot;</span>U32_F<span class="stringliteral">&quot;   pcb-&gt;tmr %&quot;</span>U32_F<span class="stringliteral">&quot; pcb-&gt;keep_cnt_sent %&quot;</span>U16_F<span class="stringliteral">&quot;\n&quot;</span>, 
<a name="l00942"></a>00942                           tcp_ticks, pcb-&gt;tmr, pcb-&gt;keep_cnt_sent));
<a name="l00943"></a>00943    
<a name="l00944"></a>00944   p = <a class="code" href="pbuf_8c.html#acfcb0a2af918658ba0afe36499c65f47">pbuf_alloc</a>(PBUF_IP, TCP_HLEN, PBUF_RAM);
<a name="l00945"></a>00945    
<a name="l00946"></a>00946   <span class="keywordflow">if</span>(p == NULL) {
<a name="l00947"></a>00947     LWIP_DEBUGF(<a class="code" href="opt_8h.html#a4f43bb8a430c7a52a1ad5086d3f2803c">TCP_DEBUG</a>, 
<a name="l00948"></a>00948                 (<span class="stringliteral">&quot;tcp_keepalive: could not allocate memory for pbuf\n&quot;</span>));
<a name="l00949"></a>00949     <span class="keywordflow">return</span>;
<a name="l00950"></a>00950   }
<a name="l00951"></a>00951   LWIP_ASSERT(<span class="stringliteral">&quot;check that first pbuf can hold struct tcp_hdr&quot;</span>,
<a name="l00952"></a>00952               (p-&gt;<a class="code" href="structpbuf.html#a6f82449625e36e294f5d210268c0703f">len</a> &gt;= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structtcp__hdr.html">tcp_hdr</a>)));
<a name="l00953"></a>00953 
<a name="l00954"></a>00954   tcphdr = tcp_output_set_header(pcb, p, 0, <a class="code" href="inet_8c.html#aed84a49b499a0d09a1237113b85ad0ab">htonl</a>(pcb-&gt;snd_nxt - 1));
<a name="l00955"></a>00955 
<a name="l00956"></a>00956 <span class="preprocessor">#if CHECKSUM_GEN_TCP</span>
<a name="l00957"></a>00957 <span class="preprocessor"></span>  tcphdr-&gt;chksum = inet_chksum_pseudo(p, &amp;pcb-&gt;local_ip, &amp;pcb-&gt;remote_ip,
<a name="l00958"></a>00958                                       IP_PROTO_TCP, p-&gt;<a class="code" href="structpbuf.html#a5259e7ec29bab9c0999b64f2e86b411f">tot_len</a>);
<a name="l00959"></a>00959 <span class="preprocessor">#endif</span>
<a name="l00960"></a>00960 <span class="preprocessor"></span>  TCP_STATS_INC(tcp.xmit);
<a name="l00961"></a>00961 
<a name="l00962"></a>00962   <span class="comment">/* Send output to IP */</span>
<a name="l00963"></a>00963 <span class="preprocessor">#if LWIP_NETIF_HWADDRHINT</span>
<a name="l00964"></a>00964 <span class="preprocessor"></span>  ip_output_hinted(p, &amp;pcb-&gt;local_ip, &amp;pcb-&gt;remote_ip, pcb-&gt;ttl, 0, IP_PROTO_TCP,
<a name="l00965"></a>00965     &amp;(pcb-&gt;addr_hint));
<a name="l00966"></a>00966 <span class="preprocessor">#else </span><span class="comment">/* LWIP_NETIF_HWADDRHINT*/</span>
<a name="l00967"></a>00967   <a class="code" href="ip_8c.html#aabccfd6ab4e3c73350c4014158cd4d2b">ip_output</a>(p, &amp;pcb-&gt;local_ip, &amp;pcb-&gt;remote_ip, pcb-&gt;ttl, 0, IP_PROTO_TCP);
<a name="l00968"></a>00968 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_NETIF_HWADDRHINT*/</span>
<a name="l00969"></a>00969 
<a name="l00970"></a>00970   <a class="code" href="pbuf_8c.html#ab0dd696fb4b6bc65e548944584f1738b">pbuf_free</a>(p);
<a name="l00971"></a>00971 
<a name="l00972"></a>00972   LWIP_DEBUGF(<a class="code" href="opt_8h.html#a4f43bb8a430c7a52a1ad5086d3f2803c">TCP_DEBUG</a>, (<span class="stringliteral">&quot;tcp_keepalive: seqno %&quot;</span>U32_F<span class="stringliteral">&quot; ackno %&quot;</span>U32_F<span class="stringliteral">&quot;.\n&quot;</span>,
<a name="l00973"></a>00973                           pcb-&gt;snd_nxt - 1, pcb-&gt;rcv_nxt));
<a name="l00974"></a>00974 }
<a name="l00975"></a>00975 
<a name="l00976"></a>00976 <span class="comment"></span>
<a name="l00977"></a>00977 <span class="comment">/**</span>
<a name="l00978"></a>00978 <span class="comment"> * Send persist timer zero-window probes to keep a connection active</span>
<a name="l00979"></a>00979 <span class="comment"> * when a window update is lost.</span>
<a name="l00980"></a>00980 <span class="comment"> *</span>
<a name="l00981"></a>00981 <span class="comment"> * Called by tcp_slowtmr()</span>
<a name="l00982"></a>00982 <span class="comment"> *</span>
<a name="l00983"></a>00983 <span class="comment"> * @param pcb the tcp_pcb for which to send a zero-window probe packet</span>
<a name="l00984"></a>00984 <span class="comment"> */</span>
<a name="l00985"></a>00985 <span class="keywordtype">void</span>
<a name="l00986"></a><a class="code" href="tcp__out_8c.html#a5f0813be2b0fe0852da63d55660c722c">00986</a> <a class="code" href="tcp__out_8c.html#a5f0813be2b0fe0852da63d55660c722c">tcp_zero_window_probe</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb)
<a name="l00987"></a>00987 {
<a name="l00988"></a>00988   <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *p;
<a name="l00989"></a>00989   <span class="keyword">struct </span><a class="code" href="structtcp__hdr.html">tcp_hdr</a> *tcphdr;
<a name="l00990"></a>00990   <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> *seg;
<a name="l00991"></a>00991   <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> len;
<a name="l00992"></a>00992   <a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> is_fin;
<a name="l00993"></a>00993 
<a name="l00994"></a>00994   LWIP_DEBUGF(<a class="code" href="opt_8h.html#a4f43bb8a430c7a52a1ad5086d3f2803c">TCP_DEBUG</a>, 
<a name="l00995"></a>00995               (<span class="stringliteral">&quot;tcp_zero_window_probe: sending ZERO WINDOW probe to %&quot;</span>
<a name="l00996"></a>00996                U16_F<span class="stringliteral">&quot;.%&quot;</span>U16_F<span class="stringliteral">&quot;.%&quot;</span>U16_F<span class="stringliteral">&quot;.%&quot;</span>U16_F<span class="stringliteral">&quot;\n&quot;</span>,
<a name="l00997"></a>00997                ip4_addr1(&amp;pcb-&gt;remote_ip), ip4_addr2(&amp;pcb-&gt;remote_ip),
<a name="l00998"></a>00998                ip4_addr3(&amp;pcb-&gt;remote_ip), ip4_addr4(&amp;pcb-&gt;remote_ip)));
<a name="l00999"></a>00999 
<a name="l01000"></a>01000   LWIP_DEBUGF(<a class="code" href="opt_8h.html#a4f43bb8a430c7a52a1ad5086d3f2803c">TCP_DEBUG</a>, 
<a name="l01001"></a>01001               (<span class="stringliteral">&quot;tcp_zero_window_probe: tcp_ticks %&quot;</span>U32_F
<a name="l01002"></a>01002                <span class="stringliteral">&quot;   pcb-&gt;tmr %&quot;</span>U32_F<span class="stringliteral">&quot; pcb-&gt;keep_cnt_sent %&quot;</span>U16_F<span class="stringliteral">&quot;\n&quot;</span>, 
<a name="l01003"></a>01003                tcp_ticks, pcb-&gt;tmr, pcb-&gt;keep_cnt_sent));
<a name="l01004"></a>01004 
<a name="l01005"></a>01005   seg = pcb-&gt;unacked;
<a name="l01006"></a>01006 
<a name="l01007"></a>01007   <span class="keywordflow">if</span>(seg == NULL)
<a name="l01008"></a>01008     seg = pcb-&gt;unsent;
<a name="l01009"></a>01009 
<a name="l01010"></a>01010   <span class="keywordflow">if</span>(seg == NULL)
<a name="l01011"></a>01011     <span class="keywordflow">return</span>;
<a name="l01012"></a>01012 
<a name="l01013"></a>01013   is_fin = ((TCPH_FLAGS(seg-&gt;tcphdr) &amp; TCP_FIN) != 0) &amp;&amp; (seg-&gt;len == 0);
<a name="l01014"></a>01014   len = is_fin ? TCP_HLEN : TCP_HLEN + 1;
<a name="l01015"></a>01015 
<a name="l01016"></a>01016   p = <a class="code" href="pbuf_8c.html#acfcb0a2af918658ba0afe36499c65f47">pbuf_alloc</a>(PBUF_IP, len, PBUF_RAM);
<a name="l01017"></a>01017   <span class="keywordflow">if</span>(p == NULL) {
<a name="l01018"></a>01018     LWIP_DEBUGF(<a class="code" href="opt_8h.html#a4f43bb8a430c7a52a1ad5086d3f2803c">TCP_DEBUG</a>, (<span class="stringliteral">&quot;tcp_zero_window_probe: no memory for pbuf\n&quot;</span>));
<a name="l01019"></a>01019     <span class="keywordflow">return</span>;
<a name="l01020"></a>01020   }
<a name="l01021"></a>01021   LWIP_ASSERT(<span class="stringliteral">&quot;check that first pbuf can hold struct tcp_hdr&quot;</span>,
<a name="l01022"></a>01022               (p-&gt;<a class="code" href="structpbuf.html#a6f82449625e36e294f5d210268c0703f">len</a> &gt;= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structtcp__hdr.html">tcp_hdr</a>)));
<a name="l01023"></a>01023 
<a name="l01024"></a>01024   tcphdr = tcp_output_set_header(pcb, p, 0, seg-&gt;tcphdr-&gt;seqno);
<a name="l01025"></a>01025 
<a name="l01026"></a>01026   <span class="keywordflow">if</span> (is_fin) {
<a name="l01027"></a>01027     <span class="comment">/* FIN segment, no data */</span>
<a name="l01028"></a>01028     TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
<a name="l01029"></a>01029   } <span class="keywordflow">else</span> {
<a name="l01030"></a>01030     <span class="comment">/* Data segment, copy in one byte from the head of the unacked queue */</span>
<a name="l01031"></a>01031     *((<span class="keywordtype">char</span> *)p-&gt;<a class="code" href="structpbuf.html#a8d32dc3e964369d4eec638fc37fbc460">payload</a> + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structtcp__hdr.html">tcp_hdr</a>)) = *(<span class="keywordtype">char</span> *)seg-&gt;dataptr;
<a name="l01032"></a>01032   }
<a name="l01033"></a>01033 
<a name="l01034"></a>01034 <span class="preprocessor">#if CHECKSUM_GEN_TCP</span>
<a name="l01035"></a>01035 <span class="preprocessor"></span>  tcphdr-&gt;chksum = inet_chksum_pseudo(p, &amp;pcb-&gt;local_ip, &amp;pcb-&gt;remote_ip,
<a name="l01036"></a>01036                                       IP_PROTO_TCP, p-&gt;<a class="code" href="structpbuf.html#a5259e7ec29bab9c0999b64f2e86b411f">tot_len</a>);
<a name="l01037"></a>01037 <span class="preprocessor">#endif</span>
<a name="l01038"></a>01038 <span class="preprocessor"></span>  TCP_STATS_INC(tcp.xmit);
<a name="l01039"></a>01039 
<a name="l01040"></a>01040   <span class="comment">/* Send output to IP */</span>
<a name="l01041"></a>01041 <span class="preprocessor">#if LWIP_NETIF_HWADDRHINT</span>
<a name="l01042"></a>01042 <span class="preprocessor"></span>  ip_output_hinted(p, &amp;pcb-&gt;local_ip, &amp;pcb-&gt;remote_ip, pcb-&gt;ttl, 0, IP_PROTO_TCP,
<a name="l01043"></a>01043     &amp;(pcb-&gt;addr_hint));
<a name="l01044"></a>01044 <span class="preprocessor">#else </span><span class="comment">/* LWIP_NETIF_HWADDRHINT*/</span>
<a name="l01045"></a>01045   <a class="code" href="ip_8c.html#aabccfd6ab4e3c73350c4014158cd4d2b">ip_output</a>(p, &amp;pcb-&gt;local_ip, &amp;pcb-&gt;remote_ip, pcb-&gt;ttl, 0, IP_PROTO_TCP);
<a name="l01046"></a>01046 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_NETIF_HWADDRHINT*/</span>
<a name="l01047"></a>01047 
<a name="l01048"></a>01048   <a class="code" href="pbuf_8c.html#ab0dd696fb4b6bc65e548944584f1738b">pbuf_free</a>(p);
<a name="l01049"></a>01049 
<a name="l01050"></a>01050   LWIP_DEBUGF(<a class="code" href="opt_8h.html#a4f43bb8a430c7a52a1ad5086d3f2803c">TCP_DEBUG</a>, (<span class="stringliteral">&quot;tcp_zero_window_probe: seqno %&quot;</span>U32_F
<a name="l01051"></a>01051                           <span class="stringliteral">&quot; ackno %&quot;</span>U32_F<span class="stringliteral">&quot;.\n&quot;</span>,
<a name="l01052"></a>01052                           pcb-&gt;snd_nxt - 1, pcb-&gt;rcv_nxt));
<a name="l01053"></a>01053 }
<a name="l01054"></a>01054 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_TCP */</span>
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
