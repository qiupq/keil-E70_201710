<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SAME70 Xplained Software Package: libraries/liblwip/source/lwip_1.3.2/src/core/pbuf.c File Reference</title>
<link href="common/style.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
    <div id="body">
        <div id="title">  SAME70 Xplained Software Package 1.5</div>
        <div id="banner"></div>

<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="dir_81818f1c1b01098ad6d8389f2aaf9f72.html">libraries</a>      </li>
      <li><a class="el" href="dir_f9d6af8b0767ec29e003eb404f55b2ba.html">liblwip</a>      </li>
      <li><a class="el" href="dir_a4b90551bcebf72d44580c734ab11c86.html">source</a>      </li>
      <li><a class="el" href="dir_7fff4700eae15a55204f316974611e6c.html">lwip_1.3.2</a>      </li>
      <li><a class="el" href="dir_6c5a4da2b38a7354841e985f92489e70.html">src</a>      </li>
      <li><a class="el" href="dir_edf09da46bb12db6367452bd0397000e.html">core</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>pbuf.c File Reference</h1>  </div>
</div>
<div class="contents">
<code>#include &quot;<a class="el" href="opt_8h_source.html">lwip/opt.h</a>&quot;</code><br/>
<code>#include &quot;lwip/stats.h&quot;</code><br/>
<code>#include &quot;lwip/def.h&quot;</code><br/>
<code>#include &quot;lwip/mem.h&quot;</code><br/>
<code>#include &quot;lwip/memp.h&quot;</code><br/>
<code>#include &quot;lwip/pbuf.h&quot;</code><br/>
<code>#include &quot;lwip/sys.h&quot;</code><br/>
<code>#include &quot;arch/perf.h&quot;</code><br/>
<code>#include &quot;lwip/tcp.h&quot;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &quot;lwip/tcpip.h&quot;</code><br/>

<p><a href="pbuf_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8357a994e45ff94c9494aa55b6c3ecb3"></a><!-- doxytag: member="pbuf.c::SIZEOF_STRUCT_PBUF" ref="a8357a994e45ff94c9494aa55b6c3ecb3" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>SIZEOF_STRUCT_PBUF</b>&nbsp;&nbsp;&nbsp;LWIP_MEM_ALIGN_SIZE(sizeof(struct <a class="el" href="structpbuf.html">pbuf</a>))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dad81a8286ee8e9a7c70a74f9f4bb0f"></a><!-- doxytag: member="pbuf.c::PBUF_POOL_BUFSIZE_ALIGNED" ref="a3dad81a8286ee8e9a7c70a74f9f4bb0f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PBUF_POOL_BUFSIZE_ALIGNED</b>&nbsp;&nbsp;&nbsp;LWIP_MEM_ALIGN_SIZE(PBUF_POOL_BUFSIZE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8c.html#ac54b0f161128a32c7419c33b893a5106">PBUF_POOL_FREE_OOSEQ</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed70c61e971683736c569a1a99b76569"></a><!-- doxytag: member="pbuf.c::PBUF_POOL_IS_EMPTY" ref="aed70c61e971683736c569a1a99b76569" args="()" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PBUF_POOL_IS_EMPTY</b>()&nbsp;&nbsp;&nbsp;pbuf_pool_is_empty()</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpbuf.html">pbuf</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8c.html#acfcb0a2af918658ba0afe36499c65f47">pbuf_alloc</a> (pbuf_layer layer, <a class="el" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> length, pbuf_type type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8c.html#a50abfe830a33a1a47a562febee66015d">pbuf_realloc</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p, <a class="el" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> new_len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8c.html#a0f81deff4a0e6e8e0ff161a7b9871449">pbuf_header</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p, s16_t header_size_increment)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8c.html#ab0dd696fb4b6bc65e548944584f1738b">pbuf_free</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8c.html#a949a13a7cfdf9241c9e7b859af1bd15c">pbuf_clen</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8c.html#a77f6bbd69e45e542014d9c547c7da74e">pbuf_ref</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8c.html#a82429084fe29015509c9b4a072707cd4">pbuf_cat</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *h, struct <a class="el" href="structpbuf.html">pbuf</a> *t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8c.html#a831c9a72bda1d3bd4c7b96f5a0e3b891">pbuf_chain</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *h, struct <a class="el" href="structpbuf.html">pbuf</a> *t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpbuf.html">pbuf</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8c.html#abf3d29c4f43986b4cb5eb314d5b9729d">pbuf_dechain</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">err_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8c.html#aee9cfb728d91302f068b5c6bd581e3e5">pbuf_copy</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p_to, struct <a class="el" href="structpbuf.html">pbuf</a> *p_from)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8c.html#a9efc1f3148d6c0236e40b41242bda4df">pbuf_copy_partial</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *buf, void *dataptr, <a class="el" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> len, <a class="el" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> <a class="el" href="examples_2periph__protect_2main_8c.html#a106faa3ad3783bae5a01fc40cfd9cdce">offset</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">err_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8c.html#ad1e31e370271335b197272af2724ca85">pbuf_take</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *buf, const void *dataptr, <a class="el" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpbuf.html">pbuf</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pbuf_8c.html#a54ac7b116c6f53c704cbf74f35a8b35c">pbuf_coalesce</a> (struct <a class="el" href="structpbuf.html">pbuf</a> *p, pbuf_layer layer)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Packet buffer management</p>
<p>Packets are built from the pbuf data structure. It supports dynamic memory allocation for packet contents or can reference externally managed packet contents both in RAM and ROM. Quick allocation for incoming packets is provided through pools with fixed sized pbufs.</p>
<p>A packet may span over multiple pbufs, chained as a singly linked list. This is called a "pbuf chain".</p>
<p>Multiple packets may be queued, also using this singly linked list. This is called a "packet queue".</p>
<p>So, a packet queue consists of one or more pbuf chains, each of which consist of one or more pbufs. CURRENTLY, PACKET QUEUES ARE NOT SUPPORTED!!! Use helper structs to queue multiple packets.</p>
<p>The differences between a pbuf chain and a packet queue are very precise but subtle.</p>
<p>The last pbuf of a packet has a -&gt;tot_len field that equals the -&gt;len field. It can be found by traversing the list. If the last pbuf of a packet has a -&gt;next field other than NULL, more packets are on the queue.</p>
<p>Therefore, looping through a pbuf of a single packet, has an loop end condition (tot_len == p-&gt;len), NOT (next == NULL). </p>

<p>Definition in file <a class="el" href="pbuf_8c_source.html">pbuf.c</a>.</p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ac54b0f161128a32c7419c33b893a5106"></a><!-- doxytag: member="pbuf.c::PBUF_POOL_FREE_OOSEQ" ref="ac54b0f161128a32c7419c33b893a5106" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PBUF_POOL_FREE_OOSEQ&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Define this to 0 to prevent freeing ooseq pbufs when the PBUF_POOL is empty </p>

<p>Definition at line <a class="el" href="pbuf_8c_source.html#l00089">89</a> of file <a class="el" href="pbuf_8c_source.html">pbuf.c</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="acfcb0a2af918658ba0afe36499c65f47"></a><!-- doxytag: member="pbuf.c::pbuf_alloc" ref="acfcb0a2af918658ba0afe36499c65f47" args="(pbuf_layer layer, u16_t length, pbuf_type type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structpbuf.html">pbuf</a>* pbuf_alloc </td>
          <td>(</td>
          <td class="paramtype">pbuf_layer&nbsp;</td>
          <td class="paramname"> <em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a>&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pbuf_type&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocates a pbuf of the given type (possibly a chain for PBUF_POOL type).</p>
<p>The actual memory allocated for the pbuf is determined by the layer at which the pbuf is allocated and the requested size (from the size parameter).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>layer</em>&nbsp;</td><td>flag to define header size </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>size of the pbuf's payload </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>this parameter decides how and where the pbuf should be allocated as follows:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>PBUF_RAM: buffer memory for pbuf is allocated as one large chunk. This includes protocol headers as well.</li>
<li>PBUF_ROM: no buffer memory is allocated for the pbuf, even for protocol headers. Additional headers must be prepended by allocating another pbuf and chain in to the front of the ROM pbuf. It is assumed that the memory used is really similar to ROM in that it is immutable and will not be changed. Memory which is dynamic should generally not be attached to PBUF_ROM pbufs. Use PBUF_REF instead.</li>
<li>PBUF_REF: no buffer memory is allocated for the pbuf, even for protocol headers. It is assumed that the pbuf is only being used in a single thread. If the pbuf gets queued, then pbuf_take should be called to copy the buffer.</li>
<li>PBUF_POOL: the pbuf is allocated as a pbuf chain, with pbufs from the pbuf pool that is allocated during pbuf_init().</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>the allocated pbuf. If multiple pbufs where allocated, this is the first pbuf of a pbuf chain. </dd></dl>

<p>Definition at line <a class="el" href="pbuf_8c_source.html#l00182">182</a> of file <a class="el" href="pbuf_8c_source.html">pbuf.c</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="pbuf_8c_acfcb0a2af918658ba0afe36499c65f47_cgraph.gif" border="0" usemap="#pbuf_8c_acfcb0a2af918658ba0afe36499c65f47_cgraph" alt=""/></div>
<map name="pbuf_8c_acfcb0a2af918658ba0afe36499c65f47_cgraph" id="pbuf_8c_acfcb0a2af918658ba0afe36499c65f47_cgraph">
<area shape="rect" id="node3" href="mem_8c.html#a932aa40d85b14cb7331625e012d12335" title="mem_malloc" alt="" coords="155,5,267,37"/><area shape="rect" id="node5" href="memp_8c.html#a2b00593d086313c267b54a976bf67aa5" title="memp_malloc" alt="" coords="151,61,271,93"/><area shape="rect" id="node7" href="pbuf_8c.html#ab0dd696fb4b6bc65e548944584f1738b" title="pbuf_free" alt="" coords="165,117,256,149"/><area shape="rect" id="node9" href="mem_8c.html#a65169147c44e9db60d997819af9b455c" title="mem_free" alt="" coords="325,89,419,121"/><area shape="rect" id="node11" href="memp_8c.html#aecd94926b7c2a0e23ae195f4ae97581f" title="memp_free" alt="" coords="320,145,424,177"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a82429084fe29015509c9b4a072707cd4"></a><!-- doxytag: member="pbuf.c::pbuf_cat" ref="a82429084fe29015509c9b4a072707cd4" args="(struct pbuf *h, struct pbuf *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pbuf_cat </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Concatenate two pbufs (each may be a pbuf chain) and take over the caller's reference of the tail pbuf.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The caller MAY NOT reference the tail pbuf afterwards. Use <a class="el" href="pbuf_8c.html#a831c9a72bda1d3bd4c7b96f5a0e3b891">pbuf_chain()</a> for that purpose.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="pbuf_8c.html#a831c9a72bda1d3bd4c7b96f5a0e3b891">pbuf_chain()</a> </dd></dl>

<p>Definition at line <a class="el" href="pbuf_8c_source.html#l00648">648</a> of file <a class="el" href="pbuf_8c_source.html">pbuf.c</a>.</p>

</div>
</div>
<a class="anchor" id="a831c9a72bda1d3bd4c7b96f5a0e3b891"></a><!-- doxytag: member="pbuf.c::pbuf_chain" ref="a831c9a72bda1d3bd4c7b96f5a0e3b891" args="(struct pbuf *h, struct pbuf *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pbuf_chain </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Chain two pbufs (or pbuf chains) together.</p>
<p>The caller MUST call pbuf_free(t) once it has stopped using it. Use <a class="el" href="pbuf_8c.html#a82429084fe29015509c9b4a072707cd4">pbuf_cat()</a> instead if you no longer use t.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>head pbuf (chain) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>tail pbuf (chain) </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The pbufs MUST belong to the same packet. </dd>
<dd>
MAY NOT be called on a packet queue.</dd></dl>
<p>The -&gt;tot_len fields of all pbufs of the head chain are adjusted. The -&gt;next field of the last pbuf of the head chain is adjusted. The -&gt;ref field of the first pbuf of the tail chain is adjusted. </p>

<p>Definition at line <a class="el" href="pbuf_8c_source.html#l00689">689</a> of file <a class="el" href="pbuf_8c_source.html">pbuf.c</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="pbuf_8c_a831c9a72bda1d3bd4c7b96f5a0e3b891_cgraph.gif" border="0" usemap="#pbuf_8c_a831c9a72bda1d3bd4c7b96f5a0e3b891_cgraph" alt=""/></div>
<map name="pbuf_8c_a831c9a72bda1d3bd4c7b96f5a0e3b891_cgraph" id="pbuf_8c_a831c9a72bda1d3bd4c7b96f5a0e3b891_cgraph">
<area shape="rect" id="node3" href="pbuf_8c.html#a82429084fe29015509c9b4a072707cd4" title="pbuf_cat" alt="" coords="157,5,243,37"/><area shape="rect" id="node5" href="pbuf_8c.html#a77f6bbd69e45e542014d9c547c7da74e" title="pbuf_ref" alt="" coords="159,61,241,93"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a949a13a7cfdf9241c9e7b859af1bd15c"></a><!-- doxytag: member="pbuf.c::pbuf_clen" ref="a949a13a7cfdf9241c9e7b859af1bd15c" args="(struct pbuf *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> pbuf_clen </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Count number of pbufs in a chain</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>first pbuf of chain </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of pbufs in a chain </dd></dl>

<p>Definition at line <a class="el" href="pbuf_8c_source.html#l00607">607</a> of file <a class="el" href="pbuf_8c_source.html">pbuf.c</a>.</p>

</div>
</div>
<a class="anchor" id="a54ac7b116c6f53c704cbf74f35a8b35c"></a><!-- doxytag: member="pbuf.c::pbuf_coalesce" ref="a54ac7b116c6f53c704cbf74f35a8b35c" args="(struct pbuf *p, pbuf_layer layer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structpbuf.html">pbuf</a>* pbuf_coalesce </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pbuf_layer&nbsp;</td>
          <td class="paramname"> <em>layer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a single pbuf out of a queue of pbufs.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>: The source pbuf 'p' is not freed by this function because that can be illegal in some places!</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>the source pbuf </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>layer</em>&nbsp;</td><td>pbuf_layer of the new pbuf</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new, single pbuf (p-&gt;next is NULL) or the old pbuf if allocation fails </dd></dl>

<p>Definition at line <a class="el" href="pbuf_8c_source.html#l00913">913</a> of file <a class="el" href="pbuf_8c_source.html">pbuf.c</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="pbuf_8c_a54ac7b116c6f53c704cbf74f35a8b35c_cgraph.gif" border="0" usemap="#pbuf_8c_a54ac7b116c6f53c704cbf74f35a8b35c_cgraph" alt=""/></div>
<map name="pbuf_8c_a54ac7b116c6f53c704cbf74f35a8b35c_cgraph" id="pbuf_8c_a54ac7b116c6f53c704cbf74f35a8b35c_cgraph">
<area shape="rect" id="node3" href="pbuf_8c.html#acfcb0a2af918658ba0afe36499c65f47" title="pbuf_alloc" alt="" coords="183,61,279,93"/><area shape="rect" id="node9" href="pbuf_8c.html#ab0dd696fb4b6bc65e548944584f1738b" title="pbuf_free" alt="" coords="344,117,435,149"/><area shape="rect" id="node11" href="pbuf_8c.html#aee9cfb728d91302f068b5c6bd581e3e5" title="pbuf_copy" alt="" coords="181,169,280,201"/><area shape="rect" id="node5" href="mem_8c.html#a932aa40d85b14cb7331625e012d12335" title="mem_malloc" alt="" coords="333,5,445,37"/><area shape="rect" id="node7" href="memp_8c.html#a2b00593d086313c267b54a976bf67aa5" title="memp_malloc" alt="" coords="329,61,449,93"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aee9cfb728d91302f068b5c6bd581e3e5"></a><!-- doxytag: member="pbuf.c::pbuf_copy" ref="aee9cfb728d91302f068b5c6bd581e3e5" args="(struct pbuf *p_to, struct pbuf *p_from)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">err_t pbuf_copy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&nbsp;</td>
          <td class="paramname"> <em>p_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&nbsp;</td>
          <td class="paramname"> <em>p_from</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create PBUF_RAM copies of pbufs.</p>
<p>Used to queue packets on behalf of the lwIP stack, such as ARP based queueing.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>You MUST explicitly use p = pbuf_take(p);</dd>
<dd>
Only one packet is copied, no packet queue!</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_to</em>&nbsp;</td><td>pbuf destination of the copy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_from</em>&nbsp;</td><td>pbuf source of the copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ERR_OK if pbuf was copied ERR_ARG if one of the pbufs is NULL or p_to is not big enough to hold p_from </dd></dl>

<p>Definition at line <a class="el" href="pbuf_8c_source.html#l00755">755</a> of file <a class="el" href="pbuf_8c_source.html">pbuf.c</a>.</p>

</div>
</div>
<a class="anchor" id="a9efc1f3148d6c0236e40b41242bda4df"></a><!-- doxytag: member="pbuf.c::pbuf_copy_partial" ref="a9efc1f3148d6c0236e40b41242bda4df" args="(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> pbuf_copy_partial </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dataptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a>&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a>&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy (part of) the contents of a packet buffer to an application supplied buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>the pbuf from which to copy data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dataptr</em>&nbsp;</td><td>the application supplied buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>length of data to copy (dataptr must be big enough). No more than buf-&gt;tot_len will be copied, irrespective of len </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>offset into the packet buffer from where to begin copying len bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of bytes copied, or 0 on failure </dd></dl>

<p>Definition at line <a class="el" href="pbuf_8c_source.html#l00821">821</a> of file <a class="el" href="pbuf_8c_source.html">pbuf.c</a>.</p>

</div>
</div>
<a class="anchor" id="abf3d29c4f43986b4cb5eb314d5b9729d"></a><!-- doxytag: member="pbuf.c::pbuf_dechain" ref="abf3d29c4f43986b4cb5eb314d5b9729d" args="(struct pbuf *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structpbuf.html">pbuf</a>* pbuf_dechain </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Dechains the first pbuf from its succeeding pbufs in the chain.</p>
<p>Makes p-&gt;tot_len field equal to p-&gt;len. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>pbuf to dechain </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>remainder of the pbuf chain, or NULL if it was de-allocated. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>May not be called on a packet queue. </dd></dl>

<p>Definition at line <a class="el" href="pbuf_8c_source.html#l00706">706</a> of file <a class="el" href="pbuf_8c_source.html">pbuf.c</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="pbuf_8c_abf3d29c4f43986b4cb5eb314d5b9729d_cgraph.gif" border="0" usemap="#pbuf_8c_abf3d29c4f43986b4cb5eb314d5b9729d_cgraph" alt=""/></div>
<map name="pbuf_8c_abf3d29c4f43986b4cb5eb314d5b9729d_cgraph" id="pbuf_8c_abf3d29c4f43986b4cb5eb314d5b9729d_cgraph">
<area shape="rect" id="node3" href="pbuf_8c.html#ab0dd696fb4b6bc65e548944584f1738b" title="pbuf_free" alt="" coords="177,33,268,65"/><area shape="rect" id="node5" href="mem_8c.html#a65169147c44e9db60d997819af9b455c" title="mem_free" alt="" coords="323,5,416,37"/><area shape="rect" id="node7" href="memp_8c.html#aecd94926b7c2a0e23ae195f4ae97581f" title="memp_free" alt="" coords="317,61,421,93"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab0dd696fb4b6bc65e548944584f1738b"></a><!-- doxytag: member="pbuf.c::pbuf_free" ref="ab0dd696fb4b6bc65e548944584f1738b" args="(struct pbuf *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> pbuf_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Dereference a pbuf chain or queue and deallocate any no-longer-used pbufs at the head of this chain or queue.</p>
<p>Decrements the pbuf reference count. If it reaches zero, the pbuf is deallocated.</p>
<p>For a pbuf chain, this is repeated for each pbuf in the chain, up to the first pbuf which has a non-zero reference count after decrementing. So, when all reference counts are one, the whole chain is free'd.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The pbuf (chain) to be dereferenced.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of pbufs that were de-allocated from the head of the chain.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>MUST NOT be called on a packet queue (Not verified to work yet). </dd>
<dd>
the reference counter of a pbuf equals the number of pointers that refer to the pbuf (or into the pbuf). </dd></dl>

<p>Definition at line <a class="el" href="pbuf_8c_source.html#l00531">531</a> of file <a class="el" href="pbuf_8c_source.html">pbuf.c</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="pbuf_8c_ab0dd696fb4b6bc65e548944584f1738b_cgraph.gif" border="0" usemap="#pbuf_8c_ab0dd696fb4b6bc65e548944584f1738b_cgraph" alt=""/></div>
<map name="pbuf_8c_ab0dd696fb4b6bc65e548944584f1738b_cgraph" id="pbuf_8c_ab0dd696fb4b6bc65e548944584f1738b_cgraph">
<area shape="rect" id="node3" href="mem_8c.html#a65169147c44e9db60d997819af9b455c" title="mem_free" alt="" coords="152,5,245,37"/><area shape="rect" id="node5" href="memp_8c.html#aecd94926b7c2a0e23ae195f4ae97581f" title="memp_free" alt="" coords="147,61,251,93"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0f81deff4a0e6e8e0ff161a7b9871449"></a><!-- doxytag: member="pbuf.c::pbuf_header" ref="a0f81deff4a0e6e8e0ff161a7b9871449" args="(struct pbuf *p, s16_t header_size_increment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> pbuf_header </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s16_t&nbsp;</td>
          <td class="paramname"> <em>header_size_increment</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adjusts the payload pointer to hide or reveal headers in the payload.</p>
<p>Adjusts the -&gt;payload pointer so that space for a header (dis)appears in the pbuf payload.</p>
<p>The -&gt;payload, -&gt;tot_len and -&gt;len fields are adjusted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>pbuf to change the header size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>header_size_increment</em>&nbsp;</td><td>Number of bytes to increment header size which increases the size of the pbuf. New space is on the front. (Using a negative value decreases the header size.) If hdr_size_inc is 0, this function does nothing and returns succesful.</td></tr>
  </table>
  </dd>
</dl>
<p>PBUF_ROM and PBUF_REF type buffers cannot have their sizes increased, so the call will fail. A check is made that the increase in header size does not move the payload pointer in front of the start of the buffer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>non-zero on failure, zero on success. </dd></dl>

<p>Definition at line <a class="el" href="pbuf_8c_source.html#l00424">424</a> of file <a class="el" href="pbuf_8c_source.html">pbuf.c</a>.</p>

</div>
</div>
<a class="anchor" id="a50abfe830a33a1a47a562febee66015d"></a><!-- doxytag: member="pbuf.c::pbuf_realloc" ref="a50abfe830a33a1a47a562febee66015d" args="(struct pbuf *p, u16_t new_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pbuf_realloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a>&nbsp;</td>
          <td class="paramname"> <em>new_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Shrink a pbuf chain to a desired length.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>pbuf to shrink. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_len</em>&nbsp;</td><td>desired new length of pbuf chain</td></tr>
  </table>
  </dd>
</dl>
<p>Depending on the desired length, the first few pbufs in a chain might be skipped and left unchanged. The new last pbuf in the chain will be resized, and any remaining pbufs will be freed.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If the pbuf is ROM/REF, only the -&gt;tot_len and -&gt;len fields are adjusted. </dd>
<dd>
May not be called on a packet queue.</dd>
<dd>
Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain). </dd></dl>

<p>Definition at line <a class="el" href="pbuf_8c_source.html#l00343">343</a> of file <a class="el" href="pbuf_8c_source.html">pbuf.c</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="pbuf_8c_a50abfe830a33a1a47a562febee66015d_cgraph.gif" border="0" usemap="#pbuf_8c_a50abfe830a33a1a47a562febee66015d_cgraph" alt=""/></div>
<map name="pbuf_8c_a50abfe830a33a1a47a562febee66015d_cgraph" id="pbuf_8c_a50abfe830a33a1a47a562febee66015d_cgraph">
<area shape="rect" id="node3" href="mem_8c.html#a845e247382361be1945535a21ca6d6a1" title="mem_realloc" alt="" coords="165,5,280,37"/><area shape="rect" id="node5" href="pbuf_8c.html#ab0dd696fb4b6bc65e548944584f1738b" title="pbuf_free" alt="" coords="177,61,268,93"/><area shape="rect" id="node7" href="mem_8c.html#a65169147c44e9db60d997819af9b455c" title="mem_free" alt="" coords="333,33,427,65"/><area shape="rect" id="node9" href="memp_8c.html#aecd94926b7c2a0e23ae195f4ae97581f" title="memp_free" alt="" coords="328,89,432,121"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a77f6bbd69e45e542014d9c547c7da74e"></a><!-- doxytag: member="pbuf.c::pbuf_ref" ref="a77f6bbd69e45e542014d9c547c7da74e" args="(struct pbuf *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pbuf_ref </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Increment the reference count of the pbuf.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>pbuf to increase reference counter of </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="pbuf_8c_source.html#l00626">626</a> of file <a class="el" href="pbuf_8c_source.html">pbuf.c</a>.</p>

</div>
</div>
<a class="anchor" id="ad1e31e370271335b197272af2724ca85"></a><!-- doxytag: member="pbuf.c::pbuf_take" ref="ad1e31e370271335b197272af2724ca85" args="(struct pbuf *buf, const void *dataptr, u16_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">err_t pbuf_take </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpbuf.html">pbuf</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>dataptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a>&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy application supplied data into a pbuf. This function can only be used to copy the equivalent of buf-&gt;tot_len data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>pbuf to fill with data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dataptr</em>&nbsp;</td><td>application supplied data buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>length of the application supplied data buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ERR_OK if successful, ERR_MEM if the pbuf is not big enough </dd></dl>

<p>Definition at line <a class="el" href="pbuf_8c_source.html#l00869">869</a> of file <a class="el" href="pbuf_8c_source.html">pbuf.c</a>.</p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
