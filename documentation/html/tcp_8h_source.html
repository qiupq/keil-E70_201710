<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SAME70 Xplained Software Package: libraries/liblwip/source/lwip_1.3.2/src/include/lwip/tcp.h Source File</title>
<link href="common/style.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
    <div id="body">
        <div id="title">  SAME70 Xplained Software Package 1.5</div>
        <div id="banner"></div>

<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="dir_81818f1c1b01098ad6d8389f2aaf9f72.html">libraries</a>      </li>
      <li><a class="el" href="dir_f9d6af8b0767ec29e003eb404f55b2ba.html">liblwip</a>      </li>
      <li><a class="el" href="dir_a4b90551bcebf72d44580c734ab11c86.html">source</a>      </li>
      <li><a class="el" href="dir_7fff4700eae15a55204f316974611e6c.html">lwip_1.3.2</a>      </li>
      <li><a class="el" href="dir_6c5a4da2b38a7354841e985f92489e70.html">src</a>      </li>
      <li><a class="el" href="dir_e7d73a812d78c2437c8951f248b5e66d.html">include</a>      </li>
      <li><a class="el" href="dir_037838e3a26925ea1d545a0a0a903343.html">lwip</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>tcp.h</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001   <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * Copyright (c) 2001-2004 Swedish Institute of Computer Science.</span>
<a name="l00003"></a>00003 <span class="comment"> * All rights reserved. </span>
<a name="l00004"></a>00004 <span class="comment"> * </span>
<a name="l00005"></a>00005 <span class="comment"> * Redistribution and use in source and binary forms, with or without modification, </span>
<a name="l00006"></a>00006 <span class="comment"> * are permitted provided that the following conditions are met:</span>
<a name="l00007"></a>00007 <span class="comment"> *</span>
<a name="l00008"></a>00008 <span class="comment"> * 1. Redistributions of source code must retain the above copyright notice,</span>
<a name="l00009"></a>00009 <span class="comment"> *    this list of conditions and the following disclaimer.</span>
<a name="l00010"></a>00010 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<a name="l00011"></a>00011 <span class="comment"> *    this list of conditions and the following disclaimer in the documentation</span>
<a name="l00012"></a>00012 <span class="comment"> *    and/or other materials provided with the distribution.</span>
<a name="l00013"></a>00013 <span class="comment"> * 3. The name of the author may not be used to endorse or promote products</span>
<a name="l00014"></a>00014 <span class="comment"> *    derived from this software without specific prior written permission. </span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS&#39;&#39; AND ANY EXPRESS OR IMPLIED </span>
<a name="l00017"></a>00017 <span class="comment"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF </span>
<a name="l00018"></a>00018 <span class="comment"> * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT </span>
<a name="l00019"></a>00019 <span class="comment"> * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, </span>
<a name="l00020"></a>00020 <span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT </span>
<a name="l00021"></a>00021 <span class="comment"> * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS </span>
<a name="l00022"></a>00022 <span class="comment"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN </span>
<a name="l00023"></a>00023 <span class="comment"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING </span>
<a name="l00024"></a>00024 <span class="comment"> * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY </span>
<a name="l00025"></a>00025 <span class="comment"> * OF SUCH DAMAGE.</span>
<a name="l00026"></a>00026 <span class="comment"> *</span>
<a name="l00027"></a>00027 <span class="comment"> * This file is part of the lwIP TCP/IP stack.</span>
<a name="l00028"></a>00028 <span class="comment"> * </span>
<a name="l00029"></a>00029 <span class="comment"> * Author: Adam Dunkels &lt;adam@sics.se&gt;</span>
<a name="l00030"></a>00030 <span class="comment"> *</span>
<a name="l00031"></a>00031 <span class="comment"> */</span>
<a name="l00032"></a>00032 <span class="preprocessor">#ifndef __LWIP_TCP_H__</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span><span class="preprocessor">#define __LWIP_TCP_H__</span>
<a name="l00034"></a>00034 <span class="preprocessor"></span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="opt_8h.html">lwip/opt.h</a>&quot;</span>
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="preprocessor">#if LWIP_TCP </span><span class="comment">/* don&#39;t build if not configured for use in lwipopts.h */</span>
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;lwip/sys.h&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;lwip/mem.h&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;lwip/pbuf.h&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;lwip/ip.h&quot;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &quot;lwip/icmp.h&quot;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &quot;lwip/err.h&quot;</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {
<a name="l00048"></a>00048 <span class="preprocessor">#endif</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span>
<a name="l00050"></a>00050 <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a>;
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 <span class="comment">/* Functions for interfacing with TCP: */</span>
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="comment">/* Lower layer interface to TCP: */</span>
<a name="l00055"></a>00055 <span class="preprocessor">#define tcp_init() </span><span class="comment">/* Compatibility define, not init needed. */</span>
<a name="l00056"></a>00056 <span class="keywordtype">void</span>             <a class="code" href="tcp_8c.html#a3846a756b13214ed88ea47d0ff8279eb">tcp_tmr</a>     (<span class="keywordtype">void</span>);  <span class="comment">/* Must be called every</span>
<a name="l00057"></a>00057 <span class="comment">                                         TCP_TMR_INTERVAL</span>
<a name="l00058"></a>00058 <span class="comment">                                         ms. (Typically 250 ms). */</span>
<a name="l00059"></a>00059 <span class="comment">/* Application program&#39;s interface: */</span>
<a name="l00060"></a>00060 <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> * <a class="code" href="tcp_8c.html#a7427c5d237fe66a8097bfa8d24ceb943">tcp_new</a>     (<span class="keywordtype">void</span>);
<a name="l00061"></a>00061 <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> * <a class="code" href="tcp_8c.html#a1dd6830a42b3c464b5a72f62ae312d0a">tcp_alloc</a>   (<a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> prio);
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 <span class="keywordtype">void</span>             <a class="code" href="tcp_8c.html#ac10926e6f76f73e17c0d37aaab3e56b6">tcp_arg</a>     (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <span class="keywordtype">void</span> *arg);
<a name="l00064"></a>00064 <span class="keywordtype">void</span>             <a class="code" href="tcp_8c.html#ae77434b264a469ee4124ff945feac490">tcp_accept</a>  (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb,
<a name="l00065"></a>00065                               err_t (* accept)(<span class="keywordtype">void</span> *arg, <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *newpcb,
<a name="l00066"></a>00066                  err_t err));
<a name="l00067"></a>00067 <span class="keywordtype">void</span>             <a class="code" href="tcp_8c.html#af58be9006b4ddb720113f03d56bc6e52">tcp_recv</a>    (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb,
<a name="l00068"></a>00068                               err_t (* recv)(<span class="keywordtype">void</span> *arg, <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *tpcb,
<a name="l00069"></a>00069                               <span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p, err_t err));
<a name="l00070"></a>00070 <span class="keywordtype">void</span>             <a class="code" href="tcp_8c.html#a030f298925f742108af2c85f22ce25da">tcp_sent</a>    (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb,
<a name="l00071"></a>00071                               err_t (* sent)(<span class="keywordtype">void</span> *arg, <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *tpcb,
<a name="l00072"></a>00072                               <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> len));
<a name="l00073"></a>00073 <span class="keywordtype">void</span>             <a class="code" href="tcp_8c.html#a501ef46b87d7e4784e41c66e4b9aef2c">tcp_poll</a>    (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb,
<a name="l00074"></a>00074                               err_t (* poll)(<span class="keywordtype">void</span> *arg, <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *tpcb),
<a name="l00075"></a>00075                               <a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> interval);
<a name="l00076"></a>00076 <span class="keywordtype">void</span>             <a class="code" href="tcp_8c.html#ab7d51d5a2637ef6c48c7365a269947c1">tcp_err</a>     (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb,
<a name="l00077"></a>00077                               <span class="keywordtype">void</span> (* err)(<span class="keywordtype">void</span> *arg, err_t err));
<a name="l00078"></a>00078 
<a name="l00079"></a>00079 <span class="preprocessor">#define          tcp_mss(pcb)      ((pcb)-&gt;mss)</span>
<a name="l00080"></a>00080 <span class="preprocessor"></span><span class="preprocessor">#define          tcp_sndbuf(pcb)   ((pcb)-&gt;snd_buf)</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span><span class="preprocessor">#define          tcp_nagle_disable(pcb)  ((pcb)-&gt;flags |= TF_NODELAY)</span>
<a name="l00082"></a>00082 <span class="preprocessor"></span><span class="preprocessor">#define          tcp_nagle_enable(pcb) ((pcb)-&gt;flags &amp;= ~TF_NODELAY)</span>
<a name="l00083"></a>00083 <span class="preprocessor"></span><span class="preprocessor">#define          tcp_nagle_disabled(pcb) (((pcb)-&gt;flags &amp; TF_NODELAY) != 0)</span>
<a name="l00084"></a>00084 <span class="preprocessor"></span>
<a name="l00085"></a>00085 <span class="preprocessor">#if TCP_LISTEN_BACKLOG</span>
<a name="l00086"></a>00086 <span class="preprocessor"></span><span class="preprocessor">#define          tcp_accepted(pcb) (((struct tcp_pcb_listen *)(pcb))-&gt;accepts_pending--)</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span><span class="preprocessor">#else  </span><span class="comment">/* TCP_LISTEN_BACKLOG */</span>
<a name="l00088"></a>00088 <span class="preprocessor">#define          tcp_accepted(pcb)</span>
<a name="l00089"></a>00089 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* TCP_LISTEN_BACKLOG */</span>
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 <span class="keywordtype">void</span>             <a class="code" href="tcp_8c.html#abdac0856a52b5789dc897d4c7137ec44">tcp_recved</a>  (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> len);
<a name="l00092"></a>00092 err_t            <a class="code" href="tcp_8c.html#a5f7cf3b3975c4d414e91456959f01233">tcp_bind</a>    (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <span class="keyword">struct</span> <a class="code" href="structip__addr.html">ip_addr</a> *ipaddr,
<a name="l00093"></a>00093                               <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> port);
<a name="l00094"></a>00094 err_t            <a class="code" href="tcp_8c.html#ad01b1fc0d4a44b934c75441c73569b81">tcp_connect</a> (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <span class="keyword">struct</span> <a class="code" href="structip__addr.html">ip_addr</a> *ipaddr,
<a name="l00095"></a>00095                               <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> port, err_t (* connected)(<span class="keywordtype">void</span> *arg,
<a name="l00096"></a>00096                               <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *tpcb,
<a name="l00097"></a>00097                               err_t err));
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> * <a class="code" href="tcp_8c.html#aeff14f321d1eecd0431611f382fcd338">tcp_listen_with_backlog</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> backlog);
<a name="l00100"></a>00100 <span class="preprocessor">#define          tcp_listen(pcb) tcp_listen_with_backlog(pcb, TCP_DEFAULT_LISTEN_BACKLOG)</span>
<a name="l00101"></a>00101 <span class="preprocessor"></span>
<a name="l00102"></a>00102 <span class="keywordtype">void</span>             <a class="code" href="tcp_8c.html#ae4f0f1ca01dbccd680eaa2d8433cd7fe">tcp_abandon</a> (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <span class="keywordtype">int</span> reset);
<a name="l00103"></a>00103 <span class="preprocessor">#define          tcp_abort(pcb) tcp_abandon((pcb), 1)</span>
<a name="l00104"></a>00104 <span class="preprocessor"></span>err_t            <a class="code" href="tcp_8c.html#a87093e137fcc53ea82a134a3f5b33623">tcp_close</a>   (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 <span class="comment">/* Flags for &quot;apiflags&quot; parameter in tcp_write and tcp_enqueue */</span>
<a name="l00107"></a>00107 <span class="preprocessor">#define TCP_WRITE_FLAG_COPY 0x01</span>
<a name="l00108"></a>00108 <span class="preprocessor"></span><span class="preprocessor">#define TCP_WRITE_FLAG_MORE 0x02</span>
<a name="l00109"></a>00109 <span class="preprocessor"></span>
<a name="l00110"></a>00110 err_t            <a class="code" href="tcp__out_8c.html#adf2da5506f6cded5fdd6ff6a2f4c6929">tcp_write</a>   (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <span class="keyword">const</span> <span class="keywordtype">void</span> *dataptr, <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> len,
<a name="l00111"></a>00111                               <a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> apiflags);
<a name="l00112"></a>00112 
<a name="l00113"></a>00113 <span class="keywordtype">void</span>             <a class="code" href="tcp_8c.html#a2c4234f1e95b6bde0e84d4ea97ae95bc">tcp_setprio</a> (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> prio);
<a name="l00114"></a>00114 
<a name="l00115"></a>00115 <span class="preprocessor">#define TCP_PRIO_MIN    1</span>
<a name="l00116"></a>00116 <span class="preprocessor"></span><span class="preprocessor">#define TCP_PRIO_NORMAL 64</span>
<a name="l00117"></a>00117 <span class="preprocessor"></span><span class="preprocessor">#define TCP_PRIO_MAX    127</span>
<a name="l00118"></a>00118 <span class="preprocessor"></span>
<a name="l00119"></a>00119 <span class="comment">/* It is also possible to call these two functions at the right</span>
<a name="l00120"></a>00120 <span class="comment">   intervals (instead of calling tcp_tmr()). */</span>
<a name="l00121"></a>00121 <span class="keywordtype">void</span>             <a class="code" href="tcp_8c.html#a421fb42ef919018e14ae413adfee9905">tcp_slowtmr</a> (<span class="keywordtype">void</span>);
<a name="l00122"></a>00122 <span class="keywordtype">void</span>             <a class="code" href="tcp_8c.html#abf446b07e52161b8a53cea07bc6c366d">tcp_fasttmr</a> (<span class="keywordtype">void</span>);
<a name="l00123"></a>00123 
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 <span class="comment">/* Only used by IP to pass a TCP segment to TCP: */</span>
<a name="l00126"></a>00126 <span class="keywordtype">void</span>             <a class="code" href="tcp__in_8c.html#ae70c3c99d9dd6b07f7e11f7ba5eedcb5">tcp_input</a>   (<span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p, <span class="keyword">struct</span> <a class="code" href="structnetif.html">netif</a> *inp);
<a name="l00127"></a>00127 <span class="comment">/* Used within the TCP code only: */</span>
<a name="l00128"></a>00128 err_t            <a class="code" href="tcp__out_8c.html#aefde3e34b2cc8df9654986484c44a996">tcp_send_empty_ack</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
<a name="l00129"></a>00129 err_t            <a class="code" href="tcp__out_8c.html#a0cbcc6d628f644a530daf629fa3e5f7f">tcp_output</a>  (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
<a name="l00130"></a>00130 <span class="keywordtype">void</span>             <a class="code" href="tcp__out_8c.html#a0520917abc5f5ae56e39d632131a69b7">tcp_rexmit</a>  (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
<a name="l00131"></a>00131 <span class="keywordtype">void</span>             <a class="code" href="tcp__out_8c.html#ab5ef9c8ab4629eb721987ae316b9f30f">tcp_rexmit_rto</a>  (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
<a name="l00132"></a>00132 <span class="keywordtype">void</span>             <a class="code" href="tcp__out_8c.html#adb6ee7b4d59f125cc8bfac3bb5ca3937">tcp_rexmit_fast</a> (<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
<a name="l00133"></a>00133 u32_t            <a class="code" href="tcp_8c.html#a6d2c254b779db4e517cb34e41301588d">tcp_update_rcv_ann_wnd</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
<a name="l00134"></a>00134 <span class="comment"></span>
<a name="l00135"></a>00135 <span class="comment">/**</span>
<a name="l00136"></a>00136 <span class="comment"> * This is the Nagle algorithm: try to combine user data to send as few TCP</span>
<a name="l00137"></a>00137 <span class="comment"> * segments as possible. Only send if</span>
<a name="l00138"></a>00138 <span class="comment"> * - no previously transmitted data on the connection remains unacknowledged or</span>
<a name="l00139"></a>00139 <span class="comment"> * - the TF_NODELAY flag is set (nagle algorithm turned off for this pcb) or</span>
<a name="l00140"></a>00140 <span class="comment"> * - the only unsent segment is at least pcb-&gt;mss bytes long (or there is more</span>
<a name="l00141"></a>00141 <span class="comment"> *   than one unsent segment - with lwIP, this can happen although unsent-&gt;len &lt; mss)</span>
<a name="l00142"></a>00142 <span class="comment"> * - or if we are in fast-retransmit (TF_INFR)</span>
<a name="l00143"></a>00143 <span class="comment"> */</span>
<a name="l00144"></a>00144 <span class="preprocessor">#define tcp_do_output_nagle(tpcb) ((((tpcb)-&gt;unacked == NULL) || \</span>
<a name="l00145"></a>00145 <span class="preprocessor">                            ((tpcb)-&gt;flags &amp; (TF_NODELAY | TF_INFR)) || \</span>
<a name="l00146"></a>00146 <span class="preprocessor">                            (((tpcb)-&gt;unsent != NULL) &amp;&amp; (((tpcb)-&gt;unsent-&gt;next != NULL) || \</span>
<a name="l00147"></a>00147 <span class="preprocessor">                              ((tpcb)-&gt;unsent-&gt;len &gt;= (tpcb)-&gt;mss))) \</span>
<a name="l00148"></a>00148 <span class="preprocessor">                            ) ? 1 : 0)</span>
<a name="l00149"></a>00149 <span class="preprocessor"></span><span class="preprocessor">#define tcp_output_nagle(tpcb) (tcp_do_output_nagle(tpcb) ? tcp_output(tpcb) : ERR_OK)</span>
<a name="l00150"></a>00150 <span class="preprocessor"></span>
<a name="l00151"></a>00151 
<a name="l00152"></a>00152 <span class="preprocessor">#define TCP_SEQ_LT(a,b)     ((s32_t)((a)-(b)) &lt; 0)</span>
<a name="l00153"></a>00153 <span class="preprocessor"></span><span class="preprocessor">#define TCP_SEQ_LEQ(a,b)    ((s32_t)((a)-(b)) &lt;= 0)</span>
<a name="l00154"></a>00154 <span class="preprocessor"></span><span class="preprocessor">#define TCP_SEQ_GT(a,b)     ((s32_t)((a)-(b)) &gt; 0)</span>
<a name="l00155"></a>00155 <span class="preprocessor"></span><span class="preprocessor">#define TCP_SEQ_GEQ(a,b)    ((s32_t)((a)-(b)) &gt;= 0)</span>
<a name="l00156"></a>00156 <span class="preprocessor"></span><span class="comment">/* is b&lt;=a&lt;=c? */</span>
<a name="l00157"></a>00157 <span class="preprocessor">#if 0 </span><span class="comment">/* see bug #10548 */</span>
<a name="l00158"></a>00158 <span class="preprocessor">#define TCP_SEQ_BETWEEN(a,b,c) ((c)-(b) &gt;= (a)-(b))</span>
<a name="l00159"></a>00159 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00160"></a>00160 <span class="preprocessor"></span><span class="preprocessor">#define TCP_SEQ_BETWEEN(a,b,c) (TCP_SEQ_GEQ(a,b) &amp;&amp; TCP_SEQ_LEQ(a,c))</span>
<a name="l00161"></a>00161 <span class="preprocessor"></span><span class="preprocessor">#define TCP_FIN 0x01U</span>
<a name="l00162"></a>00162 <span class="preprocessor"></span><span class="preprocessor">#define TCP_SYN 0x02U</span>
<a name="l00163"></a>00163 <span class="preprocessor"></span><span class="preprocessor">#define TCP_RST 0x04U</span>
<a name="l00164"></a>00164 <span class="preprocessor"></span><span class="preprocessor">#define TCP_PSH 0x08U</span>
<a name="l00165"></a>00165 <span class="preprocessor"></span><span class="preprocessor">#define TCP_ACK 0x10U</span>
<a name="l00166"></a>00166 <span class="preprocessor"></span><span class="preprocessor">#define TCP_URG 0x20U</span>
<a name="l00167"></a>00167 <span class="preprocessor"></span><span class="preprocessor">#define TCP_ECE 0x40U</span>
<a name="l00168"></a>00168 <span class="preprocessor"></span><span class="preprocessor">#define TCP_CWR 0x80U</span>
<a name="l00169"></a>00169 <span class="preprocessor"></span>
<a name="l00170"></a>00170 <span class="preprocessor">#define TCP_FLAGS 0x3fU</span>
<a name="l00171"></a>00171 <span class="preprocessor"></span>
<a name="l00172"></a>00172 <span class="comment">/* Length of the TCP header, excluding options. */</span>
<a name="l00173"></a>00173 <span class="preprocessor">#define TCP_HLEN 20</span>
<a name="l00174"></a>00174 <span class="preprocessor"></span>
<a name="l00175"></a>00175 <span class="preprocessor">#ifndef TCP_TMR_INTERVAL</span>
<a name="l00176"></a>00176 <span class="preprocessor"></span><span class="preprocessor">#define TCP_TMR_INTERVAL       250  </span><span class="comment">/* The TCP timer interval in milliseconds. */</span>
<a name="l00177"></a>00177 <span class="preprocessor">#endif </span><span class="comment">/* TCP_TMR_INTERVAL */</span>
<a name="l00178"></a>00178 
<a name="l00179"></a>00179 <span class="preprocessor">#ifndef TCP_FAST_INTERVAL</span>
<a name="l00180"></a>00180 <span class="preprocessor"></span><span class="preprocessor">#define TCP_FAST_INTERVAL      TCP_TMR_INTERVAL </span><span class="comment">/* the fine grained timeout in milliseconds */</span>
<a name="l00181"></a>00181 <span class="preprocessor">#endif </span><span class="comment">/* TCP_FAST_INTERVAL */</span>
<a name="l00182"></a>00182 
<a name="l00183"></a>00183 <span class="preprocessor">#ifndef TCP_SLOW_INTERVAL</span>
<a name="l00184"></a>00184 <span class="preprocessor"></span><span class="preprocessor">#define TCP_SLOW_INTERVAL      (2*TCP_TMR_INTERVAL)  </span><span class="comment">/* the coarse grained timeout in milliseconds */</span>
<a name="l00185"></a>00185 <span class="preprocessor">#endif </span><span class="comment">/* TCP_SLOW_INTERVAL */</span>
<a name="l00186"></a>00186 
<a name="l00187"></a>00187 <span class="preprocessor">#define TCP_FIN_WAIT_TIMEOUT 20000 </span><span class="comment">/* milliseconds */</span>
<a name="l00188"></a>00188 <span class="preprocessor">#define TCP_SYN_RCVD_TIMEOUT 20000 </span><span class="comment">/* milliseconds */</span>
<a name="l00189"></a>00189 
<a name="l00190"></a>00190 <span class="preprocessor">#define TCP_OOSEQ_TIMEOUT        6U </span><span class="comment">/* x RTO */</span>
<a name="l00191"></a>00191 
<a name="l00192"></a>00192 <span class="preprocessor">#ifndef TCP_MSL</span>
<a name="l00193"></a>00193 <span class="preprocessor"></span><span class="preprocessor">#define TCP_MSL 60000UL </span><span class="comment">/* The maximum segment lifetime in milliseconds */</span>
<a name="l00194"></a>00194 <span class="preprocessor">#endif</span>
<a name="l00195"></a>00195 <span class="preprocessor"></span>
<a name="l00196"></a>00196 <span class="comment">/* Keepalive values, compliant with RFC 1122. Don&#39;t change this unless you know what you&#39;re doing */</span>
<a name="l00197"></a>00197 <span class="preprocessor">#ifndef  TCP_KEEPIDLE_DEFAULT</span>
<a name="l00198"></a>00198 <span class="preprocessor"></span><span class="preprocessor">#define  TCP_KEEPIDLE_DEFAULT     7200000UL </span><span class="comment">/* Default KEEPALIVE timer in milliseconds */</span>
<a name="l00199"></a>00199 <span class="preprocessor">#endif</span>
<a name="l00200"></a>00200 <span class="preprocessor"></span>
<a name="l00201"></a>00201 <span class="preprocessor">#ifndef  TCP_KEEPINTVL_DEFAULT</span>
<a name="l00202"></a>00202 <span class="preprocessor"></span><span class="preprocessor">#define  TCP_KEEPINTVL_DEFAULT    75000UL   </span><span class="comment">/* Default Time between KEEPALIVE probes in milliseconds */</span>
<a name="l00203"></a>00203 <span class="preprocessor">#endif</span>
<a name="l00204"></a>00204 <span class="preprocessor"></span>
<a name="l00205"></a>00205 <span class="preprocessor">#ifndef  TCP_KEEPCNT_DEFAULT</span>
<a name="l00206"></a>00206 <span class="preprocessor"></span><span class="preprocessor">#define  TCP_KEEPCNT_DEFAULT      9U        </span><span class="comment">/* Default Counter for KEEPALIVE probes */</span>
<a name="l00207"></a>00207 <span class="preprocessor">#endif</span>
<a name="l00208"></a>00208 <span class="preprocessor"></span>
<a name="l00209"></a>00209 <span class="preprocessor">#define  TCP_MAXIDLE              TCP_KEEPCNT_DEFAULT * TCP_KEEPINTVL_DEFAULT  </span><span class="comment">/* Maximum KEEPALIVE probe time */</span>
<a name="l00210"></a>00210 
<a name="l00211"></a>00211 <span class="comment">/* Fields are (of course) in network byte order.</span>
<a name="l00212"></a>00212 <span class="comment"> * Some fields are converted to host byte order in tcp_input().</span>
<a name="l00213"></a>00213 <span class="comment"> */</span>
<a name="l00214"></a>00214 <span class="preprocessor">#ifdef PACK_STRUCT_USE_INCLUDES</span>
<a name="l00215"></a>00215 <span class="preprocessor"></span><span class="preprocessor">#  include &quot;arch/bpstruct.h&quot;</span>
<a name="l00216"></a>00216 <span class="preprocessor">#endif</span>
<a name="l00217"></a>00217 <span class="preprocessor"></span>PACK_STRUCT_BEGIN
<a name="l00218"></a><a class="code" href="structtcp__hdr.html">00218</a> <span class="keyword">struct </span><a class="code" href="structtcp__hdr.html">tcp_hdr</a> {
<a name="l00219"></a>00219   PACK_STRUCT_FIELD(<a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> src);
<a name="l00220"></a>00220   PACK_STRUCT_FIELD(<a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> dest);
<a name="l00221"></a>00221   PACK_STRUCT_FIELD(u32_t seqno);
<a name="l00222"></a>00222   PACK_STRUCT_FIELD(u32_t ackno);
<a name="l00223"></a>00223   PACK_STRUCT_FIELD(<a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> _hdrlen_rsvd_flags);
<a name="l00224"></a>00224   PACK_STRUCT_FIELD(<a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> wnd);
<a name="l00225"></a>00225   PACK_STRUCT_FIELD(<a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> chksum);
<a name="l00226"></a>00226   PACK_STRUCT_FIELD(<a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> urgp);
<a name="l00227"></a>00227 } <a class="code" href="ip__frag_8c.html#a421562ab5ea9c1ad7f6e3b7fdc7a9c3e">PACK_STRUCT_STRUCT</a>;
<a name="l00228"></a>00228 PACK_STRUCT_END
<a name="l00229"></a>00229 <span class="preprocessor">#ifdef PACK_STRUCT_USE_INCLUDES</span>
<a name="l00230"></a>00230 <span class="preprocessor"></span><span class="preprocessor">#  include &quot;arch/epstruct.h&quot;</span>
<a name="l00231"></a>00231 <span class="preprocessor">#endif</span>
<a name="l00232"></a>00232 <span class="preprocessor"></span>
<a name="l00233"></a>00233 <span class="preprocessor">#define TCPH_OFFSET(phdr) (ntohs((phdr)-&gt;_hdrlen_rsvd_flags) &gt;&gt; 8)</span>
<a name="l00234"></a>00234 <span class="preprocessor"></span><span class="preprocessor">#define TCPH_HDRLEN(phdr) (ntohs((phdr)-&gt;_hdrlen_rsvd_flags) &gt;&gt; 12)</span>
<a name="l00235"></a>00235 <span class="preprocessor"></span><span class="preprocessor">#define TCPH_FLAGS(phdr)  (ntohs((phdr)-&gt;_hdrlen_rsvd_flags) &amp; TCP_FLAGS)</span>
<a name="l00236"></a>00236 <span class="preprocessor"></span>
<a name="l00237"></a>00237 <span class="preprocessor">#define TCPH_OFFSET_SET(phdr, offset) (phdr)-&gt;_hdrlen_rsvd_flags = htons(((offset) &lt;&lt; 8) | TCPH_FLAGS(phdr))</span>
<a name="l00238"></a>00238 <span class="preprocessor"></span><span class="preprocessor">#define TCPH_HDRLEN_SET(phdr, len) (phdr)-&gt;_hdrlen_rsvd_flags = htons(((len) &lt;&lt; 12) | TCPH_FLAGS(phdr))</span>
<a name="l00239"></a>00239 <span class="preprocessor"></span><span class="preprocessor">#define TCPH_FLAGS_SET(phdr, flags) (phdr)-&gt;_hdrlen_rsvd_flags = (((phdr)-&gt;_hdrlen_rsvd_flags &amp; htons((u16_t)(~(u16_t)(TCP_FLAGS)))) | htons(flags))</span>
<a name="l00240"></a>00240 <span class="preprocessor"></span><span class="preprocessor">#define TCPH_SET_FLAG(phdr, flags ) (phdr)-&gt;_hdrlen_rsvd_flags = ((phdr)-&gt;_hdrlen_rsvd_flags | htons(flags))</span>
<a name="l00241"></a>00241 <span class="preprocessor"></span><span class="preprocessor">#define TCPH_UNSET_FLAG(phdr, flags) (phdr)-&gt;_hdrlen_rsvd_flags = htons(ntohs((phdr)-&gt;_hdrlen_rsvd_flags) | (TCPH_FLAGS(phdr) &amp; ~(flags)) )</span>
<a name="l00242"></a>00242 <span class="preprocessor"></span>
<a name="l00243"></a>00243 <span class="preprocessor">#define TCP_TCPLEN(seg) ((seg)-&gt;len + ((TCPH_FLAGS((seg)-&gt;tcphdr) &amp; (TCP_FIN | TCP_SYN)) != 0))</span>
<a name="l00244"></a>00244 <span class="preprocessor"></span>
<a name="l00245"></a>00245 <span class="keyword">enum</span> tcp_state {
<a name="l00246"></a>00246   CLOSED      = 0,
<a name="l00247"></a>00247   LISTEN      = 1,
<a name="l00248"></a>00248   SYN_SENT    = 2,
<a name="l00249"></a>00249   SYN_RCVD    = 3,
<a name="l00250"></a>00250   ESTABLISHED = 4,
<a name="l00251"></a>00251   FIN_WAIT_1  = 5,
<a name="l00252"></a>00252   FIN_WAIT_2  = 6,
<a name="l00253"></a>00253   CLOSE_WAIT  = 7,
<a name="l00254"></a>00254   CLOSING     = 8,
<a name="l00255"></a>00255   LAST_ACK    = 9,
<a name="l00256"></a>00256   TIME_WAIT   = 10
<a name="l00257"></a>00257 };
<a name="l00258"></a>00258 <span class="comment"></span>
<a name="l00259"></a>00259 <span class="comment">/** Flags used on input processing, not on pcb-&gt;flags</span>
<a name="l00260"></a>00260 <span class="comment">*/</span>
<a name="l00261"></a>00261 <span class="preprocessor">#define TF_RESET     (u8_t)0x08U   </span><span class="comment">/* Connection was reset. */</span>
<a name="l00262"></a>00262 <span class="preprocessor">#define TF_CLOSED    (u8_t)0x10U   </span><span class="comment">/* Connection was sucessfully closed. */</span>
<a name="l00263"></a>00263 <span class="preprocessor">#define TF_GOT_FIN   (u8_t)0x20U   </span><span class="comment">/* Connection was closed by the remote end. */</span>
<a name="l00264"></a>00264 
<a name="l00265"></a>00265 
<a name="l00266"></a>00266 <span class="preprocessor">#if LWIP_CALLBACK_API</span>
<a name="l00267"></a>00267 <span class="preprocessor"></span>  <span class="comment">/* Function to call when a listener has been connected.</span>
<a name="l00268"></a>00268 <span class="comment">   * @param arg user-supplied argument (tcp_pcb.callback_arg)</span>
<a name="l00269"></a>00269 <span class="comment">   * @param pcb a new tcp_pcb that now is connected</span>
<a name="l00270"></a>00270 <span class="comment">   * @param err an error argument (TODO: that is current always ERR_OK?)</span>
<a name="l00271"></a>00271 <span class="comment">   * @return ERR_OK: accept the new connection,</span>
<a name="l00272"></a>00272 <span class="comment">   *                 any other err_t abortsthe new connection</span>
<a name="l00273"></a>00273 <span class="comment">   */</span>
<a name="l00274"></a>00274 <span class="preprocessor">#define DEF_ACCEPT_CALLBACK  err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err)</span>
<a name="l00275"></a>00275 <span class="preprocessor"></span><span class="preprocessor">#else </span><span class="comment">/* LWIP_CALLBACK_API */</span>
<a name="l00276"></a>00276 <span class="preprocessor">#define DEF_ACCEPT_CALLBACK</span>
<a name="l00277"></a>00277 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* LWIP_CALLBACK_API */</span>
<a name="l00278"></a>00278 <span class="comment"></span>
<a name="l00279"></a>00279 <span class="comment">/**</span>
<a name="l00280"></a>00280 <span class="comment"> * members common to struct tcp_pcb and struct tcp_listen_pcb</span>
<a name="l00281"></a>00281 <span class="comment"> */</span>
<a name="l00282"></a>00282 <span class="preprocessor">#define TCP_PCB_COMMON(type) \</span>
<a name="l00283"></a>00283 <span class="preprocessor">  type *next; </span><span class="comment">/* for the linked list */</span> \
<a name="l00284"></a>00284   enum tcp_state state; <span class="comment">/* TCP state */</span> \
<a name="l00285"></a>00285   u8_t prio; \
<a name="l00286"></a>00286   void *callback_arg; \
<a name="l00287"></a>00287   <span class="comment">/* ports are in host byte order */</span> \
<a name="l00288"></a>00288   u16_t local_port; \
<a name="l00289"></a>00289   <span class="comment">/* the accept callback for listen- and normal pcbs, if LWIP_CALLBACK_API */</span> \
<a name="l00290"></a>00290   DEF_ACCEPT_CALLBACK
<a name="l00291"></a>00291 
<a name="l00292"></a>00292 
<a name="l00293"></a>00293 <span class="comment">/* the TCP protocol control block */</span>
<a name="l00294"></a><a class="code" href="structtcp__pcb.html">00294</a> <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> {<span class="comment"></span>
<a name="l00295"></a>00295 <span class="comment">/** common PCB members */</span>
<a name="l00296"></a><a class="code" href="structtcp__pcb.html#a74bdfcd8828ca72254814c01f0e29097">00296</a>   <a class="code" href="structtcp__pcb.html#a74bdfcd8828ca72254814c01f0e29097">IP_PCB</a>;<span class="comment"></span>
<a name="l00297"></a>00297 <span class="comment">/** protocol specific PCB members */</span>
<a name="l00298"></a>00298   <a class="code" href="structtcp__pcb.html#a49e489a6b9486d0570ad85ba8323e350">TCP_PCB_COMMON</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a>);
<a name="l00299"></a>00299 
<a name="l00300"></a>00300   <span class="comment">/* ports are in host byte order */</span>
<a name="l00301"></a>00301   <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> remote_port;
<a name="l00302"></a>00302   
<a name="l00303"></a>00303   <a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> flags;
<a name="l00304"></a>00304 <span class="preprocessor">#define TF_ACK_DELAY   ((u8_t)0x01U)   </span><span class="comment">/* Delayed ACK. */</span>
<a name="l00305"></a>00305 <span class="preprocessor">#define TF_ACK_NOW     ((u8_t)0x02U)   </span><span class="comment">/* Immediate ACK. */</span>
<a name="l00306"></a>00306 <span class="preprocessor">#define TF_INFR        ((u8_t)0x04U)   </span><span class="comment">/* In fast recovery. */</span>
<a name="l00307"></a>00307 <span class="preprocessor">#define TF_TIMESTAMP   ((u8_t)0x08U)   </span><span class="comment">/* Timestamp option enabled */</span>
<a name="l00308"></a>00308 <span class="preprocessor">#define TF_FIN         ((u8_t)0x20U)   </span><span class="comment">/* Connection was closed locally (FIN segment enqueued). */</span>
<a name="l00309"></a>00309 <span class="preprocessor">#define TF_NODELAY     ((u8_t)0x40U)   </span><span class="comment">/* Disable Nagle algorithm */</span>
<a name="l00310"></a>00310 <span class="preprocessor">#define TF_NAGLEMEMERR ((u8_t)0x80U)   </span><span class="comment">/* nagle enabled, memerr, try to output to prevent delayed ACK to happen */</span>
<a name="l00311"></a>00311 
<a name="l00312"></a>00312   <span class="comment">/* the rest of the fields are in host byte order</span>
<a name="l00313"></a>00313 <span class="comment">     as we have to do some math with them */</span>
<a name="l00314"></a>00314   <span class="comment">/* receiver variables */</span>
<a name="l00315"></a>00315   u32_t rcv_nxt;   <span class="comment">/* next seqno expected */</span>
<a name="l00316"></a>00316   <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> rcv_wnd;   <span class="comment">/* receiver window available */</span>
<a name="l00317"></a>00317   <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> rcv_ann_wnd; <span class="comment">/* receiver window to announce */</span>
<a name="l00318"></a>00318   u32_t rcv_ann_right_edge; <span class="comment">/* announced right edge of window */</span>
<a name="l00319"></a>00319 
<a name="l00320"></a>00320   <span class="comment">/* Timers */</span>
<a name="l00321"></a>00321   u32_t tmr;
<a name="l00322"></a>00322   <a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> polltmr, pollinterval;
<a name="l00323"></a>00323   
<a name="l00324"></a>00324   <span class="comment">/* Retransmission timer. */</span>
<a name="l00325"></a>00325   s16_t rtime;
<a name="l00326"></a>00326   
<a name="l00327"></a>00327   <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> mss;   <span class="comment">/* maximum segment size */</span>
<a name="l00328"></a>00328   
<a name="l00329"></a>00329   <span class="comment">/* RTT (round trip time) estimation variables */</span>
<a name="l00330"></a>00330   u32_t rttest; <span class="comment">/* RTT estimate in 500ms ticks */</span>
<a name="l00331"></a>00331   u32_t rtseq;  <span class="comment">/* sequence number being timed */</span>
<a name="l00332"></a>00332   s16_t sa, sv; <span class="comment">/* @todo document this */</span>
<a name="l00333"></a>00333 
<a name="l00334"></a>00334   s16_t rto;    <span class="comment">/* retransmission time-out */</span>
<a name="l00335"></a>00335   <a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> nrtx;    <span class="comment">/* number of retransmissions */</span>
<a name="l00336"></a>00336 
<a name="l00337"></a>00337   <span class="comment">/* fast retransmit/recovery */</span>
<a name="l00338"></a>00338   u32_t lastack; <span class="comment">/* Highest acknowledged seqno. */</span>
<a name="l00339"></a>00339   <a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> dupacks;
<a name="l00340"></a>00340   
<a name="l00341"></a>00341   <span class="comment">/* congestion avoidance/control variables */</span>
<a name="l00342"></a>00342   <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> cwnd;  
<a name="l00343"></a>00343   <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> ssthresh;
<a name="l00344"></a>00344 
<a name="l00345"></a>00345   <span class="comment">/* sender variables */</span>
<a name="l00346"></a>00346   u32_t snd_nxt;   <span class="comment">/* next new seqno to be sent */</span>
<a name="l00347"></a>00347   <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> snd_wnd;   <span class="comment">/* sender window */</span>
<a name="l00348"></a>00348   u32_t snd_wl1, snd_wl2; <span class="comment">/* Sequence and acknowledgement numbers of last</span>
<a name="l00349"></a>00349 <span class="comment">                             window update. */</span>
<a name="l00350"></a>00350   u32_t snd_lbb;       <span class="comment">/* Sequence number of next byte to be buffered. */</span>
<a name="l00351"></a>00351 
<a name="l00352"></a>00352   <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> acked;
<a name="l00353"></a>00353   
<a name="l00354"></a>00354   <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> snd_buf;   <span class="comment">/* Available buffer space for sending (in bytes). */</span>
<a name="l00355"></a>00355 <span class="preprocessor">#define TCP_SNDQUEUELEN_OVERFLOW (0xffff-3)</span>
<a name="l00356"></a>00356 <span class="preprocessor"></span>  <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> snd_queuelen; <span class="comment">/* Available buffer space for sending (in tcp_segs). */</span>
<a name="l00357"></a>00357   
<a name="l00358"></a>00358   
<a name="l00359"></a>00359   <span class="comment">/* These are ordered by sequence number: */</span>
<a name="l00360"></a>00360   <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> *unsent;   <span class="comment">/* Unsent (queued) segments. */</span>
<a name="l00361"></a>00361   <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> *unacked;  <span class="comment">/* Sent but unacknowledged segments. */</span>
<a name="l00362"></a>00362 <span class="preprocessor">#if TCP_QUEUE_OOSEQ  </span>
<a name="l00363"></a>00363 <span class="preprocessor"></span>  <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> *ooseq;    <span class="comment">/* Received out of sequence segments. */</span>
<a name="l00364"></a>00364 <span class="preprocessor">#endif </span><span class="comment">/* TCP_QUEUE_OOSEQ */</span>
<a name="l00365"></a>00365 
<a name="l00366"></a>00366   <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *refused_data; <span class="comment">/* Data previously received but not yet taken by upper layer */</span>
<a name="l00367"></a>00367 
<a name="l00368"></a>00368 <span class="preprocessor">#if LWIP_CALLBACK_API</span>
<a name="l00369"></a>00369 <span class="preprocessor"></span>  <span class="comment">/* Function to be called when more send buffer space is available.</span>
<a name="l00370"></a>00370 <span class="comment">   * @param arg user-supplied argument (tcp_pcb.callback_arg)</span>
<a name="l00371"></a>00371 <span class="comment">   * @param pcb the tcp_pcb which has send buffer space available</span>
<a name="l00372"></a>00372 <span class="comment">   * @param space the amount of bytes available</span>
<a name="l00373"></a>00373 <span class="comment">   * @return ERR_OK: try to send some data by calling tcp_output</span>
<a name="l00374"></a>00374 <span class="comment">   */</span>
<a name="l00375"></a>00375   err_t (* sent)(<span class="keywordtype">void</span> *arg, <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> space);
<a name="l00376"></a>00376   
<a name="l00377"></a>00377   <span class="comment">/* Function to be called when (in-sequence) data has arrived.</span>
<a name="l00378"></a>00378 <span class="comment">   * @param arg user-supplied argument (tcp_pcb.callback_arg)</span>
<a name="l00379"></a>00379 <span class="comment">   * @param pcb the tcp_pcb for which data has arrived</span>
<a name="l00380"></a>00380 <span class="comment">   * @param p the packet buffer which arrived</span>
<a name="l00381"></a>00381 <span class="comment">   * @param err an error argument (TODO: that is current always ERR_OK?)</span>
<a name="l00382"></a>00382 <span class="comment">   * @return ERR_OK: try to send some data by calling tcp_output</span>
<a name="l00383"></a>00383 <span class="comment">   */</span>
<a name="l00384"></a>00384   err_t (* recv)(<span class="keywordtype">void</span> *arg, <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *p, err_t err);
<a name="l00385"></a>00385 
<a name="l00386"></a>00386   <span class="comment">/* Function to be called when a connection has been set up.</span>
<a name="l00387"></a>00387 <span class="comment">   * @param arg user-supplied argument (tcp_pcb.callback_arg)</span>
<a name="l00388"></a>00388 <span class="comment">   * @param pcb the tcp_pcb that now is connected</span>
<a name="l00389"></a>00389 <span class="comment">   * @param err an error argument (TODO: that is current always ERR_OK?)</span>
<a name="l00390"></a>00390 <span class="comment">   * @return value is currently ignored</span>
<a name="l00391"></a>00391 <span class="comment">   */</span>
<a name="l00392"></a>00392   err_t (* connected)(<span class="keywordtype">void</span> *arg, <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, err_t err);
<a name="l00393"></a>00393 
<a name="l00394"></a>00394   <span class="comment">/* Function which is called periodically.</span>
<a name="l00395"></a>00395 <span class="comment">   * The period can be adjusted in multiples of the TCP slow timer interval</span>
<a name="l00396"></a>00396 <span class="comment">   * by changing tcp_pcb.polltmr.</span>
<a name="l00397"></a>00397 <span class="comment">   * @param arg user-supplied argument (tcp_pcb.callback_arg)</span>
<a name="l00398"></a>00398 <span class="comment">   * @param pcb the tcp_pcb to poll for</span>
<a name="l00399"></a>00399 <span class="comment">   * @return ERR_OK: try to send some data by calling tcp_output</span>
<a name="l00400"></a>00400 <span class="comment">   */</span>
<a name="l00401"></a>00401   err_t (* poll)(<span class="keywordtype">void</span> *arg, <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
<a name="l00402"></a>00402 
<a name="l00403"></a>00403   <span class="comment">/* Function to be called whenever a fatal error occurs.</span>
<a name="l00404"></a>00404 <span class="comment">   * There is no pcb parameter since most of the times, the pcb is</span>
<a name="l00405"></a>00405 <span class="comment">   * already deallocated (or there is no pcb) when this function is called.</span>
<a name="l00406"></a>00406 <span class="comment">   * @param arg user-supplied argument (tcp_pcb.callback_arg)</span>
<a name="l00407"></a>00407 <span class="comment">   * @param err an indication why the error callback is called:</span>
<a name="l00408"></a>00408 <span class="comment">   *            ERR_ABRT: aborted through tcp_abort or by a TCP timer</span>
<a name="l00409"></a>00409 <span class="comment">   *            ERR_RST: the connection was reset by the remote host</span>
<a name="l00410"></a>00410 <span class="comment">   */</span>
<a name="l00411"></a>00411   void (* errf)(<span class="keywordtype">void</span> *arg, err_t err);
<a name="l00412"></a>00412 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_CALLBACK_API */</span>
<a name="l00413"></a>00413 
<a name="l00414"></a>00414 <span class="preprocessor">#if LWIP_TCP_TIMESTAMPS</span>
<a name="l00415"></a>00415 <span class="preprocessor"></span>  u32_t ts_lastacksent;
<a name="l00416"></a>00416   u32_t ts_recent;
<a name="l00417"></a>00417 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_TCP_TIMESTAMPS */</span>
<a name="l00418"></a>00418 
<a name="l00419"></a>00419   <span class="comment">/* idle time before KEEPALIVE is sent */</span>
<a name="l00420"></a>00420   u32_t keep_idle;
<a name="l00421"></a>00421 <span class="preprocessor">#if LWIP_TCP_KEEPALIVE</span>
<a name="l00422"></a>00422 <span class="preprocessor"></span>  u32_t keep_intvl;
<a name="l00423"></a>00423   u32_t keep_cnt;
<a name="l00424"></a>00424 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_TCP_KEEPALIVE */</span>
<a name="l00425"></a>00425   
<a name="l00426"></a>00426   <span class="comment">/* Persist timer counter */</span>
<a name="l00427"></a>00427   u32_t persist_cnt;
<a name="l00428"></a>00428   <span class="comment">/* Persist timer back-off */</span>
<a name="l00429"></a>00429   <a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> persist_backoff;
<a name="l00430"></a>00430 
<a name="l00431"></a>00431   <span class="comment">/* KEEPALIVE counter */</span>
<a name="l00432"></a>00432   <a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> keep_cnt_sent;
<a name="l00433"></a>00433 };
<a name="l00434"></a>00434 
<a name="l00435"></a><a class="code" href="structtcp__pcb__listen.html">00435</a> <span class="keyword">struct </span><a class="code" href="structtcp__pcb__listen.html">tcp_pcb_listen</a> {  
<a name="l00436"></a>00436 <span class="comment">/* Common members of all PCB types */</span>
<a name="l00437"></a>00437   IP_PCB;
<a name="l00438"></a>00438 <span class="comment">/* Protocol specific PCB members */</span>
<a name="l00439"></a>00439   TCP_PCB_COMMON(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb__listen.html">tcp_pcb_listen</a>);
<a name="l00440"></a>00440 
<a name="l00441"></a>00441 <span class="preprocessor">#if TCP_LISTEN_BACKLOG</span>
<a name="l00442"></a>00442 <span class="preprocessor"></span>  <a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> backlog;
<a name="l00443"></a>00443   <a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> accepts_pending;
<a name="l00444"></a>00444 <span class="preprocessor">#endif </span><span class="comment">/* TCP_LISTEN_BACKLOG */</span>
<a name="l00445"></a>00445 };
<a name="l00446"></a>00446 
<a name="l00447"></a>00447 <span class="preprocessor">#if LWIP_EVENT_API</span>
<a name="l00448"></a>00448 <span class="preprocessor"></span>
<a name="l00449"></a>00449 <span class="keyword">enum</span> lwip_event {
<a name="l00450"></a>00450   LWIP_EVENT_ACCEPT,
<a name="l00451"></a>00451   LWIP_EVENT_SENT,
<a name="l00452"></a>00452   LWIP_EVENT_RECV,
<a name="l00453"></a>00453   LWIP_EVENT_CONNECTED,
<a name="l00454"></a>00454   LWIP_EVENT_POLL,
<a name="l00455"></a>00455   LWIP_EVENT_ERR
<a name="l00456"></a>00456 };
<a name="l00457"></a>00457 
<a name="l00458"></a>00458 err_t lwip_tcp_event(<span class="keywordtype">void</span> *arg, <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb,
<a name="l00459"></a>00459          <span class="keyword">enum</span> lwip_event,
<a name="l00460"></a>00460          <span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p,
<a name="l00461"></a>00461          <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> size,
<a name="l00462"></a>00462          err_t err);
<a name="l00463"></a>00463 
<a name="l00464"></a>00464 <span class="preprocessor">#define TCP_EVENT_ACCEPT(pcb,err,ret)    ret = lwip_tcp_event((pcb)-&gt;callback_arg, (pcb),\</span>
<a name="l00465"></a>00465 <span class="preprocessor">                LWIP_EVENT_ACCEPT, NULL, 0, err)</span>
<a name="l00466"></a>00466 <span class="preprocessor"></span><span class="preprocessor">#define TCP_EVENT_SENT(pcb,space,ret) ret = lwip_tcp_event((pcb)-&gt;callback_arg, (pcb),\</span>
<a name="l00467"></a>00467 <span class="preprocessor">                   LWIP_EVENT_SENT, NULL, space, ERR_OK)</span>
<a name="l00468"></a>00468 <span class="preprocessor"></span><span class="preprocessor">#define TCP_EVENT_RECV(pcb,p,err,ret) ret = lwip_tcp_event((pcb)-&gt;callback_arg, (pcb),\</span>
<a name="l00469"></a>00469 <span class="preprocessor">                LWIP_EVENT_RECV, (p), 0, (err))</span>
<a name="l00470"></a>00470 <span class="preprocessor"></span><span class="preprocessor">#define TCP_EVENT_CONNECTED(pcb,err,ret) ret = lwip_tcp_event((pcb)-&gt;callback_arg, (pcb),\</span>
<a name="l00471"></a>00471 <span class="preprocessor">                LWIP_EVENT_CONNECTED, NULL, 0, (err))</span>
<a name="l00472"></a>00472 <span class="preprocessor"></span><span class="preprocessor">#define TCP_EVENT_POLL(pcb,ret)       ret = lwip_tcp_event((pcb)-&gt;callback_arg, (pcb),\</span>
<a name="l00473"></a>00473 <span class="preprocessor">                LWIP_EVENT_POLL, NULL, 0, ERR_OK)</span>
<a name="l00474"></a>00474 <span class="preprocessor"></span><span class="preprocessor">#define TCP_EVENT_ERR(errf,arg,err)  lwip_tcp_event((arg), NULL, \</span>
<a name="l00475"></a>00475 <span class="preprocessor">                LWIP_EVENT_ERR, NULL, 0, (err))</span>
<a name="l00476"></a>00476 <span class="preprocessor"></span><span class="preprocessor">#else </span><span class="comment">/* LWIP_EVENT_API */</span>
<a name="l00477"></a>00477 
<a name="l00478"></a>00478 <span class="preprocessor">#define TCP_EVENT_ACCEPT(pcb,err,ret)                          \</span>
<a name="l00479"></a>00479 <span class="preprocessor">  do {                                                         \</span>
<a name="l00480"></a>00480 <span class="preprocessor">    if((pcb)-&gt;accept != NULL)                                  \</span>
<a name="l00481"></a>00481 <span class="preprocessor">      (ret) = (pcb)-&gt;accept((pcb)-&gt;callback_arg,(pcb),(err));  \</span>
<a name="l00482"></a>00482 <span class="preprocessor">    else (ret) = ERR_OK;                                       \</span>
<a name="l00483"></a>00483 <span class="preprocessor">  } while (0)</span>
<a name="l00484"></a>00484 <span class="preprocessor"></span>
<a name="l00485"></a>00485 <span class="preprocessor">#define TCP_EVENT_SENT(pcb,space,ret)                          \</span>
<a name="l00486"></a>00486 <span class="preprocessor">  do {                                                         \</span>
<a name="l00487"></a>00487 <span class="preprocessor">    if((pcb)-&gt;sent != NULL)                                    \</span>
<a name="l00488"></a>00488 <span class="preprocessor">      (ret) = (pcb)-&gt;sent((pcb)-&gt;callback_arg,(pcb),(space));  \</span>
<a name="l00489"></a>00489 <span class="preprocessor">    else (ret) = ERR_OK;                                       \</span>
<a name="l00490"></a>00490 <span class="preprocessor">  } while (0)</span>
<a name="l00491"></a>00491 <span class="preprocessor"></span>
<a name="l00492"></a>00492 <span class="preprocessor">#define TCP_EVENT_RECV(pcb,p,err,ret)                           \</span>
<a name="l00493"></a>00493 <span class="preprocessor">  do {                                                          \</span>
<a name="l00494"></a>00494 <span class="preprocessor">    if((pcb)-&gt;recv != NULL) {                                   \</span>
<a name="l00495"></a>00495 <span class="preprocessor">      (ret) = (pcb)-&gt;recv((pcb)-&gt;callback_arg,(pcb),(p),(err)); \</span>
<a name="l00496"></a>00496 <span class="preprocessor">    } else {                                                    \</span>
<a name="l00497"></a>00497 <span class="preprocessor">      (ret) = tcp_recv_null(NULL, (pcb), (p), (err));           \</span>
<a name="l00498"></a>00498 <span class="preprocessor">    }                                                           \</span>
<a name="l00499"></a>00499 <span class="preprocessor">  } while (0)</span>
<a name="l00500"></a>00500 <span class="preprocessor"></span>
<a name="l00501"></a>00501 <span class="preprocessor">#define TCP_EVENT_CONNECTED(pcb,err,ret)                         \</span>
<a name="l00502"></a>00502 <span class="preprocessor">  do {                                                           \</span>
<a name="l00503"></a>00503 <span class="preprocessor">    if((pcb)-&gt;connected != NULL)                                 \</span>
<a name="l00504"></a>00504 <span class="preprocessor">      (ret) = (pcb)-&gt;connected((pcb)-&gt;callback_arg,(pcb),(err)); \</span>
<a name="l00505"></a>00505 <span class="preprocessor">    else (ret) = ERR_OK;                                         \</span>
<a name="l00506"></a>00506 <span class="preprocessor">  } while (0)</span>
<a name="l00507"></a>00507 <span class="preprocessor"></span>
<a name="l00508"></a>00508 <span class="preprocessor">#define TCP_EVENT_POLL(pcb,ret)                                \</span>
<a name="l00509"></a>00509 <span class="preprocessor">  do {                                                         \</span>
<a name="l00510"></a>00510 <span class="preprocessor">    if((pcb)-&gt;poll != NULL)                                    \</span>
<a name="l00511"></a>00511 <span class="preprocessor">      (ret) = (pcb)-&gt;poll((pcb)-&gt;callback_arg,(pcb));          \</span>
<a name="l00512"></a>00512 <span class="preprocessor">    else (ret) = ERR_OK;                                       \</span>
<a name="l00513"></a>00513 <span class="preprocessor">  } while (0)</span>
<a name="l00514"></a>00514 <span class="preprocessor"></span>
<a name="l00515"></a>00515 <span class="preprocessor">#define TCP_EVENT_ERR(errf,arg,err)                            \</span>
<a name="l00516"></a>00516 <span class="preprocessor">  do {                                                         \</span>
<a name="l00517"></a>00517 <span class="preprocessor">    if((errf) != NULL)                                         \</span>
<a name="l00518"></a>00518 <span class="preprocessor">      (errf)((arg),(err));                                     \</span>
<a name="l00519"></a>00519 <span class="preprocessor">  } while (0)</span>
<a name="l00520"></a>00520 <span class="preprocessor"></span>
<a name="l00521"></a>00521 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_EVENT_API */</span>
<a name="l00522"></a>00522 
<a name="l00523"></a>00523 <span class="comment">/* This structure represents a TCP segment on the unsent and unacked queues */</span>
<a name="l00524"></a><a class="code" href="structtcp__seg.html">00524</a> <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> {
<a name="l00525"></a>00525   <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> *next;    <span class="comment">/* used when putting segements on a queue */</span>
<a name="l00526"></a>00526   <span class="keyword">struct </span><a class="code" href="structpbuf.html">pbuf</a> *p;          <span class="comment">/* buffer containing data + TCP header */</span>
<a name="l00527"></a>00527   <span class="keywordtype">void</span> *dataptr;           <span class="comment">/* pointer to the TCP data in the pbuf */</span>
<a name="l00528"></a>00528   <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> <a class="code" href="structpbuf.html#a6f82449625e36e294f5d210268c0703f">len</a>;               <span class="comment">/* the TCP length of this segment */</span>
<a name="l00529"></a>00529   <a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a>  <a class="code" href="structpbuf.html#aa4d1af2cab3d9280d29212095b5b872a">flags</a>;
<a name="l00530"></a>00530 <span class="preprocessor">#define TF_SEG_OPTS_MSS   (u8_t)0x01U   </span><span class="comment">/* Include MSS option. */</span>
<a name="l00531"></a>00531 <span class="preprocessor">#define TF_SEG_OPTS_TS    (u8_t)0x02U   </span><span class="comment">/* Include timestamp option. */</span>
<a name="l00532"></a>00532   <span class="keyword">struct </span><a class="code" href="structtcp__hdr.html">tcp_hdr</a> *<a class="code" href="structtcphdr.html">tcphdr</a>;  <span class="comment">/* the TCP header */</span>
<a name="l00533"></a>00533 };
<a name="l00534"></a>00534 
<a name="l00535"></a>00535 <span class="preprocessor">#define LWIP_TCP_OPT_LENGTH(flags)              \</span>
<a name="l00536"></a>00536 <span class="preprocessor">  (flags &amp; TF_SEG_OPTS_MSS ? 4  : 0) +          \</span>
<a name="l00537"></a>00537 <span class="preprocessor">  (flags &amp; TF_SEG_OPTS_TS  ? 12 : 0)</span>
<a name="l00538"></a>00538 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00539"></a>00539 <span class="comment">/** This returns a TCP header option for MSS in an u32_t */</span>
<a name="l00540"></a>00540 <span class="preprocessor">#define TCP_BUILD_MSS_OPTION(x) (x) = htonl(((u32_t)2 &lt;&lt; 24) |          \</span>
<a name="l00541"></a>00541 <span class="preprocessor">                                            ((u32_t)4 &lt;&lt; 16) |          \</span>
<a name="l00542"></a>00542 <span class="preprocessor">                                            (((u32_t)TCP_MSS / 256) &lt;&lt; 8) | \</span>
<a name="l00543"></a>00543 <span class="preprocessor">                                            (TCP_MSS &amp; 255))</span>
<a name="l00544"></a>00544 <span class="preprocessor"></span>
<a name="l00545"></a>00545 <span class="comment">/* Internal functions and global variables: */</span>
<a name="l00546"></a>00546 <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *tcp_pcb_copy(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
<a name="l00547"></a>00547 <span class="keywordtype">void</span> <a class="code" href="tcp_8c.html#a44fc672b9d14a65e61040707c45302ba">tcp_pcb_purge</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
<a name="l00548"></a>00548 <span class="keywordtype">void</span> <a class="code" href="tcp_8c.html#aaaef096f6a03bf5b778329bb66ee06f6">tcp_pcb_remove</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> **pcblist, <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
<a name="l00549"></a>00549 
<a name="l00550"></a>00550 <a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> <a class="code" href="tcp_8c.html#a1f6d5f868cfaf1a4d843f030d61c58ae">tcp_segs_free</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__seg.html">tcp_seg</a> *seg);
<a name="l00551"></a>00551 <a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> <a class="code" href="tcp_8c.html#a404539c2e8a6e38e2d57042225a96b40">tcp_seg_free</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__seg.html">tcp_seg</a> *seg);
<a name="l00552"></a>00552 <span class="keyword">struct </span><a class="code" href="structtcp__seg.html">tcp_seg</a> *<a class="code" href="tcp_8c.html#a569d79451d2570e4ef406775725ef6ef">tcp_seg_copy</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__seg.html">tcp_seg</a> *seg);
<a name="l00553"></a>00553 
<a name="l00554"></a>00554 <span class="preprocessor">#define tcp_ack(pcb)                               \</span>
<a name="l00555"></a>00555 <span class="preprocessor">  do {                                             \</span>
<a name="l00556"></a>00556 <span class="preprocessor">    if((pcb)-&gt;flags &amp; TF_ACK_DELAY) {              \</span>
<a name="l00557"></a>00557 <span class="preprocessor">      (pcb)-&gt;flags &amp;= ~TF_ACK_DELAY;               \</span>
<a name="l00558"></a>00558 <span class="preprocessor">      (pcb)-&gt;flags |= TF_ACK_NOW;                  \</span>
<a name="l00559"></a>00559 <span class="preprocessor">      tcp_output(pcb);                             \</span>
<a name="l00560"></a>00560 <span class="preprocessor">    }                                              \</span>
<a name="l00561"></a>00561 <span class="preprocessor">    else {                                         \</span>
<a name="l00562"></a>00562 <span class="preprocessor">      (pcb)-&gt;flags |= TF_ACK_DELAY;                \</span>
<a name="l00563"></a>00563 <span class="preprocessor">    }                                              \</span>
<a name="l00564"></a>00564 <span class="preprocessor">  } while (0)</span>
<a name="l00565"></a>00565 <span class="preprocessor"></span>
<a name="l00566"></a>00566 <span class="preprocessor">#define tcp_ack_now(pcb)                           \</span>
<a name="l00567"></a>00567 <span class="preprocessor">  do {                                             \</span>
<a name="l00568"></a>00568 <span class="preprocessor">    (pcb)-&gt;flags |= TF_ACK_NOW;                    \</span>
<a name="l00569"></a>00569 <span class="preprocessor">    tcp_output(pcb);                               \</span>
<a name="l00570"></a>00570 <span class="preprocessor">  } while (0)</span>
<a name="l00571"></a>00571 <span class="preprocessor"></span>
<a name="l00572"></a>00572 err_t <a class="code" href="tcp__out_8c.html#ac8e4dca2a2e04c5073f09901742d1146">tcp_send_ctrl</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> flags);
<a name="l00573"></a>00573 err_t <a class="code" href="tcp__out_8c.html#a94dcf0b53c8a8e627c14b5cb01836bdb">tcp_enqueue</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <span class="keywordtype">void</span> *dataptr, <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> len,
<a name="l00574"></a>00574                   <a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> flags, <a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> apiflags, <a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> optflags);
<a name="l00575"></a>00575 
<a name="l00576"></a>00576 <span class="keywordtype">void</span> tcp_rexmit_seg(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <span class="keyword">struct</span> <a class="code" href="structtcp__seg.html">tcp_seg</a> *seg);
<a name="l00577"></a>00577 
<a name="l00578"></a>00578 <span class="keywordtype">void</span> <a class="code" href="tcp__out_8c.html#a168fa0bb172bb0bd29bd58e31f804147">tcp_rst</a>(u32_t seqno, u32_t ackno,
<a name="l00579"></a>00579        <span class="keyword">struct</span> <a class="code" href="structip__addr.html">ip_addr</a> *local_ip, <span class="keyword">struct</span> <a class="code" href="structip__addr.html">ip_addr</a> *remote_ip,
<a name="l00580"></a>00580        <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> local_port, <a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> remote_port);
<a name="l00581"></a>00581 
<a name="l00582"></a>00582 u32_t <a class="code" href="tcp_8c.html#af5427fc45c0694592419b03694b95af7">tcp_next_iss</a>(<span class="keywordtype">void</span>);
<a name="l00583"></a>00583 
<a name="l00584"></a>00584 <span class="keywordtype">void</span> <a class="code" href="tcp__out_8c.html#a13fd5160cf75d19d6696c27d7becf3d9">tcp_keepalive</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
<a name="l00585"></a>00585 <span class="keywordtype">void</span> <a class="code" href="tcp__out_8c.html#a5f0813be2b0fe0852da63d55660c722c">tcp_zero_window_probe</a>(<span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb);
<a name="l00586"></a>00586 
<a name="l00587"></a>00587 <span class="preprocessor">#if TCP_CALCULATE_EFF_SEND_MSS</span>
<a name="l00588"></a>00588 <span class="preprocessor"></span><a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> <a class="code" href="tcp_8c.html#add8d3e84e2018e42cc60d8dee2773bd5">tcp_eff_send_mss</a>(<a class="code" href="group__uipopt.html#gafc6499c1f28697aa3bfc2804d496fd11">u16_t</a> sendmss, <span class="keyword">struct</span> <a class="code" href="structip__addr.html">ip_addr</a> *addr);
<a name="l00589"></a>00589 <span class="preprocessor">#endif </span><span class="comment">/* TCP_CALCULATE_EFF_SEND_MSS */</span>
<a name="l00590"></a>00590 
<a name="l00591"></a>00591 <span class="preprocessor">#if LWIP_CALLBACK_API</span>
<a name="l00592"></a>00592 <span class="preprocessor"></span>err_t <a class="code" href="tcp_8c.html#a0cb3f604fc8d20870d8cab291da5701c">tcp_recv_null</a>(<span class="keywordtype">void</span> *arg, <span class="keyword">struct</span> <a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcb, <span class="keyword">struct</span> <a class="code" href="structpbuf.html">pbuf</a> *p, err_t err);
<a name="l00593"></a>00593 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_CALLBACK_API */</span>
<a name="l00594"></a>00594 
<a name="l00595"></a>00595 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *tcp_input_pcb;
<a name="l00596"></a>00596 <span class="keyword">extern</span> u32_t tcp_ticks;
<a name="l00597"></a>00597 
<a name="l00598"></a>00598 <span class="keyword">const</span> <span class="keywordtype">char</span>* tcp_debug_state_str(<span class="keyword">enum</span> tcp_state s);
<a name="l00599"></a>00599 <span class="preprocessor">#if TCP_DEBUG || TCP_INPUT_DEBUG || TCP_OUTPUT_DEBUG</span>
<a name="l00600"></a>00600 <span class="preprocessor"></span><span class="keywordtype">void</span> tcp_debug_print(<span class="keyword">struct</span> <a class="code" href="structtcp__hdr.html">tcp_hdr</a> *<a class="code" href="structtcphdr.html">tcphdr</a>);
<a name="l00601"></a>00601 <span class="keywordtype">void</span> tcp_debug_print_flags(<a class="code" href="group__uipopt.html#gae081489b4906f65a3cb18e9fbe9f8d23">u8_t</a> flags);
<a name="l00602"></a>00602 <span class="keywordtype">void</span> tcp_debug_print_state(<span class="keyword">enum</span> tcp_state s);
<a name="l00603"></a>00603 <span class="keywordtype">void</span> tcp_debug_print_pcbs(<span class="keywordtype">void</span>);
<a name="l00604"></a>00604 s16_t tcp_pcbs_sane(<span class="keywordtype">void</span>);
<a name="l00605"></a>00605 <span class="preprocessor">#else</span>
<a name="l00606"></a>00606 <span class="preprocessor"></span><span class="preprocessor">#  define tcp_debug_print(tcphdr)</span>
<a name="l00607"></a>00607 <span class="preprocessor"></span><span class="preprocessor">#  define tcp_debug_print_flags(flags)</span>
<a name="l00608"></a>00608 <span class="preprocessor"></span><span class="preprocessor">#  define tcp_debug_print_state(s)</span>
<a name="l00609"></a>00609 <span class="preprocessor"></span><span class="preprocessor">#  define tcp_debug_print_pcbs()</span>
<a name="l00610"></a>00610 <span class="preprocessor"></span><span class="preprocessor">#  define tcp_pcbs_sane() 1</span>
<a name="l00611"></a>00611 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* TCP_DEBUG */</span>
<a name="l00612"></a>00612 
<a name="l00613"></a>00613 <span class="preprocessor">#if NO_SYS</span>
<a name="l00614"></a>00614 <span class="preprocessor"></span><span class="preprocessor">#define tcp_timer_needed()</span>
<a name="l00615"></a>00615 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00616"></a>00616 <span class="preprocessor"></span><span class="keywordtype">void</span> <a class="code" href="tcpip_8c.html#a8181bc316fdf61b85f787c5cadfcd249">tcp_timer_needed</a>(<span class="keywordtype">void</span>);
<a name="l00617"></a>00617 <span class="preprocessor">#endif</span>
<a name="l00618"></a>00618 <span class="preprocessor"></span>
<a name="l00619"></a>00619 <span class="comment">/* The TCP PCB lists. */</span>
<a name="l00620"></a><a class="code" href="uniontcp__listen__pcbs__t.html">00620</a> <span class="keyword">union </span><a class="code" href="uniontcp__listen__pcbs__t.html">tcp_listen_pcbs_t</a> { <span class="comment">/* List of all TCP PCBs in LISTEN state. */</span>
<a name="l00621"></a>00621   <span class="keyword">struct </span><a class="code" href="structtcp__pcb__listen.html">tcp_pcb_listen</a> *listen_pcbs; 
<a name="l00622"></a>00622   <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *pcbs;
<a name="l00623"></a>00623 };
<a name="l00624"></a>00624 <span class="keyword">extern</span> <span class="keyword">union </span><a class="code" href="uniontcp__listen__pcbs__t.html">tcp_listen_pcbs_t</a> <a class="code" href="tcp_8c.html#a96fe1350e510d4308ac9969ffb4c9c81">tcp_listen_pcbs</a>;
<a name="l00625"></a>00625 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *<a class="code" href="tcp_8c.html#a78c09dbae67ccc06b659d9f1a388f911">tcp_active_pcbs</a>;  <span class="comment">/* List of all TCP PCBs that are in a</span>
<a name="l00626"></a>00626 <span class="comment">              state in which they accept or send</span>
<a name="l00627"></a>00627 <span class="comment">              data. */</span>
<a name="l00628"></a>00628 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *<a class="code" href="tcp_8c.html#a9a522a66c5e1f1a4e28fe7a672cc64e3">tcp_tw_pcbs</a>;      <span class="comment">/* List of all TCP PCBs in TIME-WAIT. */</span>
<a name="l00629"></a>00629 
<a name="l00630"></a>00630 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="structtcp__pcb.html">tcp_pcb</a> *tcp_tmp_pcb;      <span class="comment">/* Only used for temporary storage. */</span>
<a name="l00631"></a>00631 
<a name="l00632"></a>00632 <span class="comment">/* Axioms about the above lists:   </span>
<a name="l00633"></a>00633 <span class="comment">   1) Every TCP PCB that is not CLOSED is in one of the lists.</span>
<a name="l00634"></a>00634 <span class="comment">   2) A PCB is only in one of the lists.</span>
<a name="l00635"></a>00635 <span class="comment">   3) All PCBs in the tcp_listen_pcbs list is in LISTEN state.</span>
<a name="l00636"></a>00636 <span class="comment">   4) All PCBs in the tcp_tw_pcbs list is in TIME-WAIT state.</span>
<a name="l00637"></a>00637 <span class="comment">*/</span>
<a name="l00638"></a>00638 
<a name="l00639"></a>00639 <span class="comment">/* Define two macros, TCP_REG and TCP_RMV that registers a TCP PCB</span>
<a name="l00640"></a>00640 <span class="comment">   with a PCB list or removes a PCB from a list, respectively. */</span>
<a name="l00641"></a>00641 <span class="preprocessor">#if 0</span>
<a name="l00642"></a>00642 <span class="preprocessor"></span><span class="preprocessor">#define TCP_REG(pcbs, npcb) do {\</span>
<a name="l00643"></a>00643 <span class="preprocessor">                            LWIP_DEBUGF(TCP_DEBUG, (&quot;TCP_REG %p local port %d\n&quot;, npcb, npcb-&gt;local_port)); \</span>
<a name="l00644"></a>00644 <span class="preprocessor">                            for(tcp_tmp_pcb = *pcbs; \</span>
<a name="l00645"></a>00645 <span class="preprocessor">          tcp_tmp_pcb != NULL; \</span>
<a name="l00646"></a>00646 <span class="preprocessor">        tcp_tmp_pcb = tcp_tmp_pcb-&gt;next) { \</span>
<a name="l00647"></a>00647 <span class="preprocessor">                                LWIP_ASSERT(&quot;TCP_REG: already registered\n&quot;, tcp_tmp_pcb != npcb); \</span>
<a name="l00648"></a>00648 <span class="preprocessor">                            } \</span>
<a name="l00649"></a>00649 <span class="preprocessor">                            LWIP_ASSERT(&quot;TCP_REG: pcb-&gt;state != CLOSED&quot;, npcb-&gt;state != CLOSED); \</span>
<a name="l00650"></a>00650 <span class="preprocessor">                            npcb-&gt;next = *pcbs; \</span>
<a name="l00651"></a>00651 <span class="preprocessor">                            LWIP_ASSERT(&quot;TCP_REG: npcb-&gt;next != npcb&quot;, npcb-&gt;next != npcb); \</span>
<a name="l00652"></a>00652 <span class="preprocessor">                            *(pcbs) = npcb; \</span>
<a name="l00653"></a>00653 <span class="preprocessor">                            LWIP_ASSERT(&quot;TCP_RMV: tcp_pcbs sane&quot;, tcp_pcbs_sane()); \</span>
<a name="l00654"></a>00654 <span class="preprocessor">              tcp_timer_needed(); \</span>
<a name="l00655"></a>00655 <span class="preprocessor">                            } while(0)</span>
<a name="l00656"></a>00656 <span class="preprocessor"></span><span class="preprocessor">#define TCP_RMV(pcbs, npcb) do { \</span>
<a name="l00657"></a>00657 <span class="preprocessor">                            LWIP_ASSERT(&quot;TCP_RMV: pcbs != NULL&quot;, *pcbs != NULL); \</span>
<a name="l00658"></a>00658 <span class="preprocessor">                            LWIP_DEBUGF(TCP_DEBUG, (&quot;TCP_RMV: removing %p from %p\n&quot;, npcb, *pcbs)); \</span>
<a name="l00659"></a>00659 <span class="preprocessor">                            if(*pcbs == npcb) { \</span>
<a name="l00660"></a>00660 <span class="preprocessor">                               *pcbs = (*pcbs)-&gt;next; \</span>
<a name="l00661"></a>00661 <span class="preprocessor">                            } else for(tcp_tmp_pcb = *pcbs; tcp_tmp_pcb != NULL; tcp_tmp_pcb = tcp_tmp_pcb-&gt;next) { \</span>
<a name="l00662"></a>00662 <span class="preprocessor">                               if(tcp_tmp_pcb-&gt;next == npcb) { \</span>
<a name="l00663"></a>00663 <span class="preprocessor">                                  tcp_tmp_pcb-&gt;next = npcb-&gt;next; \</span>
<a name="l00664"></a>00664 <span class="preprocessor">                                  break; \</span>
<a name="l00665"></a>00665 <span class="preprocessor">                               } \</span>
<a name="l00666"></a>00666 <span class="preprocessor">                            } \</span>
<a name="l00667"></a>00667 <span class="preprocessor">                            npcb-&gt;next = NULL; \</span>
<a name="l00668"></a>00668 <span class="preprocessor">                            LWIP_ASSERT(&quot;TCP_RMV: tcp_pcbs sane&quot;, tcp_pcbs_sane()); \</span>
<a name="l00669"></a>00669 <span class="preprocessor">                            LWIP_DEBUGF(TCP_DEBUG, (&quot;TCP_RMV: removed %p from %p\n&quot;, npcb, *pcbs)); \</span>
<a name="l00670"></a>00670 <span class="preprocessor">                            } while(0)</span>
<a name="l00671"></a>00671 <span class="preprocessor"></span>
<a name="l00672"></a>00672 <span class="preprocessor">#else </span><span class="comment">/* LWIP_DEBUG */</span>
<a name="l00673"></a>00673 
<a name="l00674"></a>00674 <span class="preprocessor">#define TCP_REG(pcbs, npcb)                        \</span>
<a name="l00675"></a>00675 <span class="preprocessor">  do {                                             \</span>
<a name="l00676"></a>00676 <span class="preprocessor">    npcb-&gt;next = *pcbs;                            \</span>
<a name="l00677"></a>00677 <span class="preprocessor">    *(pcbs) = npcb;                                \</span>
<a name="l00678"></a>00678 <span class="preprocessor">    tcp_timer_needed();                            \</span>
<a name="l00679"></a>00679 <span class="preprocessor">  } while (0)</span>
<a name="l00680"></a>00680 <span class="preprocessor"></span>
<a name="l00681"></a>00681 <span class="preprocessor">#define TCP_RMV(pcbs, npcb)                        \</span>
<a name="l00682"></a>00682 <span class="preprocessor">  do {                                             \</span>
<a name="l00683"></a>00683 <span class="preprocessor">    if(*(pcbs) == npcb) {                          \</span>
<a name="l00684"></a>00684 <span class="preprocessor">      (*(pcbs)) = (*pcbs)-&gt;next;                   \</span>
<a name="l00685"></a>00685 <span class="preprocessor">    }                                              \</span>
<a name="l00686"></a>00686 <span class="preprocessor">    else {                                         \</span>
<a name="l00687"></a>00687 <span class="preprocessor">      for(tcp_tmp_pcb = *pcbs;                                         \</span>
<a name="l00688"></a>00688 <span class="preprocessor">          tcp_tmp_pcb != NULL;                                         \</span>
<a name="l00689"></a>00689 <span class="preprocessor">          tcp_tmp_pcb = tcp_tmp_pcb-&gt;next) {                           \</span>
<a name="l00690"></a>00690 <span class="preprocessor">        if(tcp_tmp_pcb-&gt;next == npcb) {   \</span>
<a name="l00691"></a>00691 <span class="preprocessor">          tcp_tmp_pcb-&gt;next = npcb-&gt;next;          \</span>
<a name="l00692"></a>00692 <span class="preprocessor">          break;                                   \</span>
<a name="l00693"></a>00693 <span class="preprocessor">        }                                          \</span>
<a name="l00694"></a>00694 <span class="preprocessor">      }                                            \</span>
<a name="l00695"></a>00695 <span class="preprocessor">    }                                              \</span>
<a name="l00696"></a>00696 <span class="preprocessor">    npcb-&gt;next = NULL;                             \</span>
<a name="l00697"></a>00697 <span class="preprocessor">  } while(0)</span>
<a name="l00698"></a>00698 <span class="preprocessor"></span>
<a name="l00699"></a>00699 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_DEBUG */</span>
<a name="l00700"></a>00700 
<a name="l00701"></a>00701 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l00702"></a>00702 <span class="preprocessor"></span>}
<a name="l00703"></a>00703 <span class="preprocessor">#endif</span>
<a name="l00704"></a>00704 <span class="preprocessor"></span>
<a name="l00705"></a>00705 <span class="preprocessor">#endif </span><span class="comment">/* LWIP_TCP */</span>
<a name="l00706"></a>00706 
<a name="l00707"></a>00707 <span class="preprocessor">#endif </span><span class="comment">/* __LWIP_TCP_H__ */</span>
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
