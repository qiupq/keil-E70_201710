<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SAME70 Xplained Software Package: libraries/libusb/common/core/USBH_HAL.c Source File</title>
<link href="common/style.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
    <div id="body">
        <div id="title">  SAME70 Xplained Software Package 1.5</div>
        <div id="banner"></div>

<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="dir_81818f1c1b01098ad6d8389f2aaf9f72.html">libraries</a>      </li>
      <li><a class="el" href="dir_e365a8e7e6dab9d5b63f3989eef3bf2b.html">libusb</a>      </li>
      <li><a class="el" href="dir_b36a190e1fe9f8cfe4df7936496db854.html">common</a>      </li>
      <li><a class="el" href="dir_6e3818122f158cde411be17551301587.html">core</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>USBH_HAL.c</h1>  </div>
</div>
<div class="contents">
<a href="_u_s_b_h___h_a_l_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* ---------------------------------------------------------------------------- */</span>
<a name="l00002"></a>00002 <span class="comment">/*                  Atmel Microcontroller Software Support                      */</span>
<a name="l00003"></a>00003 <span class="comment">/*                       SAM Software Package License                           */</span>
<a name="l00004"></a>00004 <span class="comment">/* ---------------------------------------------------------------------------- */</span>
<a name="l00005"></a>00005 <span class="comment">/* Copyright (c) 2015, Atmel Corporation                                        */</span>
<a name="l00006"></a>00006 <span class="comment">/*                                                                              */</span>
<a name="l00007"></a>00007 <span class="comment">/* All rights reserved.                                                         */</span>
<a name="l00008"></a>00008 <span class="comment">/*                                                                              */</span>
<a name="l00009"></a>00009 <span class="comment">/* Redistribution and use in source and binary forms, with or without           */</span>
<a name="l00010"></a>00010 <span class="comment">/* modification, are permitted provided that the following condition is met:    */</span>
<a name="l00011"></a>00011 <span class="comment">/*                                                                              */</span>
<a name="l00012"></a>00012 <span class="comment">/* - Redistributions of source code must retain the above copyright notice,     */</span>
<a name="l00013"></a>00013 <span class="comment">/* this list of conditions and the disclaimer below.                            */</span>
<a name="l00014"></a>00014 <span class="comment">/*                                                                              */</span>
<a name="l00015"></a>00015 <span class="comment">/* Atmel&#39;s name may not be used to endorse or promote products derived from     */</span>
<a name="l00016"></a>00016 <span class="comment">/* this software without specific prior written permission.                     */</span>
<a name="l00017"></a>00017 <span class="comment">/*                                                                              */</span>
<a name="l00018"></a>00018 <span class="comment">/* DISCLAIMER:  THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR   */</span>
<a name="l00019"></a>00019 <span class="comment">/* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF */</span>
<a name="l00020"></a>00020 <span class="comment">/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE   */</span>
<a name="l00021"></a>00021 <span class="comment">/* DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,      */</span>
<a name="l00022"></a>00022 <span class="comment">/* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT */</span>
<a name="l00023"></a>00023 <span class="comment">/* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,  */</span>
<a name="l00024"></a>00024 <span class="comment">/* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF    */</span>
<a name="l00025"></a>00025 <span class="comment">/* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING         */</span>
<a name="l00026"></a>00026 <span class="comment">/* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, */</span>
<a name="l00027"></a>00027 <span class="comment">/* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                           */</span>
<a name="l00028"></a>00028 <span class="comment">/* ---------------------------------------------------------------------------- */</span><span class="comment"></span>
<a name="l00029"></a>00029 <span class="comment">/**</span>
<a name="l00030"></a>00030 <span class="comment"> * \file</span>
<a name="l00031"></a>00031 <span class="comment"> *</span>
<a name="l00032"></a>00032 <span class="comment"> * \brief USB host driver</span>
<a name="l00033"></a>00033 <span class="comment"> * Compliance with common driver UHD</span>
<a name="l00034"></a>00034 <span class="comment"> */</span>
<a name="l00035"></a>00035 <span class="comment">/*</span>
<a name="l00036"></a>00036 <span class="comment"> * Support and FAQ: visit &lt;a href=&quot;http://www.atmel.com/design-support/&quot;&gt;Atmel Support&lt;/a&gt;</span>
<a name="l00037"></a>00037 <span class="comment"> */</span>
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;conf_usb_host.h&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;<a class="code" href="board_8h.html">board.h</a>&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;<a class="code" href="_u_s_b_h_driver_8h.html" title="Common API for USB Host Drivers (UHD).">USBHDriver.h</a>&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;<a class="code" href="_u_s_b_h_8h.html" title="Interface of the USB Host Controller (UHC).">USBH.h</a>&quot;</span>
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 <span class="preprocessor">#ifndef UHD_USB_INT_LEVEL</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span><span class="preprocessor">    #define UHD_USB_INT_LEVEL 5 // By default USB interrupt have low priority</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span>
<a name="l00053"></a>00053 <span class="preprocessor">#define USB_HOST_MAX_EP  9</span>
<a name="l00054"></a>00054 <span class="preprocessor"></span><span class="preprocessor">#define UHD_PIPE_USED(pipe)      (USB_HOST_MAX_EP &gt;= pipe)</span>
<a name="l00055"></a>00055 <span class="preprocessor"></span>
<a name="l00056"></a>00056 <span class="preprocessor">#if ((UHD_PIPE_USED( 1) &amp;&amp; Is_uhd_pipe_dma_supported( 1)) \</span>
<a name="l00057"></a>00057 <span class="preprocessor">    ||(UHD_PIPE_USED( 2) &amp;&amp; Is_uhd_pipe_dma_supported( 2)) \</span>
<a name="l00058"></a>00058 <span class="preprocessor">    ||(UHD_PIPE_USED( 3) &amp;&amp; Is_uhd_pipe_dma_supported( 3)) \</span>
<a name="l00059"></a>00059 <span class="preprocessor">    ||(UHD_PIPE_USED( 4) &amp;&amp; Is_uhd_pipe_dma_supported( 4)) \</span>
<a name="l00060"></a>00060 <span class="preprocessor">    ||(UHD_PIPE_USED( 5) &amp;&amp; Is_uhd_pipe_dma_supported( 5)) \</span>
<a name="l00061"></a>00061 <span class="preprocessor">    ||(UHD_PIPE_USED( 6) &amp;&amp; Is_uhd_pipe_dma_supported( 6)) \</span>
<a name="l00062"></a>00062 <span class="preprocessor">    ||(UHD_PIPE_USED( 7) &amp;&amp; Is_uhd_pipe_dma_supported( 7)) \</span>
<a name="l00063"></a>00063 <span class="preprocessor">    ||(UHD_PIPE_USED( 8) &amp;&amp; Is_uhd_pipe_dma_supported( 8)) \</span>
<a name="l00064"></a>00064 <span class="preprocessor">    ||(UHD_PIPE_USED( 9) &amp;&amp; Is_uhd_pipe_dma_supported( 9)) \</span>
<a name="l00065"></a>00065 <span class="preprocessor">    ||(UHD_PIPE_USED(10) &amp;&amp; Is_uhd_pipe_dma_supported(10)) \</span>
<a name="l00066"></a>00066 <span class="preprocessor">    ||(UHD_PIPE_USED(11) &amp;&amp; Is_uhd_pipe_dma_supported(11)) \</span>
<a name="l00067"></a>00067 <span class="preprocessor">    ||(UHD_PIPE_USED(12) &amp;&amp; Is_uhd_pipe_dma_supported(12)) \</span>
<a name="l00068"></a>00068 <span class="preprocessor">    ||(UHD_PIPE_USED(13) &amp;&amp; Is_uhd_pipe_dma_supported(13)) \</span>
<a name="l00069"></a>00069 <span class="preprocessor">    ||(UHD_PIPE_USED(14) &amp;&amp; Is_uhd_pipe_dma_supported(14)) \</span>
<a name="l00070"></a>00070 <span class="preprocessor">    ||(UHD_PIPE_USED(15) &amp;&amp; Is_uhd_pipe_dma_supported(15)) \</span>
<a name="l00071"></a>00071 <span class="preprocessor">    )</span>
<a name="l00072"></a>00072 <span class="preprocessor"></span><span class="preprocessor"># define UHD_PIPE_DMA_SUPPORTED</span>
<a name="l00073"></a>00073 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00074"></a>00074 <span class="preprocessor"></span>
<a name="l00075"></a>00075 <span class="preprocessor">#if ((UHD_PIPE_USED( 1) &amp;&amp; !Is_uhd_pipe_dma_supported( 1)) \</span>
<a name="l00076"></a>00076 <span class="preprocessor">    ||(UHD_PIPE_USED( 2) &amp;&amp; !Is_uhd_pipe_dma_supported( 2)) \</span>
<a name="l00077"></a>00077 <span class="preprocessor">    ||(UHD_PIPE_USED( 3) &amp;&amp; !Is_uhd_pipe_dma_supported( 3)) \</span>
<a name="l00078"></a>00078 <span class="preprocessor">    ||(UHD_PIPE_USED( 4) &amp;&amp; !Is_uhd_pipe_dma_supported( 4)) \</span>
<a name="l00079"></a>00079 <span class="preprocessor">    ||(UHD_PIPE_USED( 5) &amp;&amp; !Is_uhd_pipe_dma_supported( 5)) \</span>
<a name="l00080"></a>00080 <span class="preprocessor">    ||(UHD_PIPE_USED( 6) &amp;&amp; !Is_uhd_pipe_dma_supported( 6)) \</span>
<a name="l00081"></a>00081 <span class="preprocessor">    ||(UHD_PIPE_USED( 7) &amp;&amp; !Is_uhd_pipe_dma_supported( 7)) \</span>
<a name="l00082"></a>00082 <span class="preprocessor">    ||(UHD_PIPE_USED( 8) &amp;&amp; !Is_uhd_pipe_dma_supported( 8)) \</span>
<a name="l00083"></a>00083 <span class="preprocessor">    ||(UHD_PIPE_USED( 9) &amp;&amp; !Is_uhd_pipe_dma_supported( 9)) \</span>
<a name="l00084"></a>00084 <span class="preprocessor">    ||(UHD_PIPE_USED(10) &amp;&amp; !Is_uhd_pipe_dma_supported(10)) \</span>
<a name="l00085"></a>00085 <span class="preprocessor">    ||(UHD_PIPE_USED(11) &amp;&amp; !Is_uhd_pipe_dma_supported(11)) \</span>
<a name="l00086"></a>00086 <span class="preprocessor">    ||(UHD_PIPE_USED(12) &amp;&amp; !Is_uhd_pipe_dma_supported(12)) \</span>
<a name="l00087"></a>00087 <span class="preprocessor">    ||(UHD_PIPE_USED(13) &amp;&amp; !Is_uhd_pipe_dma_supported(13)) \</span>
<a name="l00088"></a>00088 <span class="preprocessor">    ||(UHD_PIPE_USED(14) &amp;&amp; !Is_uhd_pipe_dma_supported(14)) \</span>
<a name="l00089"></a>00089 <span class="preprocessor">    ||(UHD_PIPE_USED(15) &amp;&amp; !Is_uhd_pipe_dma_supported(15)) \</span>
<a name="l00090"></a>00090 <span class="preprocessor">    )</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span><span class="preprocessor"># define UHD_PIPE_FIFO_SUPPORTED</span>
<a name="l00092"></a>00092 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00093"></a>00093 <span class="preprocessor"></span>
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 
<a name="l00096"></a>00096 <span class="comment">// Optional UHC callbacks</span>
<a name="l00097"></a>00097 <span class="preprocessor">#ifndef UHC_MODE_CHANGE</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span><span class="preprocessor">    #define UHC_MODE_CHANGE(arg)</span>
<a name="l00099"></a>00099 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span><span class="preprocessor">#ifndef UHC_SOF_EVENT</span>
<a name="l00101"></a>00101 <span class="preprocessor"></span><span class="preprocessor">    #define UHC_SOF_EVENT()</span>
<a name="l00102"></a>00102 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00103"></a>00103 <span class="preprocessor"></span><span class="preprocessor">#ifndef UHC_VBUS_CHANGE</span>
<a name="l00104"></a>00104 <span class="preprocessor"></span><span class="preprocessor">    #define UHC_VBUS_CHANGE(b_present)</span>
<a name="l00105"></a>00105 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00106"></a>00106 <span class="preprocessor"></span><span class="preprocessor">#ifndef UHC_VBUS_ERROR</span>
<a name="l00107"></a>00107 <span class="preprocessor"></span><span class="preprocessor">    #define UHC_VBUS_ERROR()</span>
<a name="l00108"></a>00108 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00109"></a>00109 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00110"></a>00110 <span class="comment">/**</span>
<a name="l00111"></a>00111 <span class="comment"> * \ingroup usb_host_group</span>
<a name="l00112"></a>00112 <span class="comment"> * \defgroup uhd_group USB Host Driver (UHD)</span>
<a name="l00113"></a>00113 <span class="comment"> *</span>
<a name="l00114"></a>00114 <span class="comment"> * \section USB_CONF USB dual role configuration</span>
<a name="l00115"></a>00115 <span class="comment"> * The defines UHD_ENABLE and UDD_ENABLE must be added in project to allow</span>
<a name="l00116"></a>00116 <span class="comment"> * the USB low level (UHD) to manage or not the dual role (device and host).</span>
<a name="l00117"></a>00117 <span class="comment"> *</span>
<a name="l00118"></a>00118 <span class="comment"> * \section USBHS_CONF USBHS Custom configuration</span>
<a name="l00119"></a>00119 <span class="comment"> * The following USBHS driver configuration must be defined in conf_usb_host.h</span>
<a name="l00120"></a>00120 <span class="comment"> * file of the application.</span>
<a name="l00121"></a>00121 <span class="comment"> *</span>
<a name="l00122"></a>00122 <span class="comment"> * UHD_USB_INT_LEVEL&lt;br&gt;</span>
<a name="l00123"></a>00123 <span class="comment"> * Option to change the interrupt priority (0 to 15) by default 5 (recommended).</span>
<a name="l00124"></a>00124 <span class="comment"> *</span>
<a name="l00125"></a>00125 <span class="comment"> * UHD_USB_INT_FUN&lt;br&gt;</span>
<a name="l00126"></a>00126 <span class="comment"> * Option to fit interrupt function to what defined in exception table.</span>
<a name="l00127"></a>00127 <span class="comment"> *</span>
<a name="l00128"></a>00128 <span class="comment"> * UHD_ISOCHRONOUS_NB_BANK&lt;br&gt;</span>
<a name="l00129"></a>00129 <span class="comment"> * Feature to reduce or increase isochronous endpoints buffering (1 to 2).</span>
<a name="l00130"></a>00130 <span class="comment"> * Default value 2.</span>
<a name="l00131"></a>00131 <span class="comment"> *</span>
<a name="l00132"></a>00132 <span class="comment"> * UHD_BULK_NB_BANK&lt;br&gt;</span>
<a name="l00133"></a>00133 <span class="comment"> * Feature to reduce or increase bulk endpoints buffering (1 to 2).</span>
<a name="l00134"></a>00134 <span class="comment"> * Default value 2.</span>
<a name="l00135"></a>00135 <span class="comment"> *</span>
<a name="l00136"></a>00136 <span class="comment"> * UHD_INTERRUPT_NB_BANK&lt;br&gt;</span>
<a name="l00137"></a>00137 <span class="comment"> * Feature to reduce or increase interrupt endpoints buffering (1 to 2).</span>
<a name="l00138"></a>00138 <span class="comment"> * Default value 1.</span>
<a name="l00139"></a>00139 <span class="comment"> *</span>
<a name="l00140"></a>00140 <span class="comment"> * \section Callbacks management</span>
<a name="l00141"></a>00141 <span class="comment"> * The USB driver is fully managed by interrupt and does not request periodic</span>
<a name="l00142"></a>00142 <span class="comment"> * task. Thereby, the USB events use callbacks to transfer the information.</span>
<a name="l00143"></a>00143 <span class="comment"> * The callbacks can be declared in static during compilation</span>
<a name="l00144"></a>00144 <span class="comment"> * or dynamically during code execution.</span>
<a name="l00145"></a>00145 <span class="comment"> *</span>
<a name="l00146"></a>00146 <span class="comment"> * \section Power mode management</span>
<a name="l00147"></a>00147 <span class="comment"> * The driver uses the sleepmgr service to manage the different sleep modes.</span>
<a name="l00148"></a>00148 <span class="comment"> * The sleep mode depends on USB driver state (uhd_uotghs_state_enum).</span>
<a name="l00149"></a>00149 <span class="comment"> * @{</span>
<a name="l00150"></a>00150 <span class="comment"> */</span>
<a name="l00151"></a>00151 
<a name="l00152"></a>00152 
<a name="l00153"></a>00153 <span class="preprocessor">#ifndef UHD_ISOCHRONOUS_NB_BANK</span>
<a name="l00154"></a>00154 <span class="preprocessor"></span><span class="preprocessor">    #define UHD_ISOCHRONOUS_NB_BANK 2</span>
<a name="l00155"></a>00155 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00156"></a>00156 <span class="preprocessor"></span><span class="preprocessor">    #if (UHD_ISOCHRONOUS_NB_BANK &lt; 1) || (UHD_ISOCHRONOUS_NB_BANK &gt; 2)</span>
<a name="l00157"></a>00157 <span class="preprocessor"></span><span class="preprocessor">        #    error UHD_ISOCHRONOUS_NB_BANK must be define with 1 or 2.</span>
<a name="l00158"></a>00158 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l00159"></a>00159 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00160"></a>00160 <span class="preprocessor"></span>
<a name="l00161"></a>00161 <span class="preprocessor">#ifndef UHD_BULK_NB_BANK</span>
<a name="l00162"></a>00162 <span class="preprocessor"></span><span class="preprocessor">    #define UHD_BULK_NB_BANK        2</span>
<a name="l00163"></a>00163 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00164"></a>00164 <span class="preprocessor"></span><span class="preprocessor">    #if (UHD_BULK_NB_BANK &lt; 1) || (UHD_BULK_NB_BANK &gt; 2)</span>
<a name="l00165"></a>00165 <span class="preprocessor"></span><span class="preprocessor">        #    error UHD_BULK_NB_BANK must be define with 1 or 2.</span>
<a name="l00166"></a>00166 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l00167"></a>00167 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00168"></a>00168 <span class="preprocessor"></span>
<a name="l00169"></a>00169 <span class="preprocessor">#ifndef UHD_INTERRUPT_NB_BANK</span>
<a name="l00170"></a>00170 <span class="preprocessor"></span><span class="preprocessor">    #define UHD_INTERRUPT_NB_BANK   1</span>
<a name="l00171"></a>00171 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00172"></a>00172 <span class="preprocessor"></span><span class="preprocessor">    #if (UHD_INTERRUPT_NB_BANK &lt; 1) || (UHD_INTERRUPT_NB_BANK &gt; 2)</span>
<a name="l00173"></a>00173 <span class="preprocessor"></span><span class="preprocessor">        #    error UHD_INTERRUPT_NB_BANK must be define with 1 or 2.</span>
<a name="l00174"></a>00174 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
<a name="l00175"></a>00175 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00176"></a>00176 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00177"></a>00177 <span class="comment">/**</span>
<a name="l00178"></a>00178 <span class="comment"> * \name Power management</span>
<a name="l00179"></a>00179 <span class="comment"> */</span><span class="comment"></span>
<a name="l00180"></a>00180 <span class="comment">//@{</span>
<a name="l00181"></a>00181 <span class="comment"></span><span class="preprocessor">#ifndef UHD_NO_SLEEP_MGR</span>
<a name="l00182"></a>00182 <span class="preprocessor"></span>
<a name="l00183"></a>00183 <span class="preprocessor">#include &quot;sleepmgr.h&quot;</span><span class="comment"></span>
<a name="l00184"></a>00184 <span class="comment">//! States of USBHS interface</span>
<a name="l00185"></a><a class="code" href="group__uhd__group.html#ga763c7a9a339aa2cb2b670d6446f37147">00185</a> <span class="comment"></span><span class="keyword">enum</span> <a class="code" href="group__uhd__group.html#ga763c7a9a339aa2cb2b670d6446f37147" title="States of USBHS interface.">uhd_uotghs_state_enum</a> {
<a name="l00186"></a>00186     UHD_STATE_OFF = 0,
<a name="l00187"></a>00187     UHD_STATE_WAIT_ID_HOST = 1,
<a name="l00188"></a>00188     UHD_STATE_NO_VBUS = 2,
<a name="l00189"></a>00189     UHD_STATE_DISCONNECT = 3,
<a name="l00190"></a>00190     UHD_STATE_SUSPEND = 4,
<a name="l00191"></a>00191     UHD_STATE_IDLE = 5,
<a name="l00192"></a>00192 };
<a name="l00193"></a>00193 <span class="comment"></span>
<a name="l00194"></a>00194 <span class="comment">/*! \brief Manages the sleep mode following the USBHS state</span>
<a name="l00195"></a>00195 <span class="comment"> *</span>
<a name="l00196"></a>00196 <span class="comment"> * \param new_state  New USBHS state</span>
<a name="l00197"></a>00197 <span class="comment"> */</span>
<a name="l00198"></a>00198 <span class="keyword">static</span> <span class="keywordtype">void</span> uhd_sleep_mode(<span class="keyword">enum</span> <a class="code" href="group__uhd__group.html#ga763c7a9a339aa2cb2b670d6446f37147" title="States of USBHS interface.">uhd_uotghs_state_enum</a> new_state)
<a name="l00199"></a>00199 {
<a name="l00200"></a>00200     <span class="keyword">enum</span> sleepmgr_mode sleep_mode[] = {
<a name="l00201"></a>00201         SLEEPMGR_BACKUP,    <span class="comment">// UHD_STATE_OFF (not used)</span>
<a name="l00202"></a>00202         SLEEPMGR_WAIT_FAST, <span class="comment">// UHD_STATE_WAIT_ID_HOST</span>
<a name="l00203"></a>00203         SLEEPMGR_SLEEP_WFI, <span class="comment">// UHD_STATE_NO_VBUS</span>
<a name="l00204"></a>00204         SLEEPMGR_SLEEP_WFI, <span class="comment">// UHD_STATE_DISCONNECT</span>
<a name="l00205"></a>00205         SLEEPMGR_WAIT_FAST, <span class="comment">// UHD_STATE_SUSPEND</span>
<a name="l00206"></a>00206         SLEEPMGR_SLEEP_WFI, <span class="comment">// UHD_STATE_IDLE</span>
<a name="l00207"></a>00207     };
<a name="l00208"></a>00208 
<a name="l00209"></a>00209     <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="group__uhd__group.html#ga763c7a9a339aa2cb2b670d6446f37147" title="States of USBHS interface.">uhd_uotghs_state_enum</a> uhd_state = UHD_STATE_OFF;
<a name="l00210"></a>00210 
<a name="l00211"></a>00211     <span class="keywordflow">if</span> (uhd_state == new_state) {
<a name="l00212"></a>00212         <span class="keywordflow">return</span>; <span class="comment">// No change</span>
<a name="l00213"></a>00213     }
<a name="l00214"></a>00214 
<a name="l00215"></a>00215     <span class="keywordflow">if</span> (new_state != UHD_STATE_OFF) {
<a name="l00216"></a>00216         <span class="comment">// Lock new limit</span>
<a name="l00217"></a>00217         sleepmgr_lock_mode(sleep_mode[new_state]);
<a name="l00218"></a>00218     }
<a name="l00219"></a>00219 
<a name="l00220"></a>00220     <span class="keywordflow">if</span> (uhd_state != UHD_STATE_OFF) {
<a name="l00221"></a>00221         <span class="comment">// Unlock old limit</span>
<a name="l00222"></a>00222         sleepmgr_unlock_mode(sleep_mode[uhd_state]);
<a name="l00223"></a>00223     }
<a name="l00224"></a>00224 
<a name="l00225"></a>00225     uhd_state = new_state;
<a name="l00226"></a>00226 }
<a name="l00227"></a>00227 
<a name="l00228"></a>00228 <span class="preprocessor">#else</span>
<a name="l00229"></a>00229 <span class="preprocessor"></span><span class="preprocessor">#  define uhd_sleep_mode(arg)</span>
<a name="l00230"></a>00230 <span class="preprocessor"></span><span class="preprocessor">#endif // UHD_NO_SLEEP_MGR</span>
<a name="l00231"></a>00231 <span class="preprocessor"></span><span class="comment">//@}</span>
<a name="l00232"></a>00232 <span class="comment"></span>
<a name="l00233"></a>00233 <span class="comment"></span>
<a name="l00234"></a>00234 <span class="comment">//! Store the callback to be call at the end of reset signal</span>
<a name="l00235"></a>00235 <span class="comment"></span><span class="keyword">static</span> <a class="code" href="group__uhd__group.html#ga305e97eac8bfb0052c9efbfc6d070c60" title="End of reset callback function type. Registered by uhd_send_reset() Callback called when reset event ...">uhd_callback_reset_t</a> uhd_reset_callback = NULL;
<a name="l00236"></a>00236 <span class="comment"></span>
<a name="l00237"></a>00237 <span class="comment">/**</span>
<a name="l00238"></a>00238 <span class="comment"> * \name Control endpoint low level management routine.</span>
<a name="l00239"></a>00239 <span class="comment"> *</span>
<a name="l00240"></a>00240 <span class="comment"> * This function performs control endpoint management.</span>
<a name="l00241"></a>00241 <span class="comment"> * It handles the SETUP/DATA/HANDSHAKE phases of a control transaction.</span>
<a name="l00242"></a>00242 <span class="comment"> */</span><span class="comment"></span>
<a name="l00243"></a>00243 <span class="comment">//@{</span>
<a name="l00244"></a>00244 <span class="comment"></span><span class="comment"></span>
<a name="l00245"></a>00245 <span class="comment">/**</span>
<a name="l00246"></a>00246 <span class="comment"> * \brief Structure to store the high level setup request</span>
<a name="l00247"></a>00247 <span class="comment"> */</span>
<a name="l00248"></a>00248 
<a name="l00249"></a><a class="code" href="structuhd__ctrl__request__t.html">00249</a> <span class="keyword">struct </span><a class="code" href="structuhd__ctrl__request__t.html" title="Structure to store the high level setup request.">uhd_ctrl_request_t</a> {<span class="comment"></span>
<a name="l00250"></a>00250 <span class="comment">    //! Next setup request to process</span>
<a name="l00251"></a><a class="code" href="structuhd__ctrl__request__t.html#a158d16ea2e48d975b22443a9a4bc20e2">00251</a> <span class="comment"></span>    <span class="keyword">struct </span><a class="code" href="structuhd__ctrl__request__t.html" title="Structure to store the high level setup request.">uhd_ctrl_request_t</a> *<a class="code" href="structuhd__ctrl__request__t.html#a158d16ea2e48d975b22443a9a4bc20e2" title="Next setup request to process.">next_request</a>;
<a name="l00252"></a>00252 <span class="comment"></span>
<a name="l00253"></a>00253 <span class="comment">    //! Callback called when buffer is empty or full</span>
<a name="l00254"></a><a class="code" href="structuhd__ctrl__request__t.html#aab515926dcc24785d888351fb22b4952">00254</a> <span class="comment"></span>    <a class="code" href="group__uhd__group.html#ga96bf6cc1dfc70e9ef06e54f7aa0cd02a" title="Data setup transfer callback function type. Registered by USBH_HAL_SetupReq() Called during DATA phas...">uhd_callback_setup_run_t</a> <a class="code" href="structuhd__ctrl__request__t.html#aab515926dcc24785d888351fb22b4952" title="Callback called when buffer is empty or full.">callback_run</a>;<span class="comment"></span>
<a name="l00255"></a>00255 <span class="comment">    //! Callback called when request is completed</span>
<a name="l00256"></a><a class="code" href="structuhd__ctrl__request__t.html#a499487997bb0cccd2194fcdf0504386f">00256</a> <span class="comment"></span>    <a class="code" href="group__uhd__group.html#ga48eac59f68de74c0ce604429cb46510e" title="End of setup callback function type. Registered by USBH_HAL_SetupReq() Called when the setup request ...">uhd_callback_setup_end_t</a> <a class="code" href="structuhd__ctrl__request__t.html#a499487997bb0cccd2194fcdf0504386f" title="Callback called when request is completed.">callback_end</a>;
<a name="l00257"></a>00257 <span class="comment"></span>
<a name="l00258"></a>00258 <span class="comment">    //! Buffer to store the setup DATA phase</span>
<a name="l00259"></a><a class="code" href="structuhd__ctrl__request__t.html#a44aa00d0c9a6f68f208329f0fbbbf214">00259</a> <span class="comment"></span>    uint8_t *<a class="code" href="structuhd__ctrl__request__t.html#a44aa00d0c9a6f68f208329f0fbbbf214" title="Buffer to store the setup DATA phase.">payload</a>;
<a name="l00260"></a>00260 <span class="comment"></span>
<a name="l00261"></a>00261 <span class="comment">    //! USB address of control endpoint</span>
<a name="l00262"></a><a class="code" href="structuhd__ctrl__request__t.html#a4172d80c6e98235ed2d65a16513e3640">00262</a> <span class="comment"></span>    uint8_t <a class="code" href="structuhd__ctrl__request__t.html#a4172d80c6e98235ed2d65a16513e3640" title="USB address of control endpoint.">add</a>;
<a name="l00263"></a>00263 <span class="comment"></span>
<a name="l00264"></a>00264 <span class="comment">    //! Setup request definition</span>
<a name="l00265"></a><a class="code" href="structuhd__ctrl__request__t.html#af533979e39a8f0059a84a9024168faf1">00265</a> <span class="comment"></span>    <a class="code" href="struct_u_s_b_generic_request.html">USBGenericRequest</a> <a class="code" href="structuhd__ctrl__request__t.html#af533979e39a8f0059a84a9024168faf1" title="Setup request definition.">req</a>;
<a name="l00266"></a>00266 <span class="comment"></span>
<a name="l00267"></a>00267 <span class="comment">    //! Size of buffer used in DATA phase</span>
<a name="l00268"></a><a class="code" href="structuhd__ctrl__request__t.html#aab546d1e52187d029085b16b03b2c197">00268</a> <span class="comment"></span>    uint16_t <a class="code" href="structuhd__ctrl__request__t.html#aab546d1e52187d029085b16b03b2c197" title="Size of buffer used in DATA phase.">payload_size</a>;
<a name="l00269"></a>00269 };
<a name="l00270"></a>00270 <span class="comment"></span>
<a name="l00271"></a>00271 <span class="comment">//! Entry points of setup request list</span>
<a name="l00272"></a><a class="code" href="group__uhd__group.html#gad2628647770aba23602cd668c75f30cd">00272</a> <span class="comment"></span><span class="keyword">struct </span><a class="code" href="structuhd__ctrl__request__t.html" title="Structure to store the high level setup request.">uhd_ctrl_request_t</a> *<a class="code" href="group__uhd__group.html#gad2628647770aba23602cd668c75f30cd" title="Entry points of setup request list.">uhd_ctrl_request_first</a>;
<a name="l00273"></a>00273 <span class="keyword">struct </span><a class="code" href="structuhd__ctrl__request__t.html" title="Structure to store the high level setup request.">uhd_ctrl_request_t</a> *uhd_ctrl_request_last;
<a name="l00274"></a>00274 <span class="comment"></span>
<a name="l00275"></a>00275 <span class="comment">//! Remaining time for on-going setup request (No request on-going if equal 0)</span>
<a name="l00276"></a><a class="code" href="group__uhd__group.html#ga49ee25dd706f7dedc0598ba7f5575353">00276</a> <span class="comment"></span><span class="keyword">volatile</span> uint16_t <a class="code" href="group__uhd__group.html#ga49ee25dd706f7dedc0598ba7f5575353" title="Remaining time for on-going setup request (No request on-going if equal 0).">uhd_ctrl_request_timeout</a>;
<a name="l00277"></a>00277 <span class="comment"></span>
<a name="l00278"></a>00278 <span class="comment">//! Number of transfered byte on DATA phase of current setup request</span>
<a name="l00279"></a><a class="code" href="group__uhd__group.html#ga213de2c8a6616c71912577930df2fff0">00279</a> <span class="comment"></span>uint16_t <a class="code" href="group__uhd__group.html#ga213de2c8a6616c71912577930df2fff0" title="Number of transfered byte on DATA phase of current setup request.">uhd_ctrl_nb_trans</a>;
<a name="l00280"></a>00280 <span class="comment"></span>
<a name="l00281"></a>00281 <span class="comment">//! Flag to delay a suspend request after all on-going setup request</span>
<a name="l00282"></a>00282 <span class="comment"></span><span class="keyword">static</span> <span class="keywordtype">bool</span> uhd_b_suspend_requested;
<a name="l00283"></a>00283 <span class="comment"></span>
<a name="l00284"></a>00284 <span class="comment">//! Bit definitions to store setup request state machine</span>
<a name="l00285"></a><a class="code" href="group__uhd__group.html#gab5c14d3e2e40e55761ffe45496ae5427">00285</a> <span class="comment"></span><span class="keyword">typedef</span> <span class="keyword">enum</span> {<span class="comment"></span>
<a name="l00286"></a>00286 <span class="comment">    //! Wait a SETUP packet</span>
<a name="l00287"></a><a class="code" href="group__uhd__group.html#ggab5c14d3e2e40e55761ffe45496ae5427a4d58c9d6d4a100fafb7a2c99304ef274">00287</a> <span class="comment"></span>    <a class="code" href="group__uhd__group.html#ggab5c14d3e2e40e55761ffe45496ae5427a4d58c9d6d4a100fafb7a2c99304ef274" title="Wait a SETUP packet.">UHD_CTRL_REQ_PHASE_SETUP</a> = 0,<span class="comment"></span>
<a name="l00288"></a>00288 <span class="comment">    //! Wait a OUT data packet</span>
<a name="l00289"></a><a class="code" href="group__uhd__group.html#ggab5c14d3e2e40e55761ffe45496ae5427aab15b28a6a920b07a0cc82de1d0c414a">00289</a> <span class="comment"></span>    <a class="code" href="group__uhd__group.html#ggab5c14d3e2e40e55761ffe45496ae5427aab15b28a6a920b07a0cc82de1d0c414a" title="Wait a OUT data packet.">UHD_CTRL_REQ_PHASE_DATA_OUT</a> = 1,<span class="comment"></span>
<a name="l00290"></a>00290 <span class="comment">    //! Wait a IN data packet</span>
<a name="l00291"></a><a class="code" href="group__uhd__group.html#ggab5c14d3e2e40e55761ffe45496ae5427adad9d075f8a169516efd6b29961612a5">00291</a> <span class="comment"></span>    <a class="code" href="group__uhd__group.html#ggab5c14d3e2e40e55761ffe45496ae5427adad9d075f8a169516efd6b29961612a5" title="Wait a IN data packet.">UHD_CTRL_REQ_PHASE_DATA_IN</a> = 2,<span class="comment"></span>
<a name="l00292"></a>00292 <span class="comment">    //! Wait a IN ZLP packet</span>
<a name="l00293"></a><a class="code" href="group__uhd__group.html#ggab5c14d3e2e40e55761ffe45496ae5427acb0a9b7a084121f4ff48cd53ad76842a">00293</a> <span class="comment"></span>    <a class="code" href="group__uhd__group.html#ggab5c14d3e2e40e55761ffe45496ae5427acb0a9b7a084121f4ff48cd53ad76842a" title="Wait a IN ZLP packet.">UHD_CTRL_REQ_PHASE_ZLP_IN</a> = 3,<span class="comment"></span>
<a name="l00294"></a>00294 <span class="comment">    //! Wait a OUT ZLP packet</span>
<a name="l00295"></a><a class="code" href="group__uhd__group.html#ggab5c14d3e2e40e55761ffe45496ae5427a62b5126d713b2ed56894a6899fda885e">00295</a> <span class="comment"></span>    <a class="code" href="group__uhd__group.html#ggab5c14d3e2e40e55761ffe45496ae5427a62b5126d713b2ed56894a6899fda885e" title="Wait a OUT ZLP packet.">UHD_CTRL_REQ_PHASE_ZLP_OUT</a> = 4,
<a name="l00296"></a>00296 } uhd_ctrl_request_phase_t;
<a name="l00297"></a>00297 <a class="code" href="group__uhd__group.html#gab5c14d3e2e40e55761ffe45496ae5427" title="Bit definitions to store setup request state machine.">uhd_ctrl_request_phase_t</a> uhd_ctrl_request_phase;
<a name="l00298"></a>00298 <span class="comment"></span>
<a name="l00299"></a>00299 <span class="comment">//@}</span>
<a name="l00300"></a>00300 <span class="comment"></span>
<a name="l00301"></a>00301 <span class="comment"></span>
<a name="l00302"></a>00302 <span class="comment">/**</span>
<a name="l00303"></a>00303 <span class="comment"> * \name Management of bulk/interrupt/isochronous endpoints</span>
<a name="l00304"></a>00304 <span class="comment"> *</span>
<a name="l00305"></a>00305 <span class="comment"> * The UHD manages the data transfer on endpoints:</span>
<a name="l00306"></a>00306 <span class="comment"> * - Start data transfer on endpoint with USB DMA</span>
<a name="l00307"></a>00307 <span class="comment"> * - Send a ZLP packet if requested</span>
<a name="l00308"></a>00308 <span class="comment"> * - Call registered callback to signal end of transfer</span>
<a name="l00309"></a>00309 <span class="comment"> * The transfer abort and stall feature are supported.</span>
<a name="l00310"></a>00310 <span class="comment"> */</span><span class="comment"></span>
<a name="l00311"></a>00311 <span class="comment">//@{</span>
<a name="l00312"></a>00312 <span class="comment"></span><span class="comment"></span>
<a name="l00313"></a>00313 <span class="comment">//! Structure definition to store registered jobs on a pipe</span>
<a name="l00314"></a><a class="code" href="struct_u_s_b_h___pipe_job__t.html">00314</a> <span class="comment"></span><span class="keyword">typedef</span> <span class="keyword">struct </span>{<span class="comment"></span>
<a name="l00315"></a>00315 <span class="comment">    //! Callback to call at the end of transfer</span>
<a name="l00316"></a><a class="code" href="struct_u_s_b_h___pipe_job__t.html#ac42e3e3067edeba6bbb5831de8270f06">00316</a> <span class="comment"></span>    <a class="code" href="group__uhd__group.html#ga750fe064c082c913ac202fe1641648d3" title="End of transfer callback function type. Registered by USBH_HAL_RunEndpoint() Callback called by USB i...">uhd_callback_trans_t</a> call_end;
<a name="l00317"></a>00317 <span class="comment"></span>
<a name="l00318"></a>00318 <span class="comment">    //! Buffer located in internal RAM to send or fill during job</span>
<a name="l00319"></a><a class="code" href="struct_u_s_b_h___pipe_job__t.html#aecfd98dfe2e19e4fc0e92fa30fee7b2e">00319</a> <span class="comment"></span>    uint8_t *buf;<span class="comment"></span>
<a name="l00320"></a>00320 <span class="comment">    //! Size of buffer to send or fill</span>
<a name="l00321"></a><a class="code" href="struct_u_s_b_h___pipe_job__t.html#a9f7a2c3bfe2d805a5328dae0dd3d6648">00321</a> <span class="comment"></span>    uint32_t buf_size;<span class="comment"></span>
<a name="l00322"></a>00322 <span class="comment">    //! Total number of transfered data on endpoint</span>
<a name="l00323"></a><a class="code" href="struct_u_s_b_h___pipe_job__t.html#afd8c90263aef338ab94344013a0c8162">00323</a> <span class="comment"></span>    uint32_t nb_trans;
<a name="l00324"></a>00324 <span class="comment"></span>
<a name="l00325"></a>00325 <span class="comment">    //! timeout on this request (ms)</span>
<a name="l00326"></a><a class="code" href="struct_u_s_b_h___pipe_job__t.html#a47c387e93b181e39d8f84bf6c7b8a016">00326</a> <span class="comment"></span>    uint16_t timeout;<span class="comment"></span>
<a name="l00327"></a>00327 <span class="comment">    //! A job is registered on this pipe</span>
<a name="l00328"></a><a class="code" href="struct_u_s_b_h___pipe_job__t.html#a07b75fbf986996a3382967085a7362d0">00328</a> <span class="comment"></span>    uint16_t busy: 1;<span class="comment"></span>
<a name="l00329"></a>00329 <span class="comment">    //! A short packet is requested for this job on endpoint IN</span>
<a name="l00330"></a><a class="code" href="struct_u_s_b_h___pipe_job__t.html#a21a69dca8be71be6f87e4809f4c83922">00330</a> <span class="comment"></span>    uint16_t b_shortpacket: 1;<span class="comment"></span>
<a name="l00331"></a>00331 <span class="comment">    //! Periodic packet start for this job</span>
<a name="l00332"></a><a class="code" href="struct_u_s_b_h___pipe_job__t.html#a9c7642dff284877f8ebc741157c376e0">00332</a> <span class="comment"></span>    uint16_t b_periodic_start: 1;
<a name="l00333"></a>00333 } <a class="code" href="struct_u_s_b_h___pipe_job__t.html" title="Structure definition to store registered jobs on a pipe.">USBH_PipeJob_t</a>;
<a name="l00334"></a>00334 <span class="comment"></span>
<a name="l00335"></a>00335 <span class="comment">//! Array to register a job on bulk/interrupt/isochronous endpoint</span>
<a name="l00336"></a>00336 <span class="comment"></span><span class="keyword">static</span> <a class="code" href="struct_u_s_b_h___pipe_job__t.html" title="Structure definition to store registered jobs on a pipe.">USBH_PipeJob_t</a> uhd_pipe_job[USBHS_EPT_NUM - 1];
<a name="l00337"></a>00337 <span class="comment"></span>
<a name="l00338"></a>00338 <span class="comment">//! Variables to manage the suspend/resume sequence</span>
<a name="l00339"></a>00339 <span class="comment"></span><span class="keyword">static</span> uint8_t uhd_suspend_start;
<a name="l00340"></a>00340 <span class="keyword">static</span> uint8_t uhd_resume_start;
<a name="l00341"></a>00341 <span class="keyword">static</span> uint16_t uhd_pipes_unfreeze;
<a name="l00342"></a>00342 <span class="comment"></span>
<a name="l00343"></a>00343 <span class="comment">//@}</span>
<a name="l00344"></a>00344 <span class="comment"></span><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="struct_pin.html">Pin</a> USB_HOST[] = {PINS_VBUS_EN};
<a name="l00345"></a>00345 
<a name="l00346"></a>00346 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_ManageSof(<span class="keywordtype">void</span>);
<a name="l00347"></a>00347 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_ControlInterrupt(<span class="keywordtype">void</span>);
<a name="l00348"></a>00348 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_PhaseControlSetup(<span class="keywordtype">void</span>);
<a name="l00349"></a>00349 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_PhaseDataInStart(<span class="keywordtype">void</span>);
<a name="l00350"></a>00350 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_PhaseDataIn(<span class="keywordtype">void</span>);
<a name="l00351"></a>00351 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_InZLP(<span class="keywordtype">void</span>);
<a name="l00352"></a>00352 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_PhaseDataOut(<span class="keywordtype">void</span>);
<a name="l00353"></a>00353 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_OutZLP(<span class="keywordtype">void</span>);
<a name="l00354"></a>00354 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_ControlReqEnd(<a class="code" href="group__uhd__group.html#ga19c67cc9d097b54049dbc7c12119eb83" title="Endpoint transfer status The status field is updated after each transaction attempt, whether successful or not.">USBH_XfrStatus_t</a> status);
<a name="l00355"></a>00355 <span class="keyword">static</span> <a class="code" href="group__uhd__group.html#ga19c67cc9d097b54049dbc7c12119eb83" title="Endpoint transfer status The status field is updated after each transaction attempt, whether successful or not.">USBH_XfrStatus_t</a> USBH_HAL_GetPipeError(uint8_t pipe);
<a name="l00356"></a>00356 <span class="keyword">static</span> uint8_t USBH_HAL_GetPipe(uint8_t Addr, uint8_t bEndpoint);
<a name="l00357"></a>00357 
<a name="l00358"></a>00358 <span class="preprocessor">#ifdef UHD_PIPE_FIFO_SUPPORTED</span>
<a name="l00359"></a>00359 <span class="preprocessor"></span>    <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_PipeOutReady(uint8_t pipe);
<a name="l00360"></a>00360     <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_PipeInReceived(uint8_t pipe);
<a name="l00361"></a>00361 <span class="preprocessor">#endif</span>
<a name="l00362"></a>00362 <span class="preprocessor"></span><span class="preprocessor">#ifdef UHD_PIPE_DMA_SUPPORTED</span>
<a name="l00363"></a>00363 <span class="preprocessor"></span>    <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_PipeXfrCmplt(uint8_t pipe);
<a name="l00364"></a>00364     <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_PipeDmaInterrupt(uint8_t pipe);
<a name="l00365"></a>00365 <span class="preprocessor">#endif</span>
<a name="l00366"></a>00366 <span class="preprocessor"></span>
<a name="l00367"></a>00367 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_PipeInterrupt(uint8_t pipe);
<a name="l00368"></a>00368 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_PipeAbort(uint8_t pipe, <a class="code" href="group__uhd__group.html#ga19c67cc9d097b54049dbc7c12119eb83" title="Endpoint transfer status The status field is updated after each transaction attempt, whether successful or not.">USBH_XfrStatus_t</a> status);
<a name="l00369"></a>00369 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_PipeXfrEnd(uint8_t pipe, <a class="code" href="group__uhd__group.html#ga19c67cc9d097b54049dbc7c12119eb83" title="Endpoint transfer status The status field is updated after each transaction attempt, whether successful or not.">USBH_XfrStatus_t</a> status);
<a name="l00370"></a>00370 
<a name="l00371"></a>00371 
<a name="l00372"></a>00372 <span class="comment">//--------------------------------------------------------</span>
<a name="l00373"></a>00373 <span class="comment">//--- INTERNAL ROUTINES TO MANAGED GLOBAL EVENTS</span>
<a name="l00374"></a>00374 <span class="comment"></span>
<a name="l00375"></a>00375 <span class="comment">/**</span>
<a name="l00376"></a>00376 <span class="comment"> * \internal</span>
<a name="l00377"></a>00377 <span class="comment"> * \brief Function called by USBHS interrupt handler to manage USB interrupts</span>
<a name="l00378"></a>00378 <span class="comment"> *</span>
<a name="l00379"></a>00379 <span class="comment"> * USB host interrupt events are split into four sections:</span>
<a name="l00380"></a>00380 <span class="comment"> * - USB line events</span>
<a name="l00381"></a>00381 <span class="comment"> *   (VBus error, device dis/connection, SOF, reset, suspend, resume, wakeup)</span>
<a name="l00382"></a>00382 <span class="comment"> * - control endpoint events</span>
<a name="l00383"></a>00383 <span class="comment"> *   (setup reception, end of data transfer, underflow, overflow, stall, error)</span>
<a name="l00384"></a>00384 <span class="comment"> * - bulk/interrupt/isochronous endpoints events</span>
<a name="l00385"></a>00385 <span class="comment"> *   (end of data transfer, stall, error)</span>
<a name="l00386"></a>00386 <span class="comment"> *</span>
<a name="l00387"></a>00387 <span class="comment"> * Note:</span>
<a name="l00388"></a>00388 <span class="comment"> * Here, the global interrupt mask is not cleared when an USB interrupt</span>
<a name="l00389"></a>00389 <span class="comment"> * is enabled because this one can not occurred during the USB ISR</span>
<a name="l00390"></a>00390 <span class="comment"> * (=during INTX is masked).</span>
<a name="l00391"></a>00391 <span class="comment"> * See Technical reference $3.8.3 Masking interrupt requests</span>
<a name="l00392"></a>00392 <span class="comment"> * in peripheral modules.</span>
<a name="l00393"></a>00393 <span class="comment"> */</span>
<a name="l00394"></a><a class="code" href="group__uhd__group.html#gafcd12a00544aac7645deb694ec611e7a">00394</a> <span class="keywordtype">void</span> <a class="code" href="group___s_a_m_e70_j19__cmsis.html#gafcd12a00544aac7645deb694ec611e7a">USBHS_Handler</a>(<span class="keywordtype">void</span>)
<a name="l00395"></a>00395 {
<a name="l00396"></a>00396     uint8_t pipe_int, pipe_dma_int;
<a name="l00397"></a>00397     uint32_t status = <a class="code" href="usbhs_8h.html#a40267eb93445cc78fe9b243d25622f9c" title="Gets USB host interrupt status.">USBHS_GetHostStatus</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0xFF);
<a name="l00398"></a>00398     uint32_t statusInt = ( status &amp; <a class="code" href="usbhs_8h.html#a6e707992fde3a408663eae6e34b00deb" title="Gets USB host interrupt status.">USBHS_IsHostIntEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0xFF));
<a name="l00399"></a>00399 
<a name="l00400"></a>00400     memory_sync();
<a name="l00401"></a>00401     <a class="code" href="trace_8h.html#a67a8f9bc74358aa21745a76e23768dae">TRACE_DEBUG</a>(<span class="stringliteral">&quot;%c &quot;</span>, <a class="code" href="usbhs_8h.html#a017b00c66ba92abe86f341381e3795ee" title="Enable or disable USB address.">USBHS_IsUsbLowSpeed</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>) ? <span class="charliteral">&#39;L&#39;</span> :
<a name="l00402"></a>00402                 (<a class="code" href="usbhs_8h.html#a3a003f0bc5f5ed08ba3253028bd04923" title="Enable or disable USB address.">USBHS_IsUsbHighSpeed</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>) ? <span class="charliteral">&#39;H&#39;</span> : <span class="charliteral">&#39;F&#39;</span>));
<a name="l00403"></a>00403 
<a name="l00404"></a>00404     <span class="keywordflow">if</span> (<a class="code" href="usbhs_8h.html#a017b00c66ba92abe86f341381e3795ee" title="Enable or disable USB address.">USBHS_IsUsbLowSpeed</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>)
<a name="l00405"></a>00405         &amp;&amp; (!(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>-&gt;USBHS_HSTCTRL &amp; <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gac7ec7fd901405a233ec5fc86a4c8cf33" title="(USBHS_HSTCTRL) Mode Configuration">USBHS_HSTCTRL_SPDCONF_Msk</a>)))
<a name="l00406"></a>00406         <a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>-&gt;USBHS_HSTCTRL |= USBHS_HSTCTRL_SPDCONF_LOW_POWER;
<a name="l00407"></a>00407 
<a name="l00408"></a>00408     <span class="comment">// Manage SOF interrupt</span>
<a name="l00409"></a>00409     <span class="keywordflow">if</span> (status &amp; <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga2e72394c9c97ef664be053cbd2c76bc5" title="(USBHS_HSTISR) Host Start of Frame Interrupt">USBHS_HSTISR_HSOFI</a>) {
<a name="l00410"></a>00410         <span class="comment">//Acknowledge SOF</span>
<a name="l00411"></a>00411         <a class="code" href="usbhs_8h.html#aab0688b661054b73b5c9fe45e59ea015" title="Gets USB host interrupt status.">USBHS_ClearHostStatus</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gaa6df5ae7bc42d5c5a48f7780451ccd57" title="(USBHS_HSTICR) Host Start of Frame Interrupt Clear">USBHS_HSTICR_HSOFIC</a>);
<a name="l00412"></a>00412         USBH_HAL_ManageSof();
<a name="l00413"></a>00413     } <span class="keywordflow">else</span> {
<a name="l00414"></a>00414         pipe_int = USBHS_GetInterruptPipeNum();
<a name="l00415"></a>00415         pipe_dma_int = USBHS_GetInterruptPipeDmaNum();
<a name="l00416"></a>00416 
<a name="l00417"></a>00417         <span class="keywordflow">if</span> (pipe_int == 0) {
<a name="l00418"></a>00418             <a class="code" href="trace_8h.html#a67a8f9bc74358aa21745a76e23768dae">TRACE_DEBUG</a>(<span class="stringliteral">&quot;Pipe0: &quot;</span>);
<a name="l00419"></a>00419             <span class="comment">// Interrupt acked by control endpoint managed</span>
<a name="l00420"></a>00420             USBH_HAL_ControlInterrupt();
<a name="l00421"></a>00421         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pipe_int != USBHS_EPT_NUM) {
<a name="l00422"></a>00422             <a class="code" href="trace_8h.html#a67a8f9bc74358aa21745a76e23768dae">TRACE_DEBUG</a>(<span class="stringliteral">&quot;Pipe%x: &quot;</span>, pipe_int);
<a name="l00423"></a>00423             <span class="comment">// Interrupt acked by bulk/interrupt/isochronous endpoint</span>
<a name="l00424"></a>00424             USBH_HAL_PipeInterrupt(pipe_int);
<a name="l00425"></a>00425         }
<a name="l00426"></a>00426 
<a name="l00427"></a>00427 <span class="preprocessor">#ifdef UHD_PIPE_DMA_SUPPORTED</span>
<a name="l00428"></a>00428 <span class="preprocessor"></span>        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pipe_dma_int != USBHS_EPT_NUM) {
<a name="l00429"></a>00429             <a class="code" href="trace_8h.html#a67a8f9bc74358aa21745a76e23768dae">TRACE_DEBUG</a>(<span class="stringliteral">&quot;Pipe%x &quot;</span>, pipe_dma_int);
<a name="l00430"></a>00430             <span class="comment">// Interrupt DMA acked by bulk/interrupt/isochronous endpoint</span>
<a name="l00431"></a>00431             USBH_HAL_PipeDmaInterrupt(pipe_dma_int);
<a name="l00432"></a>00432         }
<a name="l00433"></a>00433 
<a name="l00434"></a>00434 <span class="preprocessor">#endif</span>
<a name="l00435"></a>00435 <span class="preprocessor"></span>        <span class="comment">// USB bus reset detection</span>
<a name="l00436"></a>00436         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (status &amp; <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gaf84113b919c558bfeb00a82f0b34ceaa" title="(USBHS_HSTISR) USB Reset Sent Interrupt">USBHS_HSTISR_RSTI</a>) {
<a name="l00437"></a>00437             TRACE_INFO_WP(<span class="stringliteral">&quot;RST &quot;</span>);
<a name="l00438"></a>00438             <a class="code" href="usbhs_8h.html#aab0688b661054b73b5c9fe45e59ea015" title="Gets USB host interrupt status.">USBHS_ClearHostStatus</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga84df2c9bc871c6336be81958fe823f08" title="(USBHS_HSTICR) USB Reset Sent Interrupt Clear">USBHS_HSTICR_RSTIC</a>);
<a name="l00439"></a>00439 
<a name="l00440"></a>00440             <span class="keywordflow">if</span> (uhd_reset_callback != NULL)
<a name="l00441"></a>00441                 uhd_reset_callback();
<a name="l00442"></a>00442         }
<a name="l00443"></a>00443 
<a name="l00444"></a>00444         <span class="comment">// Check USB clock ready after asynchronous interrupt</span>
<a name="l00445"></a>00445 
<a name="l00446"></a>00446         <span class="comment">// Manage dis/connection event</span>
<a name="l00447"></a>00447         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (statusInt &amp; <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gab3e7bad35dd2abc7543891f740c405ca" title="(USBHS_HSTIMR) Device Disconnection Interrupt Enable">USBHS_HSTIMR_DDISCIE</a>) {
<a name="l00448"></a>00448             <a class="code" href="usbhs_8h.html#aab0688b661054b73b5c9fe45e59ea015" title="Gets USB host interrupt status.">USBHS_ClearHostStatus</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga23995ee5d7ddabec341170ca98b6d624" title="(USBHS_HSTICR) Device Disconnection Interrupt Clear">USBHS_HSTICR_DDISCIC</a>);
<a name="l00449"></a>00449             <a class="code" href="usbhs_8h.html#aa9a5b060519f982e8cd29dc32754b5a9" title="Gets USB host interrupt status.">USBHS_HostIntDisable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gae7c9ec90aa2f4d31dcf59aa75706904b" title="(USBHS_HSTIDR) Device Disconnection Interrupt Disable">USBHS_HSTIDR_DDISCIEC</a>);
<a name="l00450"></a>00450             TRACE_INFO(<span class="stringliteral">&quot;Disconnect--\n\r&quot;</span>);
<a name="l00451"></a>00451             <span class="comment">// Stop reset signal, in case of disconnection during reset</span>
<a name="l00452"></a>00452             <a class="code" href="usbhs_8h.html#aac479594b09aba35a095529855449a42" title="Sets USB host sends reste signal on USB Bus.">USBHS_StopReset</a>();
<a name="l00453"></a>00453             <span class="comment">// Disable wakeup/resumes interrupts,</span>
<a name="l00454"></a>00454             <span class="comment">// in case of disconnection during suspend mode</span>
<a name="l00455"></a>00455             <a class="code" href="usbhs_8h.html#aa9a5b060519f982e8cd29dc32754b5a9" title="Gets USB host interrupt status.">USBHS_HostIntDisable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gad76e639effe266e8ea166bc9c5faf889" title="(USBHS_HSTIDR) Host Wake-Up Interrupt Disable">USBHS_HSTIDR_HWUPIEC</a>
<a name="l00456"></a>00456                                          | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga7c699747f489cbb80ea42c95a9d6a8d0" title="(USBHS_HSTIDR) Downstream Resume Sent Interrupt Disable">USBHS_HSTIDR_RSMEDIEC</a>
<a name="l00457"></a>00457                                          | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gae0e07a0dbd66d3c04b103b99476029d1" title="(USBHS_HSTIDR) Upstream Resume Received Interrupt Disable">USBHS_HSTIDR_RXRSMIEC</a>));
<a name="l00458"></a>00458             uhd_sleep_mode(UHD_STATE_DISCONNECT);
<a name="l00459"></a>00459             <a class="code" href="usbhs_8h.html#aab0688b661054b73b5c9fe45e59ea015" title="Gets USB host interrupt status.">USBHS_ClearHostStatus</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga0fb7643d5be82c2ea2172850b38484e2" title="(USBHS_HSTICR) Device Connection Interrupt Clear">USBHS_HSTICR_DCONNIC</a>);
<a name="l00460"></a>00460             <a class="code" href="usbhs_8h.html#a7ac646519dfb6c319d8a60f08b5e4c29" title="Gets USB host interrupt status.">USBHS_HostIntEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga09be10f559e69bb67edafc93a6585788" title="(USBHS_HSTIER) Device Connection Interrupt Enable">USBHS_HSTIER_DCONNIES</a>);
<a name="l00461"></a>00461             <a class="code" href="usbhs_8h.html#aab0688b661054b73b5c9fe45e59ea015" title="Gets USB host interrupt status.">USBHS_ClearHostStatus</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga63908e82e8d8280a53314644efcda9ba" title="(USBHS_HSTICR) Host Wake-Up Interrupt Clear">USBHS_HSTICR_HWUPIC</a>);
<a name="l00462"></a>00462             <a class="code" href="usbhs_8h.html#a7ac646519dfb6c319d8a60f08b5e4c29" title="Gets USB host interrupt status.">USBHS_HostIntEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga3da0cf2e0f5a86423269e347cb1430f8" title="(USBHS_HSTIER) Host Wake-Up Interrupt Enable">USBHS_HSTIER_HWUPIES</a>);
<a name="l00463"></a>00463 <span class="preprocessor">#ifdef USB_HOST_HS_SUPPORT</span>
<a name="l00464"></a>00464 <span class="preprocessor"></span>            <a class="code" href="usbhs_8h.html#af5209f422709bb346dd8906a84594481" title="Sets USB host&amp;#39;s speed to Normal , it sets to HS from FS.">USBHS_SetHostHighSpeed</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>);
<a name="l00465"></a>00465 <span class="preprocessor">#endif</span>
<a name="l00466"></a>00466 <span class="preprocessor"></span>            <span class="comment">//otg_freeze_clock();</span>
<a name="l00467"></a>00467             uhd_suspend_start = 0;
<a name="l00468"></a>00468             uhd_resume_start = 0;
<a name="l00469"></a>00469             <a class="code" href="group___u_s_b_h__group__interne.html#ga78a0073e6ae8ed58cc6a28ea89820ef1" title="Notify device connection or disconnection.">USBH_notify_connection</a>(<span class="keyword">false</span>);
<a name="l00470"></a>00470         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (statusInt &amp; <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga9e4f9a2f8424866113c488a83f3fe511" title="(USBHS_HSTIMR) Device Connection Interrupt Enable">USBHS_HSTIMR_DCONNIE</a>) {
<a name="l00471"></a>00471             TRACE_INFO(<span class="stringliteral">&quot;Connect-- &quot;</span>);
<a name="l00472"></a>00472             <a class="code" href="usbhs_8h.html#aab0688b661054b73b5c9fe45e59ea015" title="Gets USB host interrupt status.">USBHS_ClearHostStatus</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga0fb7643d5be82c2ea2172850b38484e2" title="(USBHS_HSTICR) Device Connection Interrupt Clear">USBHS_HSTICR_DCONNIC</a>);
<a name="l00473"></a>00473             <a class="code" href="usbhs_8h.html#aa9a5b060519f982e8cd29dc32754b5a9" title="Gets USB host interrupt status.">USBHS_HostIntDisable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gae12d73aff52d4e956f581bcf23f118f3" title="(USBHS_HSTIDR) Device Connection Interrupt Disable">USBHS_HSTIDR_DCONNIEC</a>);
<a name="l00474"></a>00474             <a class="code" href="usbhs_8h.html#aab0688b661054b73b5c9fe45e59ea015" title="Gets USB host interrupt status.">USBHS_ClearHostStatus</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga23995ee5d7ddabec341170ca98b6d624" title="(USBHS_HSTICR) Device Disconnection Interrupt Clear">USBHS_HSTICR_DDISCIC</a>);
<a name="l00475"></a>00475             <a class="code" href="usbhs_8h.html#a7ac646519dfb6c319d8a60f08b5e4c29" title="Gets USB host interrupt status.">USBHS_HostIntEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga20152f5f9facf06b69f6b83fba5f6cfd" title="(USBHS_HSTIER) Device Disconnection Interrupt Enable">USBHS_HSTIER_DDISCIES</a>);
<a name="l00476"></a>00476             <a class="code" href="usbhs_8h.html#ac783c1af3755deab237694ce7b4579bf" title="Sets USB host Enable the Generation of Start of Frame.">USBHS_EnableSOF</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>);
<a name="l00477"></a>00477             uhd_sleep_mode(UHD_STATE_IDLE);
<a name="l00478"></a>00478             uhd_suspend_start = 0;
<a name="l00479"></a>00479             uhd_resume_start = 0;
<a name="l00480"></a>00480             <a class="code" href="group___u_s_b_h__group__interne.html#ga78a0073e6ae8ed58cc6a28ea89820ef1" title="Notify device connection or disconnection.">USBH_notify_connection</a>(<span class="keyword">true</span>);
<a name="l00481"></a>00481         }
<a name="l00482"></a>00482 
<a name="l00483"></a>00483         <span class="comment">/* If Wakeup interrupt is enabled and triggered and connection interrupt is enabled  */</span>
<a name="l00484"></a>00484         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((statusInt &amp; <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gafbd5ce141cbeda44deeeb8803154192b" title="(USBHS_HSTISR) Host Wake-Up Interrupt">USBHS_HSTISR_HWUPI</a> )
<a name="l00485"></a>00485                  &amp;&amp; <a class="code" href="usbhs_8h.html#a6e707992fde3a408663eae6e34b00deb" title="Gets USB host interrupt status.">USBHS_IsHostIntEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, USBHS_HSTIMR_DCONNIE)) {
<a name="l00486"></a>00486             <span class="keywordflow">while</span> (!<a class="code" href="usbhs_8h.html#af53df9330077448ac0d721dbef847c9f" title="Check if clock is usable or not.">USBHS_ISUsableClock</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>));
<a name="l00487"></a>00487 
<a name="l00488"></a>00488             <a class="code" href="usbhs_8h.html#a78d27724945f587c54cba1d9617979c8" title="Freeze or unfreeze USB clock.">USBHS_UnFreezeClock</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>);
<a name="l00489"></a>00489             <span class="comment">// Here the wakeup interrupt has been used to detect connection</span>
<a name="l00490"></a>00490             <span class="comment">// with an asynchrone interrupt</span>
<a name="l00491"></a>00491             <a class="code" href="usbhs_8h.html#aa9a5b060519f982e8cd29dc32754b5a9" title="Gets USB host interrupt status.">USBHS_HostIntDisable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gad76e639effe266e8ea166bc9c5faf889" title="(USBHS_HSTIDR) Host Wake-Up Interrupt Disable">USBHS_HSTIDR_HWUPIEC</a>);
<a name="l00492"></a>00492 
<a name="l00493"></a>00493             <a class="code" href="usbhs_8h.html#ace6971cff0c4aeb589dd3caf663a2756" title="Raise interrupt for endpoint.">USBHS_Set</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga5b63a0fd26b0556923946ffda9966153" title="(USBHS_SR) VBUS Request (Host mode only)">USBHS_SR_VBUSRQ</a>);<span class="comment">// enable VBUS</span>
<a name="l00494"></a>00494             uhd_sleep_mode(UHD_STATE_DISCONNECT);
<a name="l00495"></a>00495             UHC_VBUS_CHANGE(<span class="keyword">true</span>);
<a name="l00496"></a>00496         }
<a name="l00497"></a>00497 
<a name="l00498"></a>00498 
<a name="l00499"></a>00499         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="usbhs_8h.html#a6e707992fde3a408663eae6e34b00deb" title="Gets USB host interrupt status.">USBHS_IsHostIntEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gaafb0e3fbc603a463affb7a12d70bef38" title="(USBHS_HSTIMR) Host Wake-Up Interrupt Enable">USBHS_HSTIMR_HWUPIE</a>)
<a name="l00500"></a>00500                  &amp;&amp; (<a class="code" href="usbhs_8h.html#a40267eb93445cc78fe9b243d25622f9c" title="Gets USB host interrupt status.">USBHS_GetHostStatus</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>,
<a name="l00501"></a>00501                                          (USBHS_HSTISR_HWUPI | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga09c9fce8f7ee07463c038713026e71a3" title="(USBHS_HSTISR) Downstream Resume Sent Interrupt">USBHS_HSTISR_RSMEDI</a> | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gab6e204fe65d4c73c987271638fcdfdb6" title="(USBHS_HSTISR) Upstream Resume Received Interrupt">USBHS_HSTISR_RXRSMI</a>)))) {
<a name="l00502"></a>00502 
<a name="l00503"></a>00503             TRACE_INFO_WP(<span class="stringliteral">&quot;\n\rWKP &quot;</span>);
<a name="l00504"></a>00504 
<a name="l00505"></a>00505             <span class="keywordflow">while</span> (!<a class="code" href="usbhs_8h.html#af53df9330077448ac0d721dbef847c9f" title="Check if clock is usable or not.">USBHS_ISUsableClock</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>));
<a name="l00506"></a>00506 
<a name="l00507"></a>00507             <a class="code" href="usbhs_8h.html#a78d27724945f587c54cba1d9617979c8" title="Freeze or unfreeze USB clock.">USBHS_UnFreezeClock</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>);
<a name="l00508"></a>00508             <span class="comment">// Disable wakeup/resumes interrupts</span>
<a name="l00509"></a>00509             <a class="code" href="usbhs_8h.html#aa9a5b060519f982e8cd29dc32754b5a9" title="Gets USB host interrupt status.">USBHS_HostIntDisable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gad76e639effe266e8ea166bc9c5faf889" title="(USBHS_HSTIDR) Host Wake-Up Interrupt Disable">USBHS_HSTIDR_HWUPIEC</a>
<a name="l00510"></a>00510                                          | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga7c699747f489cbb80ea42c95a9d6a8d0" title="(USBHS_HSTIDR) Downstream Resume Sent Interrupt Disable">USBHS_HSTIDR_RSMEDIEC</a>
<a name="l00511"></a>00511                                          | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gae0e07a0dbd66d3c04b103b99476029d1" title="(USBHS_HSTIDR) Upstream Resume Received Interrupt Disable">USBHS_HSTIDR_RXRSMIEC</a>));
<a name="l00512"></a>00512             <a class="code" href="usbhs_8h.html#ac783c1af3755deab237694ce7b4579bf" title="Sets USB host Enable the Generation of Start of Frame.">USBHS_EnableSOF</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>);
<a name="l00513"></a>00513 
<a name="l00514"></a>00514             <span class="keywordflow">if</span> ((!(<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga09c9fce8f7ee07463c038713026e71a3" title="(USBHS_HSTISR) Downstream Resume Sent Interrupt">USBHS_HSTISR_RSMEDI</a> &amp; status))
<a name="l00515"></a>00515                 &amp;&amp; (!(<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga9bf0cbe3f438eb0ab5d55527be1666bb" title="(USBHS_HSTISR) Device Disconnection Interrupt">USBHS_HSTISR_DDISCI</a> &amp; status))) {
<a name="l00516"></a>00516                 <span class="comment">// It is a upstream resume</span>
<a name="l00517"></a>00517                 <span class="comment">// Note: When the CPU exits from a deep sleep mode, the event</span>
<a name="l00518"></a>00518                 <span class="comment">// Is_uhd_upstream_resume() can be not detected</span>
<a name="l00519"></a>00519                 <span class="comment">// because the USB clock are not available.</span>
<a name="l00520"></a>00520 
<a name="l00521"></a>00521                 <span class="comment">// In High speed mode a downstream resume must be sent</span>
<a name="l00522"></a>00522                 <span class="comment">// after a upstream to avoid a disconnection.</span>
<a name="l00523"></a>00523                 <span class="keywordflow">if</span> (<a class="code" href="usbhs_8h.html#a3a003f0bc5f5ed08ba3253028bd04923" title="Enable or disable USB address.">USBHS_IsUsbHighSpeed</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>))
<a name="l00524"></a>00524                     <a class="code" href="usbhs_8h.html#abe1074ea76550225e959d5628d6b38a4" title="Sets USB host send Resume on USB bus.">USBHS_Resume</a>();
<a name="l00525"></a>00525             }
<a name="l00526"></a>00526 
<a name="l00527"></a>00527             <span class="comment">// Wait 50ms before restarting transfer</span>
<a name="l00528"></a>00528             uhd_resume_start = 50;
<a name="l00529"></a>00529             uhd_sleep_mode(UHD_STATE_IDLE);
<a name="l00530"></a>00530         } <span class="keywordflow">else</span> {
<a name="l00531"></a>00531             assert(<span class="keyword">false</span>); <span class="comment">// Interrupt event no managed</span>
<a name="l00532"></a>00532         }
<a name="l00533"></a>00533 
<a name="l00534"></a>00534         <span class="comment">//TRACE_INFO_WP(&quot;\n\r&quot;);</span>
<a name="l00535"></a>00535     }
<a name="l00536"></a>00536 }
<a name="l00537"></a>00537 
<a name="l00538"></a>00538 
<a name="l00539"></a>00539 <span class="keywordtype">void</span> <a class="code" href="group__uhd__group.html#ga3a715175934fb8bf3c918f04ef0dae2b" title="Enables the USB host mode Start the ID pin management if the ID pin is available.">USBH_HAL_EnableUsbHost</a>(<span class="keywordtype">void</span>)
<a name="l00540"></a>00540 {
<a name="l00541"></a>00541     irqflags_t flags;
<a name="l00542"></a>00542 
<a name="l00543"></a>00543     <span class="comment">// To avoid USB interrupt before end of initialization</span>
<a name="l00544"></a>00544     flags = cpu_irq_save();
<a name="l00545"></a>00545 
<a name="l00546"></a>00546     <span class="comment">//USB_Initialized = true;</span>
<a name="l00547"></a>00547 
<a name="l00548"></a>00548     <span class="comment">//* Enable USB hardware clock</span>
<a name="l00549"></a>00549     sysclk_enable_usb();
<a name="l00550"></a>00550     <a class="code" href="pmc_8c.html#a4154148b8d69545bca1b5c868c004d49" title="Enables the clock of a peripheral. The peripheral ID is used to identify which peripheral is targeted...">PMC_EnablePeripheral</a>(<a class="code" href="group___s_a_m_e70_j19__id.html#gad3ee33b53a18d976324219dd4664a5b4" title="USB Host / Device Controller (USBHS).">ID_USBHS</a>);
<a name="l00551"></a>00551 
<a name="l00552"></a>00552     <span class="comment">// Always authorize asynchronous USB interrupts to exit of sleep mode</span>
<a name="l00553"></a>00553     <span class="comment">// For SAM3 USB wake up device except BACKUP mode</span>
<a name="l00554"></a>00554     NVIC_SetPriority((<a class="code" href="group___s_a_m_e70_j19__cmsis.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a>) <a class="code" href="group___s_a_m_e70_j19__id.html#gad3ee33b53a18d976324219dd4664a5b4" title="USB Host / Device Controller (USBHS).">ID_USBHS</a>, UHD_USB_INT_LEVEL);
<a name="l00555"></a>00555     NVIC_EnableIRQ((<a class="code" href="group___s_a_m_e70_j19__cmsis.html#ga7e1129cd8a196f4284d41db3e82ad5c8">IRQn_Type</a>) <a class="code" href="group___s_a_m_e70_j19__id.html#gad3ee33b53a18d976324219dd4664a5b4" title="USB Host / Device Controller (USBHS).">ID_USBHS</a>);
<a name="l00556"></a>00556 
<a name="l00557"></a>00557     uhd_sleep_mode(UHD_STATE_OFF);
<a name="l00558"></a>00558 
<a name="l00559"></a>00559     <a class="code" href="pio_8h.html#a1bb66b931fa38004c2178936c269fa76" title="Configures a list of Pin instances, each of which can either hold a single pin or a group of pins...">PIO_Configure</a>(USB_HOST, <a class="code" href="pio_8h.html#a2e86ed748eb3ae9574ac9822e67154f6">PIO_LISTSIZE</a>(USB_HOST));
<a name="l00560"></a>00560 
<a name="l00561"></a>00561     <a class="code" href="pio_8h.html#aac9a3cac1a51b45f82b30bd7a29826a6" title="Sets a high output level on all the PIOs defined in the given Pin instance. This has no immediate eff...">PIO_Set</a>(USB_HOST);<span class="comment">// Power off USB devices</span>
<a name="l00562"></a>00562 
<a name="l00563"></a>00563     <a class="code" href="usbhs_8h.html#a636f49939838c8348470310e71e1cd70" title="Device or Host Mode.">USBHS_UsbMode</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, HOST_MODE);
<a name="l00564"></a>00564 
<a name="l00565"></a>00565     <a class="code" href="usbhs_8h.html#a271a9d7a4f68db5bfab4401f8e67d347" title="Enables or disables USB.">USBHS_UsbEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, <span class="keyword">true</span>);
<a name="l00566"></a>00566 
<a name="l00567"></a>00567 <span class="preprocessor">#ifndef USB_HOST_HS_SUPPORT</span>
<a name="l00568"></a>00568 <span class="preprocessor"></span>    <a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>-&gt;USBHS_HSTCTRL |= USBHS_HSTCTRL_SPDCONF_LOW_POWER;
<a name="l00569"></a>00569 <span class="preprocessor">#endif</span>
<a name="l00570"></a>00570 <span class="preprocessor"></span>
<a name="l00571"></a>00571     uhd_ctrl_request_first = NULL;
<a name="l00572"></a>00572     uhd_ctrl_request_last = NULL;
<a name="l00573"></a>00573     uhd_ctrl_request_timeout = 0;
<a name="l00574"></a>00574     uhd_suspend_start = 0;
<a name="l00575"></a>00575     uhd_resume_start = 0;
<a name="l00576"></a>00576     uhd_b_suspend_requested = <span class="keyword">false</span>;
<a name="l00577"></a>00577 
<a name="l00578"></a>00578     <span class="comment">// Check USB clock</span>
<a name="l00579"></a>00579     <a class="code" href="usbhs_8h.html#a78d27724945f587c54cba1d9617979c8" title="Freeze or unfreeze USB clock.">USBHS_UnFreezeClock</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>);
<a name="l00580"></a>00580 
<a name="l00581"></a>00581     <span class="keywordflow">while</span> (!<a class="code" href="usbhs_8h.html#af53df9330077448ac0d721dbef847c9f" title="Check if clock is usable or not.">USBHS_ISUsableClock</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>));
<a name="l00582"></a>00582 
<a name="l00583"></a>00583     <span class="comment">// Clear all interrupts that may have been set by a previous host mode</span>
<a name="l00584"></a>00584     <a class="code" href="usbhs_8h.html#aab0688b661054b73b5c9fe45e59ea015" title="Gets USB host interrupt status.">USBHS_ClearHostStatus</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga0fb7643d5be82c2ea2172850b38484e2" title="(USBHS_HSTICR) Device Connection Interrupt Clear">USBHS_HSTICR_DCONNIC</a> | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga23995ee5d7ddabec341170ca98b6d624" title="(USBHS_HSTICR) Device Disconnection Interrupt Clear">USBHS_HSTICR_DDISCIC</a>
<a name="l00585"></a>00585                                   | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gaa6df5ae7bc42d5c5a48f7780451ccd57" title="(USBHS_HSTICR) Host Start of Frame Interrupt Clear">USBHS_HSTICR_HSOFIC</a> | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga63908e82e8d8280a53314644efcda9ba" title="(USBHS_HSTICR) Host Wake-Up Interrupt Clear">USBHS_HSTICR_HWUPIC</a>
<a name="l00586"></a>00586                                   | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga0051eb6033ce6b61620c7ef787defcf3" title="(USBHS_HSTICR) Downstream Resume Sent Interrupt Clear">USBHS_HSTICR_RSMEDIC</a> | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga84df2c9bc871c6336be81958fe823f08" title="(USBHS_HSTICR) USB Reset Sent Interrupt Clear">USBHS_HSTICR_RSTIC</a>
<a name="l00587"></a>00587                                   | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga566346848e44c880a71dd89abcedd6ce" title="(USBHS_HSTICR) Upstream Resume Received Interrupt Clear">USBHS_HSTICR_RXRSMIC</a>));
<a name="l00588"></a>00588     memory_sync();
<a name="l00589"></a>00589 
<a name="l00590"></a>00590     <a class="code" href="usbhs_8h.html#a737215891d431406a22e7627cb15f337" title="Freeze or unfreeze USB clock.">USBHS_VBusHWC</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, <span class="keyword">false</span>);
<a name="l00591"></a>00591     uhd_sleep_mode(UHD_STATE_NO_VBUS);
<a name="l00592"></a>00592 <span class="comment"></span>
<a name="l00593"></a>00593 <span class="comment">    /** Freeze USB clock to use wakeup interrupt</span>
<a name="l00594"></a>00594 <span class="comment">    * to detect connection.</span>
<a name="l00595"></a>00595 <span class="comment">    * After detection of wakeup interrupt,</span>
<a name="l00596"></a>00596 <span class="comment">    * the clock is unfreeze to have the true</span>
<a name="l00597"></a>00597 <span class="comment">    * connection interrupt.</span>
<a name="l00598"></a>00598 <span class="comment">    */</span>
<a name="l00599"></a>00599     <span class="comment">// wakeup</span>
<a name="l00600"></a>00600     <a class="code" href="usbhs_8h.html#a7ac646519dfb6c319d8a60f08b5e4c29" title="Gets USB host interrupt status.">USBHS_HostIntEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga3da0cf2e0f5a86423269e347cb1430f8" title="(USBHS_HSTIER) Host Wake-Up Interrupt Enable">USBHS_HSTIER_HWUPIES</a>);
<a name="l00601"></a>00601     uhd_sleep_mode(UHD_STATE_DISCONNECT);
<a name="l00602"></a>00602     UHC_VBUS_CHANGE(<span class="keyword">true</span>);<span class="comment">/* Changed to HIGH */</span>
<a name="l00603"></a>00603 
<a name="l00604"></a>00604     <a class="code" href="pio_8h.html#a2d4d88110e7ab4fc0732df6d35289e06" title="Sets a low output level on all the PIOs defined in the given Pin instance. This has no immediate effe...">PIO_Clear</a>(USB_HOST);<span class="comment">// power on USB device</span>
<a name="l00605"></a>00605 
<a name="l00606"></a>00606     <span class="comment">// Enable main control interrupt</span>
<a name="l00607"></a>00607     <span class="comment">// Connection, SOF and reset</span>
<a name="l00608"></a>00608     <a class="code" href="usbhs_8h.html#a7ac646519dfb6c319d8a60f08b5e4c29" title="Gets USB host interrupt status.">USBHS_HostIntEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>,
<a name="l00609"></a>00609                         (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga8ef717bd9e7bd7a422a7e71193970926" title="(USBHS_HSTIER) USB Reset Sent Interrupt Enable">USBHS_HSTIER_RSTIES</a> | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga2b0589e8cb36be187b55ded881b30cac" title="(USBHS_HSTIER) Host Start of Frame Interrupt Enable">USBHS_HSTIER_HSOFIES</a> | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga09be10f559e69bb67edafc93a6585788" title="(USBHS_HSTIER) Device Connection Interrupt Enable">USBHS_HSTIER_DCONNIES</a>));
<a name="l00610"></a>00610 
<a name="l00611"></a>00611     <a class="code" href="usbhs_8h.html#a07183fee11fbf4c00401b455bdfed9dd" title="Freeze or unfreeze USB clock.">USBHS_FreezeClock</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>);
<a name="l00612"></a>00612 
<a name="l00613"></a>00613     cpu_irq_restore(flags);
<a name="l00614"></a>00614 
<a name="l00615"></a>00615 }
<a name="l00616"></a>00616 
<a name="l00617"></a>00617 <span class="keywordtype">void</span> <a class="code" href="group__uhd__group.html#ga9b45418a37c193dbcff7ef17040cfa30" title="Disables the USB host mode.">USBH_HAL_DisableUsb</a>(<span class="keywordtype">bool</span> b_id_stop)
<a name="l00618"></a>00618 {
<a name="l00619"></a>00619     irqflags_t flags;
<a name="l00620"></a>00620 
<a name="l00621"></a>00621     b_id_stop = b_id_stop;
<a name="l00622"></a>00622     <span class="comment">// Check USB clock ready after a potential sleep mode &lt; IDLE</span>
<a name="l00623"></a>00623     <span class="keywordflow">while</span> (!<a class="code" href="usbhs_8h.html#af53df9330077448ac0d721dbef847c9f" title="Check if clock is usable or not.">USBHS_ISUsableClock</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>));
<a name="l00624"></a>00624 
<a name="l00625"></a>00625     <a class="code" href="usbhs_8h.html#a78d27724945f587c54cba1d9617979c8" title="Freeze or unfreeze USB clock.">USBHS_UnFreezeClock</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>);
<a name="l00626"></a>00626     printf(<span class="stringliteral">&quot;USB disabled \n\r&quot;</span>);
<a name="l00627"></a>00627 
<a name="l00628"></a>00628     <span class="comment">// (Connection, disconnection, SOF and reset)</span>
<a name="l00629"></a>00629     <a class="code" href="usbhs_8h.html#aa9a5b060519f982e8cd29dc32754b5a9" title="Gets USB host interrupt status.">USBHS_HostIntDisable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga0fb7643d5be82c2ea2172850b38484e2" title="(USBHS_HSTICR) Device Connection Interrupt Clear">USBHS_HSTICR_DCONNIC</a> | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga23995ee5d7ddabec341170ca98b6d624" title="(USBHS_HSTICR) Device Disconnection Interrupt Clear">USBHS_HSTICR_DDISCIC</a>
<a name="l00630"></a>00630                                  | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gaa6df5ae7bc42d5c5a48f7780451ccd57" title="(USBHS_HSTICR) Host Start of Frame Interrupt Clear">USBHS_HSTICR_HSOFIC</a> | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga63908e82e8d8280a53314644efcda9ba" title="(USBHS_HSTICR) Host Wake-Up Interrupt Clear">USBHS_HSTICR_HWUPIC</a>
<a name="l00631"></a>00631                                  | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga0051eb6033ce6b61620c7ef787defcf3" title="(USBHS_HSTICR) Downstream Resume Sent Interrupt Clear">USBHS_HSTICR_RSMEDIC</a> | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga84df2c9bc871c6336be81958fe823f08" title="(USBHS_HSTICR) USB Reset Sent Interrupt Clear">USBHS_HSTICR_RSTIC</a>
<a name="l00632"></a>00632                                  | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga566346848e44c880a71dd89abcedd6ce" title="(USBHS_HSTICR) Upstream Resume Received Interrupt Clear">USBHS_HSTICR_RXRSMIC</a>));
<a name="l00633"></a>00633 
<a name="l00634"></a>00634     <a class="code" href="usbhs_8h.html#a8b5061d7281a8104020962d8b6291da1" title="Sets USB host disable the Generation of Start of Frame.">USBHS_DisableSOF</a>();
<a name="l00635"></a>00635     <a class="code" href="usbhs_8h.html#abb9881c68cce5603acf01ad61966bf07" title="Raise interrupt for endpoint.">USBHS_Ack</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga5b63a0fd26b0556923946ffda9966153" title="(USBHS_SR) VBUS Request (Host mode only)">USBHS_SR_VBUSRQ</a>);
<a name="l00636"></a>00636     <a class="code" href="group___u_s_b_h__group__interne.html#ga78a0073e6ae8ed58cc6a28ea89820ef1" title="Notify device connection or disconnection.">USBH_notify_connection</a>(<span class="keyword">false</span>);
<a name="l00637"></a>00637 
<a name="l00638"></a>00638     flags = cpu_irq_save();
<a name="l00639"></a>00639     <a class="code" href="usbhs_8h.html#a07183fee11fbf4c00401b455bdfed9dd" title="Freeze or unfreeze USB clock.">USBHS_FreezeClock</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>);
<a name="l00640"></a>00640     <a class="code" href="usbhs_8h.html#a271a9d7a4f68db5bfab4401f8e67d347" title="Enables or disables USB.">USBHS_UsbEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, <span class="keyword">false</span>);
<a name="l00641"></a>00641     sysclk_disable_usb();
<a name="l00642"></a>00642     <a class="code" href="pmc_8c.html#a2bb6755e2bf15a75e193cb6510064fa4" title="Disables the clock of a peripheral. The peripheral ID is used to identify which peripheral is targete...">PMC_DisablePeripheral</a>(<a class="code" href="group___s_a_m_e70_j19__id.html#gad3ee33b53a18d976324219dd4664a5b4" title="USB Host / Device Controller (USBHS).">ID_USBHS</a>);
<a name="l00643"></a>00643     uhd_sleep_mode(UHD_STATE_OFF);
<a name="l00644"></a>00644     cpu_irq_restore(flags);
<a name="l00645"></a>00645 }
<a name="l00646"></a>00646 
<a name="l00647"></a>00647 <a class="code" href="group__uhd__group.html#ga3d1a10bd9f6a35bd4db20ced8f72474a" title="Device speed.">USBH_Speed_t</a> <a class="code" href="group__uhd__group.html#ga6d1a91042ba3675ea7495dce99f1871b" title="Returns the speed of connected device.">USBH_HAL_GetSpeed</a>(<span class="keywordtype">void</span>)
<a name="l00648"></a>00648 {
<a name="l00649"></a>00649     <span class="keywordflow">switch</span> (<a class="code" href="usbhs_8h.html#a23bc7c30ae1779f56b28b82cf5153866" title="Enable or disable USB address.">USBHS_GetUsbSpeed</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>)) {
<a name="l00650"></a>00650 
<a name="l00651"></a>00651     <span class="keywordflow">case</span> <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gac258c2bfc867253a34cd8fab6ea2b732" title="(USBHS_SR) High-Speed mode">USBHS_SR_SPEED_HIGH_SPEED</a>:
<a name="l00652"></a>00652         <span class="keywordflow">return</span> UHD_SPEED_HIGH;
<a name="l00653"></a>00653 
<a name="l00654"></a>00654     <span class="keywordflow">case</span> <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga096dbebf7943b10d6a339a0ac10b6091" title="(USBHS_SR) Full-Speed mode">USBHS_SR_SPEED_FULL_SPEED</a>:
<a name="l00655"></a>00655         <span class="keywordflow">return</span> UHD_SPEED_FULL;
<a name="l00656"></a>00656 
<a name="l00657"></a>00657     <span class="keywordflow">case</span> <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga33a328659df1b0ab128a7bca5e9c7959" title="(USBHS_SR) Low-Speed mode">USBHS_SR_SPEED_LOW_SPEED</a>:
<a name="l00658"></a>00658         <span class="keywordflow">return</span> UHD_SPEED_LOW;
<a name="l00659"></a>00659 
<a name="l00660"></a>00660     <span class="keywordflow">default</span>:
<a name="l00661"></a>00661         assert(<span class="keyword">false</span>);
<a name="l00662"></a>00662         <span class="keywordflow">return</span> UHD_SPEED_LOW;
<a name="l00663"></a>00663     }
<a name="l00664"></a>00664 }
<a name="l00665"></a>00665 
<a name="l00666"></a>00666 uint16_t <a class="code" href="group__uhd__group.html#gaee8af62530aefb6025ad2391361e8895" title="Returns the current Start Of Frame (SOF) number.">USBH_HAL_GetFrameNum</a>(<span class="keywordtype">void</span>)
<a name="l00667"></a>00667 {
<a name="l00668"></a>00668     <span class="keywordflow">return</span> <a class="code" href="usbhs_8h.html#ac2d5100e84f17f3afd652b4813f7a5b7" title="Gets USB host interrupt status.">USBHS_HostGetSOF</a>();
<a name="l00669"></a>00669 }
<a name="l00670"></a>00670 
<a name="l00671"></a>00671 uint16_t <a class="code" href="group__uhd__group.html#gae32ed29203116712f786dbc913d96327" title="Returns the current micro start of frame number.">USBH_HAL_GetMicroFrameNum</a>(<span class="keywordtype">void</span>)
<a name="l00672"></a>00672 {
<a name="l00673"></a>00673     <span class="keywordflow">return</span> <a class="code" href="usbhs_8h.html#abbd31f8ac6a853c865dbab561cd93683" title="Gets USB host interrupt status.">USBHS_HostGetMSOF</a>();
<a name="l00674"></a>00674 }
<a name="l00675"></a>00675 
<a name="l00676"></a>00676 <span class="keywordtype">void</span> <a class="code" href="group__uhd__group.html#ga9cedbbab25d378fecdae30a07b4b811f" title="Enables the Reset state on the USB line.">USBH_HAL_Reset</a>(<a class="code" href="group__uhd__group.html#ga305e97eac8bfb0052c9efbfc6d070c60" title="End of reset callback function type. Registered by uhd_send_reset() Callback called when reset event ...">uhd_callback_reset_t</a> callback)
<a name="l00677"></a>00677 {
<a name="l00678"></a>00678     uhd_reset_callback = callback;
<a name="l00679"></a>00679     <a class="code" href="usbhs_8h.html#a165ebc9ef9f9199f9c4c7163e8b3872f" title="Sets USB host sends reste signal on USB Bus.">USBHS_Reset</a>();
<a name="l00680"></a>00680 }
<a name="l00681"></a>00681 
<a name="l00682"></a>00682 <span class="keywordtype">void</span> <a class="code" href="group__uhd__group.html#ga108d6958efd3c7337897ae40963e3f58" title="Enables the suspend state on the USB line. The SUSPEND state is enable when SOF are disabled on USB l...">USBH_HAL_Suspend</a>(<span class="keywordtype">void</span>)
<a name="l00683"></a>00683 {
<a name="l00684"></a>00684     uint8_t pipe;
<a name="l00685"></a>00685 
<a name="l00686"></a>00686     <span class="keywordflow">if</span> (uhd_ctrl_request_timeout) {
<a name="l00687"></a>00687         <span class="comment">// Delay suspend after setup requests</span>
<a name="l00688"></a>00688         uhd_b_suspend_requested = <span class="keyword">true</span>;
<a name="l00689"></a>00689         <span class="keywordflow">return</span>;
<a name="l00690"></a>00690     }
<a name="l00691"></a>00691 
<a name="l00692"></a>00692     <span class="comment">// Save pipe freeze states and freeze pipes</span>
<a name="l00693"></a>00693     uhd_pipes_unfreeze = 0;
<a name="l00694"></a>00694 
<a name="l00695"></a>00695     <span class="keywordflow">for</span> (pipe = 1; pipe &lt; USBHS_EPT_NUM; pipe++) {
<a name="l00696"></a>00696         uhd_pipes_unfreeze |= (!<a class="code" href="usbhs_8h.html#a0a8e28b882f4abf73c473980d36c7e06" title="Gets USB host interrupt status.">USBHS_IsHostPipeIntTypeEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe,
<a name="l00697"></a>00697                                <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga7c445ad9e88f7bd07fa360f3ee17acbe" title="(USBHS_HSTPIPIMR[10]) Pipe Freeze">USBHS_HSTPIPIMR_PFREEZE</a>)) &lt;&lt; pipe;
<a name="l00698"></a>00698         <a class="code" href="usbhs_8h.html#acd60bcdb7e5420ac4cfb8b457838f9ba" title="Gets USB host interrupt status.">USBHS_HostEnablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga8a09e9f1a8824d9033ebfa3a0570d848" title="(USBHS_HSTPIPIER[10]) Pipe Freeze Enable">USBHS_HSTPIPIER_PFREEZES</a>);
<a name="l00699"></a>00699     }
<a name="l00700"></a>00700 
<a name="l00701"></a>00701     <span class="comment">// Wait three SOFs before entering in suspend state</span>
<a name="l00702"></a>00702     uhd_suspend_start = 3;
<a name="l00703"></a>00703 }
<a name="l00704"></a>00704 
<a name="l00705"></a>00705 <span class="keywordtype">bool</span> <a class="code" href="group__uhd__group.html#ga45fc0843344e751529a0c4f113aa3d91" title="Test if the suspend state is enabled on the USB line.">USBH_HAL_IsSuspended</a>(<span class="keywordtype">void</span>)
<a name="l00706"></a>00706 {
<a name="l00707"></a>00707     <span class="keywordflow">return</span> !<a class="code" href="usbhs_8h.html#a00c26cb8e5bbda68e2ab8a379a7bd001" title="Sets USB host Enable the Generation of Start of Frame.">USBHS_IsEnableSOF</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>);
<a name="l00708"></a>00708 }
<a name="l00709"></a>00709 
<a name="l00710"></a>00710 <span class="keywordtype">void</span> <a class="code" href="group__uhd__group.html#gac9fdf87a0d813bf3717f1440e60c41d8" title="Enables the IDLE state on the USB line. The IDLE state is enable when SOF are present on USB line...">USBH_HAL_Resume</a>(<span class="keywordtype">void</span>)
<a name="l00711"></a>00711 {
<a name="l00712"></a>00712     <span class="keywordflow">if</span> (<a class="code" href="usbhs_8h.html#a00c26cb8e5bbda68e2ab8a379a7bd001" title="Sets USB host Enable the Generation of Start of Frame.">USBHS_IsEnableSOF</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>)) {
<a name="l00713"></a>00713         <span class="comment">// Currently in IDLE mode (!=Suspend)</span>
<a name="l00714"></a>00714         <span class="keywordflow">if</span> (uhd_suspend_start) {
<a name="l00715"></a>00715             <span class="comment">// Suspend mode on going</span>
<a name="l00716"></a>00716             <span class="comment">// then stop it and start resume event</span>
<a name="l00717"></a>00717             uhd_suspend_start = 0;
<a name="l00718"></a>00718             uhd_resume_start = 1;
<a name="l00719"></a>00719         }
<a name="l00720"></a>00720 
<a name="l00721"></a>00721         <span class="keywordflow">return</span>;
<a name="l00722"></a>00722     }
<a name="l00723"></a>00723 
<a name="l00724"></a>00724     <span class="comment">// Check USB clock ready after a potential sleep mode &lt; IDLE</span>
<a name="l00725"></a>00725     <span class="keywordflow">while</span> (!<a class="code" href="usbhs_8h.html#af53df9330077448ac0d721dbef847c9f" title="Check if clock is usable or not.">USBHS_ISUsableClock</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>));
<a name="l00726"></a>00726 
<a name="l00727"></a>00727     <a class="code" href="usbhs_8h.html#a78d27724945f587c54cba1d9617979c8" title="Freeze or unfreeze USB clock.">USBHS_UnFreezeClock</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>);
<a name="l00728"></a>00728     <a class="code" href="usbhs_8h.html#ac783c1af3755deab237694ce7b4579bf" title="Sets USB host Enable the Generation of Start of Frame.">USBHS_EnableSOF</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>);
<a name="l00729"></a>00729     <a class="code" href="usbhs_8h.html#abe1074ea76550225e959d5628d6b38a4" title="Sets USB host send Resume on USB bus.">USBHS_Resume</a>();
<a name="l00730"></a>00730     uhd_sleep_mode(UHD_STATE_IDLE);
<a name="l00731"></a>00731 }
<a name="l00732"></a>00732 
<a name="l00733"></a>00733 <span class="keywordtype">bool</span> <a class="code" href="group__uhd__group.html#gad9e15307f67bf17a172ce88dc52ff6a3" title="Configures and enables a control endpoint 0.">USBH_HAL_ConfigureControlPipe</a>(uint8_t Addr, uint16_t ep_size)
<a name="l00734"></a>00734 {
<a name="l00735"></a>00735     uint8_t bSizeEpt;
<a name="l00736"></a>00736 
<a name="l00737"></a>00737     <span class="keywordflow">if</span> (ep_size &lt; 8)
<a name="l00738"></a>00738         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00739"></a>00739 
<a name="l00740"></a>00740 <span class="preprocessor">#ifdef USB_HOST_HUB_SUPPORT</span>
<a name="l00741"></a>00741 <span class="preprocessor"></span>
<a name="l00742"></a>00742     <span class="keywordflow">if</span> (<a class="code" href="usbhs_8h.html#aca1a73918c77f0aaa82395b55d760ae8" title="Gets USB host interrupt status.">USBHS_IsHostPipeEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0)) {
<a name="l00743"></a>00743         <span class="comment">// Already allocated</span>
<a name="l00744"></a>00744 <span class="preprocessor">#error TODO Add USB address in a list</span>
<a name="l00745"></a>00745 <span class="preprocessor"></span>        <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00746"></a>00746     }
<a name="l00747"></a>00747 
<a name="l00748"></a>00748 <span class="preprocessor">#endif</span>
<a name="l00749"></a>00749 <span class="preprocessor"></span>
<a name="l00750"></a>00750     <a class="code" href="usbhs_8h.html#a10f00de072a1cbb4c14e9d125368f3ff" title="Gets USB host interrupt status.">USBHS_HostPipeEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0);
<a name="l00751"></a>00751 
<a name="l00752"></a>00752     <span class="comment">/* Configure endpoint size */</span>
<a name="l00753"></a>00753     <span class="keywordflow">if</span> (ep_size &lt;= 8)
<a name="l00754"></a>00754         bSizeEpt = 0;
<a name="l00755"></a>00755     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ep_size &lt;= 16)
<a name="l00756"></a>00756         bSizeEpt = 1;
<a name="l00757"></a>00757     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ep_size &lt;= 32)
<a name="l00758"></a>00758         bSizeEpt = 2;
<a name="l00759"></a>00759     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ep_size &lt;= 64)
<a name="l00760"></a>00760         bSizeEpt = 3;
<a name="l00761"></a>00761     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ep_size &lt;= 128)
<a name="l00762"></a>00762         bSizeEpt = 4;
<a name="l00763"></a>00763     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ep_size &lt;= 256)
<a name="l00764"></a>00764         bSizeEpt = 5;
<a name="l00765"></a>00765     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ep_size &lt;= 512)
<a name="l00766"></a>00766         bSizeEpt = 6;
<a name="l00767"></a>00767     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ep_size &lt;= 1024)
<a name="l00768"></a>00768         bSizeEpt = 7;
<a name="l00769"></a>00769 
<a name="l00770"></a>00770 <span class="preprocessor">#ifdef USB_HOST_HUB_SUPPORT</span>
<a name="l00771"></a>00771 <span class="preprocessor"></span>    bSizeEpt = 3; <span class="comment">//64 bytes</span>
<a name="l00772"></a>00772 <span class="preprocessor">#endif</span>
<a name="l00773"></a>00773 <span class="preprocessor"></span>    <a class="code" href="usbhs_8h.html#ad7321df66563d27e92e3eee190f5f328" title="Gets USB host interrupt status.">USBHS_HostConfigure</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gac865ef54672a64bc27455bb233edbd67" title="(USBHS_HSTPIPCFG[10]) Single-bank pipe">USBHS_HSTPIPCFG_PBK_1_BANK</a>, bSizeEpt,
<a name="l00774"></a>00774                         <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gace3afdd5bdfd55b608a71809a5687705" title="(USBHS_HSTPIPCFG[10]) Control">USBHS_HSTPIPCFG_PTYPE_CTRL</a>, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga13977671c7a6080fe0a24e1fa20b55b2" title="(USBHS_HSTPIPCFG[10]) SETUP">USBHS_HSTPIPCFG_PTOKEN_SETUP</a>, 0, 0);
<a name="l00775"></a>00775     <a class="code" href="usbhs_8h.html#af33de4a77714a4669ec1d6c52847ce36" title="Gets USB host interrupt status.">USBHS_HostDisableAutoSw</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0);
<a name="l00776"></a>00776     <a class="code" href="usbhs_8h.html#aedf0c19282a4ab894880c582f9cc4706" title="Gets USB host interrupt status.">USBHS_HostAllocMem</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0);
<a name="l00777"></a>00777 
<a name="l00778"></a>00778     <span class="keywordflow">if</span> (!<a class="code" href="usbhs_8h.html#a80888f7cf448edbebfc2cb99264e0642" title="Gets USB host interrupt status.">USBHS_IsHostConfigOk</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0)) {
<a name="l00779"></a>00779         <a class="code" href="usbhs_8h.html#a4aabd40a9718b4bab7036aa5439a266f" title="Gets USB host interrupt status.">USBHS_HostPipeDisable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0);
<a name="l00780"></a>00780         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00781"></a>00781     }
<a name="l00782"></a>00782 
<a name="l00783"></a>00783     USBHS_HostSetAddr(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0, Addr);
<a name="l00784"></a>00784 
<a name="l00785"></a>00785     <span class="comment">// Always enable stall and error interrupts of control endpoint</span>
<a name="l00786"></a>00786     <a class="code" href="usbhs_8h.html#acd60bcdb7e5420ac4cfb8b457838f9ba" title="Gets USB host interrupt status.">USBHS_HostEnablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0,
<a name="l00787"></a>00787                                 (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gab16e4bf12ba2658f953e4deaaa5dd511" title="(USBHS_HSTPIPIER[10]) Received STALLed Interrupt Enable">USBHS_HSTPIPIER_RXSTALLDES</a> | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga233107ba8d4fb36bc0362bf1628b4570" title="(USBHS_HSTPIPIER[10]) Pipe Error Interrupt Enable">USBHS_HSTPIPIER_PERRES</a>));
<a name="l00788"></a>00788     <a class="code" href="usbhs_8h.html#abe033170285572938d1ed3fbb01e9c3e" title="Gets USB host interrupt status.">USBHS_HostPipeIntEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0);
<a name="l00789"></a>00789     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00790"></a>00790 }
<a name="l00791"></a>00791 
<a name="l00792"></a>00792 <span class="keywordtype">bool</span> <a class="code" href="group__uhd__group.html#ga8da03709234cba062389fcaee2c62f8b" title="Configures and enables an endpoint.">USBH_HAL_ConfigurePipe</a>(uint8_t Addr, USBEndpointDescriptor *ep_desc)
<a name="l00793"></a>00793 {
<a name="l00794"></a>00794     uint32_t ep_type, ep_dir;
<a name="l00795"></a>00795     uint8_t ep_interval;
<a name="l00796"></a>00796     uint8_t pipe;
<a name="l00797"></a>00797     uint8_t bank, ep_addr, bSizeEpt;
<a name="l00798"></a>00798 
<a name="l00799"></a>00799     <span class="keywordflow">for</span> (pipe = 1; pipe &lt; USBHS_EPT_NUM; pipe++) {
<a name="l00800"></a>00800         <span class="keywordflow">if</span> (<a class="code" href="usbhs_8h.html#aca1a73918c77f0aaa82395b55d760ae8" title="Gets USB host interrupt status.">USBHS_IsHostPipeEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe))
<a name="l00801"></a>00801             <span class="keywordflow">continue</span>;
<a name="l00802"></a>00802 
<a name="l00803"></a>00803         <a class="code" href="usbhs_8h.html#a10f00de072a1cbb4c14e9d125368f3ff" title="Gets USB host interrupt status.">USBHS_HostPipeEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe);
<a name="l00804"></a>00804         ep_addr = ep_desc-&gt;bEndpointAddress &amp; USB_EP_ADDR_MASK;
<a name="l00805"></a>00805         ep_dir = (ep_desc-&gt;bEndpointAddress &amp; USB_EP_DIR_IN) ?
<a name="l00806"></a>00806                  (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga05aed341b46e5deb78532b4e66ad3170" title="(USBHS_HSTPIPCFG[10]) IN">USBHS_HSTPIPCFG_PTOKEN_IN</a>) :
<a name="l00807"></a>00807                  (USBHS_HSTPIPCFG_PTOKEN_OUT),
<a name="l00808"></a>00808                  ep_type = ep_desc-&gt;bmAttributes &amp; <a class="code" href="group__usb__descriptor.html#ga0990fd5e1046bb06f9d84bfe81ffa49f">USB_EP_TYPE_MASK</a>;
<a name="l00809"></a>00809 
<a name="l00810"></a>00810         <span class="comment">// Bank choice</span>
<a name="l00811"></a>00811         switch (ep_type) {
<a name="l00812"></a>00812         <span class="keywordflow">case</span> <a class="code" href="group__usb__ep__type.html#ga68191dae196f962d68287947f9466b4d">USBEndpointDescriptor_ISOCHRONOUS</a>:
<a name="l00813"></a>00813             bank = UHD_ISOCHRONOUS_NB_BANK;
<a name="l00814"></a>00814             ep_interval = ep_desc-&gt;bInterval;
<a name="l00815"></a>00815             ep_type = USBHS_HSTPIPCFG_PTYPE_ISO;
<a name="l00816"></a>00816             <span class="keywordflow">break</span>;
<a name="l00817"></a>00817 
<a name="l00818"></a>00818         <span class="keywordflow">case</span> <a class="code" href="group__usb__ep__type.html#ga1987288549d9da0e64eb3ae097f1e52e">USBEndpointDescriptor_INTERRUPT</a>:
<a name="l00819"></a>00819             bank = UHD_INTERRUPT_NB_BANK;
<a name="l00820"></a>00820             ep_interval = ep_desc-&gt;bInterval;
<a name="l00821"></a>00821             ep_type = USBHS_HSTPIPCFG_PTYPE_INTRPT;
<a name="l00822"></a>00822             <span class="keywordflow">break</span>;
<a name="l00823"></a>00823 
<a name="l00824"></a>00824         <span class="keywordflow">case</span> <a class="code" href="group__usb__ep__type.html#ga6ecd1fc3ce2825564b74130eb8b274e1">USBEndpointDescriptor_BULK</a>:
<a name="l00825"></a>00825             bank = UHD_BULK_NB_BANK;
<a name="l00826"></a>00826             <span class="comment">// 0 is required by USBHS hardware for bulk</span>
<a name="l00827"></a>00827             ep_interval = 0;
<a name="l00828"></a>00828             ep_type = USBHS_HSTPIPCFG_PTYPE_BLK;
<a name="l00829"></a>00829             <span class="keywordflow">break</span>;
<a name="l00830"></a>00830 
<a name="l00831"></a>00831         <span class="keywordflow">default</span>:
<a name="l00832"></a>00832             assert(<span class="keyword">false</span>);
<a name="l00833"></a>00833             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00834"></a>00834         }
<a name="l00835"></a>00835 
<a name="l00836"></a>00836         <span class="keywordflow">switch</span> (bank) {
<a name="l00837"></a>00837         <span class="keywordflow">case</span> 1:
<a name="l00838"></a>00838             bank = USBHS_HSTPIPCFG_PBK_1_BANK;
<a name="l00839"></a>00839             <span class="keywordflow">break</span>;
<a name="l00840"></a>00840 
<a name="l00841"></a>00841         <span class="keywordflow">case</span> 2:
<a name="l00842"></a>00842             bank = USBHS_HSTPIPCFG_PBK_2_BANK;
<a name="l00843"></a>00843             <span class="keywordflow">break</span>;
<a name="l00844"></a>00844 
<a name="l00845"></a>00845         <span class="keywordflow">case</span> 3:
<a name="l00846"></a>00846             bank = USBHS_HSTPIPCFG_PBK_3_BANK;
<a name="l00847"></a>00847             <span class="keywordflow">break</span>;
<a name="l00848"></a>00848 
<a name="l00849"></a>00849         <span class="keywordflow">default</span>:
<a name="l00850"></a>00850             assert(<span class="keyword">false</span>);
<a name="l00851"></a>00851             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00852"></a>00852         }
<a name="l00853"></a>00853 
<a name="l00854"></a>00854         <span class="comment">/* Configure endpoint size */</span>
<a name="l00855"></a>00855         <span class="keywordflow">if</span> (ep_desc-&gt;wMaxPacketSize &lt;= 8)
<a name="l00856"></a>00856             bSizeEpt = 0;
<a name="l00857"></a>00857         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ep_desc-&gt;wMaxPacketSize &lt;= 16)
<a name="l00858"></a>00858             bSizeEpt = 1;
<a name="l00859"></a>00859         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ep_desc-&gt;wMaxPacketSize &lt;= 32)
<a name="l00860"></a>00860             bSizeEpt = 2;
<a name="l00861"></a>00861         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ep_desc-&gt;wMaxPacketSize &lt;= 64)
<a name="l00862"></a>00862             bSizeEpt = 3;
<a name="l00863"></a>00863         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ep_desc-&gt;wMaxPacketSize &lt;= 128)
<a name="l00864"></a>00864             bSizeEpt = 4;
<a name="l00865"></a>00865         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ep_desc-&gt;wMaxPacketSize &lt;= 256)
<a name="l00866"></a>00866             bSizeEpt = 5;
<a name="l00867"></a>00867         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ep_desc-&gt;wMaxPacketSize &lt;= 512)
<a name="l00868"></a>00868             bSizeEpt = 6;
<a name="l00869"></a>00869         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ep_desc-&gt;wMaxPacketSize &lt;= 1024)
<a name="l00870"></a>00870             bSizeEpt = 7;
<a name="l00871"></a>00871 
<a name="l00872"></a>00872         <a class="code" href="usbhs_8h.html#ad7321df66563d27e92e3eee190f5f328" title="Gets USB host interrupt status.">USBHS_HostConfigure</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, bank, bSizeEpt, ep_type, ep_dir,
<a name="l00873"></a>00873                             ep_addr, ep_interval);
<a name="l00874"></a>00874         <a class="code" href="usbhs_8h.html#aa347527d17e6ee48869cabe3344f0b8e" title="Gets USB host interrupt status.">USBHS_HostEnableAutoSw</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe);
<a name="l00875"></a>00875 
<a name="l00876"></a>00876         <a class="code" href="usbhs_8h.html#aedf0c19282a4ab894880c582f9cc4706" title="Gets USB host interrupt status.">USBHS_HostAllocMem</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe);
<a name="l00877"></a>00877 
<a name="l00878"></a>00878         <span class="keywordflow">if</span> (!<a class="code" href="usbhs_8h.html#a80888f7cf448edbebfc2cb99264e0642" title="Gets USB host interrupt status.">USBHS_IsHostConfigOk</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe)) {
<a name="l00879"></a>00879             <a class="code" href="usbhs_8h.html#a4aabd40a9718b4bab7036aa5439a266f" title="Gets USB host interrupt status.">USBHS_HostPipeDisable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe);
<a name="l00880"></a>00880             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00881"></a>00881         }
<a name="l00882"></a>00882 
<a name="l00883"></a>00883         USBHS_HostSetAddr(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, Addr);
<a name="l00884"></a>00884 
<a name="l00885"></a>00885         <a class="code" href="usbhs_8h.html#a10f00de072a1cbb4c14e9d125368f3ff" title="Gets USB host interrupt status.">USBHS_HostPipeEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe);
<a name="l00886"></a>00886 
<a name="l00887"></a>00887         <span class="comment">// Enable endpoint interrupts</span>
<a name="l00888"></a>00888         <a class="code" href="usbhs_8h.html#abca7229dc06a00a9e8cced6870f4a827" title="Gets USB host interrupt status.">USBHS_HostDmaIntEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe - 1);
<a name="l00889"></a>00889         <a class="code" href="usbhs_8h.html#acd60bcdb7e5420ac4cfb8b457838f9ba" title="Gets USB host interrupt status.">USBHS_HostEnablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe,
<a name="l00890"></a>00890                                     (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gab16e4bf12ba2658f953e4deaaa5dd511" title="(USBHS_HSTPIPIER[10]) Received STALLed Interrupt Enable">USBHS_HSTPIPIER_RXSTALLDES</a> | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga233107ba8d4fb36bc0362bf1628b4570" title="(USBHS_HSTPIPIER[10]) Pipe Error Interrupt Enable">USBHS_HSTPIPIER_PERRES</a>) );
<a name="l00891"></a>00891 
<a name="l00892"></a>00892         <a class="code" href="usbhs_8h.html#abe033170285572938d1ed3fbb01e9c3e" title="Gets USB host interrupt status.">USBHS_HostPipeIntEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe);
<a name="l00893"></a>00893 
<a name="l00894"></a>00894         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00895"></a>00895     }
<a name="l00896"></a>00896 
<a name="l00897"></a>00897     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00898"></a>00898 }
<a name="l00899"></a>00899 
<a name="l00900"></a>00900 
<a name="l00901"></a>00901 <span class="keywordtype">void</span> <a class="code" href="group__uhd__group.html#ga83779ae5393f2318b1eb0856f583b637" title="Disables an endpoint or all endpoint of a device.">USBH_HAL_FreePipe</a>(uint8_t Addr, uint8_t bEndpoint)
<a name="l00902"></a>00902 {
<a name="l00903"></a>00903     uint8_t pipe;
<a name="l00904"></a>00904 <span class="preprocessor">#ifdef USB_HOST_HUB_SUPPORT</span>
<a name="l00905"></a>00905 <span class="preprocessor"></span>
<a name="l00906"></a>00906     <span class="keywordflow">if</span> (bEndpoint == 0) {
<a name="l00907"></a>00907         <span class="comment">// Control endpoint does not be unallocated</span>
<a name="l00908"></a>00908 <span class="preprocessor">#error TODO the list address must be updated</span>
<a name="l00909"></a>00909 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (uhd_ctrl_request_timeout
<a name="l00910"></a>00910             &amp;&amp; (uhd_ctrl_request_first-&gt;<a class="code" href="structuhd__ctrl__request__t.html#a4172d80c6e98235ed2d65a16513e3640" title="USB address of control endpoint.">add</a> == Addr)) {
<a name="l00911"></a>00911             <span class="comment">// Disable setup request if on this device</span>
<a name="l00912"></a>00912             USBH_HAL_ControlReqEnd(<a class="code" href="group__uhd__group.html#gga19c67cc9d097b54049dbc7c12119eb83a43222d17d7126cc526f3e96b9e3cb26e" title="Device is disconnected.">UHD_TRANS_DISCONNECT</a>);
<a name="l00913"></a>00913         }
<a name="l00914"></a>00914 
<a name="l00915"></a>00915         <span class="keywordflow">return</span>;
<a name="l00916"></a>00916     }
<a name="l00917"></a>00917 
<a name="l00918"></a>00918 <span class="preprocessor">#endif</span>
<a name="l00919"></a>00919 <span class="preprocessor"></span>
<a name="l00920"></a>00920     <span class="comment">// Search endpoint(s) in all pipes</span>
<a name="l00921"></a>00921     <span class="keywordflow">for</span> (pipe = 0; pipe &lt; USBHS_EPT_NUM; pipe++) {
<a name="l00922"></a>00922         <span class="keywordflow">if</span> (!<a class="code" href="usbhs_8h.html#aca1a73918c77f0aaa82395b55d760ae8" title="Gets USB host interrupt status.">USBHS_IsHostPipeEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe))
<a name="l00923"></a>00923             <span class="keywordflow">continue</span>;
<a name="l00924"></a>00924 
<a name="l00925"></a>00925         <span class="keywordflow">if</span> (Addr != USBHS_HostGetAddr(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe))
<a name="l00926"></a>00926             <span class="keywordflow">continue</span>;
<a name="l00927"></a>00927 
<a name="l00928"></a>00928         <span class="keywordflow">if</span> (bEndpoint != 0xFF) {
<a name="l00929"></a>00929             <span class="comment">// Disable specific endpoint number</span>
<a name="l00930"></a>00930             <span class="keywordflow">if</span> (bEndpoint != USBHS_GetPipeEpAddr(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe)) {
<a name="l00931"></a>00931                 <span class="keywordflow">continue</span>; <span class="comment">// Mismatch</span>
<a name="l00932"></a>00932             }
<a name="l00933"></a>00933         }
<a name="l00934"></a>00934 
<a name="l00935"></a>00935         <span class="comment">// Unalloc pipe</span>
<a name="l00936"></a>00936         <a class="code" href="usbhs_8h.html#a4aabd40a9718b4bab7036aa5439a266f" title="Gets USB host interrupt status.">USBHS_HostPipeDisable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe);
<a name="l00937"></a>00937         <a class="code" href="usbhs_8h.html#a5af3c325c4029dd2830a88dcf6d8d360" title="Gets USB host interrupt status.">USBHS_HostFreeMem</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe);
<a name="l00938"></a>00938 
<a name="l00939"></a>00939         <span class="comment">// Stop transfer on this pipe</span>
<a name="l00940"></a>00940 <span class="preprocessor">#ifndef USB_HOST_HUB_SUPPORT</span>
<a name="l00941"></a>00941 <span class="preprocessor"></span>
<a name="l00942"></a>00942         <span class="keywordflow">if</span> (pipe == 0) {
<a name="l00943"></a>00943             <span class="comment">// Endpoint control</span>
<a name="l00944"></a>00944             <span class="keywordflow">if</span> (uhd_ctrl_request_timeout)
<a name="l00945"></a>00945                 USBH_HAL_ControlReqEnd(<a class="code" href="group__uhd__group.html#gga19c67cc9d097b54049dbc7c12119eb83a43222d17d7126cc526f3e96b9e3cb26e" title="Device is disconnected.">UHD_TRANS_DISCONNECT</a>);
<a name="l00946"></a>00946 
<a name="l00947"></a>00947             <span class="keywordflow">continue</span>;
<a name="l00948"></a>00948         }
<a name="l00949"></a>00949 
<a name="l00950"></a>00950 <span class="preprocessor">#endif</span>
<a name="l00951"></a>00951 <span class="preprocessor"></span>        <span class="comment">// Endpoint interrupt, bulk or isochronous</span>
<a name="l00952"></a>00952         USBH_HAL_PipeAbort(pipe, <a class="code" href="group__uhd__group.html#gga19c67cc9d097b54049dbc7c12119eb83a43222d17d7126cc526f3e96b9e3cb26e" title="Device is disconnected.">UHD_TRANS_DISCONNECT</a>);
<a name="l00953"></a>00953     }
<a name="l00954"></a>00954 }
<a name="l00955"></a>00955 
<a name="l00956"></a>00956 <span class="keywordtype">bool</span> <a class="code" href="group__uhd__group.html#ga11038bdbac3a23c70a7b7f5abcecc8ba" title="Add a setup request in the control endpoint setup queue. Note: Request timeout is 5s...">USBH_HAL_SetupReq</a>(
<a name="l00957"></a>00957     uint8_t Addr,
<a name="l00958"></a>00958     <a class="code" href="struct_u_s_b_generic_request.html">USBGenericRequest</a> *req,
<a name="l00959"></a>00959     uint8_t *payload,
<a name="l00960"></a>00960     uint16_t payload_size,
<a name="l00961"></a>00961     <a class="code" href="group__uhd__group.html#ga96bf6cc1dfc70e9ef06e54f7aa0cd02a" title="Data setup transfer callback function type. Registered by USBH_HAL_SetupReq() Called during DATA phas...">uhd_callback_setup_run_t</a> callback_run,
<a name="l00962"></a>00962     <a class="code" href="group__uhd__group.html#ga48eac59f68de74c0ce604429cb46510e" title="End of setup callback function type. Registered by USBH_HAL_SetupReq() Called when the setup request ...">uhd_callback_setup_end_t</a> callback_end)
<a name="l00963"></a>00963 {
<a name="l00964"></a>00964     irqflags_t flags;
<a name="l00965"></a>00965     <span class="keyword">struct </span><a class="code" href="structuhd__ctrl__request__t.html" title="Structure to store the high level setup request.">uhd_ctrl_request_t</a> *request;
<a name="l00966"></a>00966     <span class="keywordtype">bool</span> b_start_request = <span class="keyword">false</span>;
<a name="l00967"></a>00967 
<a name="l00968"></a>00968     request = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structuhd__ctrl__request__t.html" title="Structure to store the high level setup request.">uhd_ctrl_request_t</a>));
<a name="l00969"></a>00969 
<a name="l00970"></a>00970     <span class="keywordflow">if</span> (request == NULL) {
<a name="l00971"></a>00971         assert(<span class="keyword">false</span>);
<a name="l00972"></a>00972         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00973"></a>00973     }
<a name="l00974"></a>00974 
<a name="l00975"></a>00975     <span class="comment">// Fill structure</span>
<a name="l00976"></a>00976     request-&gt;<a class="code" href="structuhd__ctrl__request__t.html#a4172d80c6e98235ed2d65a16513e3640" title="USB address of control endpoint.">add</a> = (uint8_t) Addr;
<a name="l00977"></a>00977     memcpy(&amp;request-&gt;<a class="code" href="structuhd__ctrl__request__t.html#af533979e39a8f0059a84a9024168faf1" title="Setup request definition.">req</a>, req, <span class="keyword">sizeof</span>(<a class="code" href="struct_u_s_b_generic_request.html">USBGenericRequest</a>));
<a name="l00978"></a>00978     request-&gt;<a class="code" href="structuhd__ctrl__request__t.html#a44aa00d0c9a6f68f208329f0fbbbf214" title="Buffer to store the setup DATA phase.">payload</a> = payload;
<a name="l00979"></a>00979     request-&gt;<a class="code" href="structuhd__ctrl__request__t.html#aab546d1e52187d029085b16b03b2c197" title="Size of buffer used in DATA phase.">payload_size</a> = payload_size;
<a name="l00980"></a>00980     request-&gt;<a class="code" href="structuhd__ctrl__request__t.html#aab515926dcc24785d888351fb22b4952" title="Callback called when buffer is empty or full.">callback_run</a> = callback_run;
<a name="l00981"></a>00981     request-&gt;<a class="code" href="structuhd__ctrl__request__t.html#a499487997bb0cccd2194fcdf0504386f" title="Callback called when request is completed.">callback_end</a> = callback_end;
<a name="l00982"></a>00982     request-&gt;<a class="code" href="structuhd__ctrl__request__t.html#a158d16ea2e48d975b22443a9a4bc20e2" title="Next setup request to process.">next_request</a> = NULL;
<a name="l00983"></a>00983 
<a name="l00984"></a>00984     <span class="comment">// Add this request in the queue</span>
<a name="l00985"></a>00985     flags = cpu_irq_save();
<a name="l00986"></a>00986 
<a name="l00987"></a>00987     <span class="keywordflow">if</span> (uhd_ctrl_request_first == NULL) {
<a name="l00988"></a>00988         uhd_ctrl_request_first = request;
<a name="l00989"></a>00989         b_start_request = <span class="keyword">true</span>;
<a name="l00990"></a>00990     } <span class="keywordflow">else</span>
<a name="l00991"></a>00991         uhd_ctrl_request_last-&gt;<a class="code" href="structuhd__ctrl__request__t.html#a158d16ea2e48d975b22443a9a4bc20e2" title="Next setup request to process.">next_request</a> = request;
<a name="l00992"></a>00992 
<a name="l00993"></a>00993     uhd_ctrl_request_last = request;
<a name="l00994"></a>00994     cpu_irq_restore(flags);
<a name="l00995"></a>00995 
<a name="l00996"></a>00996     <span class="keywordflow">if</span> (b_start_request) {
<a name="l00997"></a>00997         <span class="comment">// Start immediately request</span>
<a name="l00998"></a>00998         USBH_HAL_PhaseControlSetup();
<a name="l00999"></a>00999     }
<a name="l01000"></a>01000 
<a name="l01001"></a>01001     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01002"></a>01002 }
<a name="l01003"></a>01003 
<a name="l01004"></a>01004 <span class="keywordtype">bool</span> <a class="code" href="group__uhd__group.html#ga1d4a9f98194cb255b2fcb6cdf8d83fb8" title="Allows to receive or send data on an endpoint.">USBH_HAL_RunEndpoint</a>(uint8_t Addr,
<a name="l01005"></a>01005                           uint8_t bEndpoint,
<a name="l01006"></a>01006                           <span class="keywordtype">bool</span> b_shortpacket,
<a name="l01007"></a>01007                           uint8_t *buf,
<a name="l01008"></a>01008                           uint32_t buf_size,
<a name="l01009"></a>01009                           uint16_t timeout,
<a name="l01010"></a>01010                           <a class="code" href="group__uhd__group.html#ga750fe064c082c913ac202fe1641648d3" title="End of transfer callback function type. Registered by USBH_HAL_RunEndpoint() Callback called by USB i...">uhd_callback_trans_t</a> callback)
<a name="l01011"></a>01011 {
<a name="l01012"></a>01012     irqflags_t flags;
<a name="l01013"></a>01013     uint8_t pipe;
<a name="l01014"></a>01014     <a class="code" href="struct_u_s_b_h___pipe_job__t.html" title="Structure definition to store registered jobs on a pipe.">USBH_PipeJob_t</a> *pJob;
<a name="l01015"></a>01015 
<a name="l01016"></a>01016     pipe = USBH_HAL_GetPipe(Addr, bEndpoint);
<a name="l01017"></a>01017 
<a name="l01018"></a>01018     <span class="keywordflow">if</span> (pipe == USBHS_EPT_NUM) {
<a name="l01019"></a>01019         <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// pipe not found</span>
<a name="l01020"></a>01020     }
<a name="l01021"></a>01021 
<a name="l01022"></a>01022 <span class="preprocessor">#ifdef UHD_PIPE_FIFO_SUPPORTED</span>
<a name="l01023"></a>01023 <span class="preprocessor"></span>    <span class="keywordtype">bool</span> b_pipe_in = (<a class="code" href="usbhs_8h.html#a7e40c3d1763e18ec62b55c48edadedde" title="Gets USB host interrupt status.">USBHS_HostGetToken</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>,
<a name="l01024"></a>01024                                          pipe) == USBHS_HSTPIPCFG_PTOKEN_IN) ? <span class="keyword">true</span> : <span class="keyword">false</span>;
<a name="l01025"></a>01025 <span class="preprocessor">#endif</span>
<a name="l01026"></a>01026 <span class="preprocessor"></span>
<a name="l01027"></a>01027     <span class="comment">// Get job about pipe</span>
<a name="l01028"></a>01028     pJob = &amp;uhd_pipe_job[pipe - 1];
<a name="l01029"></a>01029     flags = cpu_irq_save();
<a name="l01030"></a>01030 
<a name="l01031"></a>01031     <span class="keywordflow">if</span> (pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a07b75fbf986996a3382967085a7362d0" title="A job is registered on this pipe.">busy</a> == <span class="keyword">true</span>) {
<a name="l01032"></a>01032         cpu_irq_restore(flags);
<a name="l01033"></a>01033         <span class="keywordflow">return</span> <span class="keyword">false</span>;<span class="comment">// Job already on going</span>
<a name="l01034"></a>01034     }
<a name="l01035"></a>01035 
<a name="l01036"></a>01036     pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a07b75fbf986996a3382967085a7362d0" title="A job is registered on this pipe.">busy</a> = <span class="keyword">true</span>;
<a name="l01037"></a>01037 
<a name="l01038"></a>01038     <span class="comment">// No job running. Let&#39;s setup a new one.</span>
<a name="l01039"></a>01039     pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#aecfd98dfe2e19e4fc0e92fa30fee7b2e" title="Buffer located in internal RAM to send or fill during job.">buf</a> = buf;
<a name="l01040"></a>01040     pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a9f7a2c3bfe2d805a5328dae0dd3d6648" title="Size of buffer to send or fill.">buf_size</a> = buf_size;
<a name="l01041"></a>01041     pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#afd8c90263aef338ab94344013a0c8162" title="Total number of transfered data on endpoint.">nb_trans</a> = 0;
<a name="l01042"></a>01042     pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a47c387e93b181e39d8f84bf6c7b8a016" title="timeout on this request (ms)">timeout</a> = timeout;
<a name="l01043"></a>01043     pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a21a69dca8be71be6f87e4809f4c83922" title="A short packet is requested for this job on endpoint IN.">b_shortpacket</a> = b_shortpacket;
<a name="l01044"></a>01044     pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#ac42e3e3067edeba6bbb5831de8270f06" title="Callback to call at the end of transfer.">call_end</a> = callback;
<a name="l01045"></a>01045 
<a name="l01046"></a>01046     <span class="keywordflow">if</span> ((<a class="code" href="usbhs_8h.html#a568fb6f40affb306e060461fe065a516" title="Gets USB host interrupt status.">USBHS_HostGetPipeType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe) &amp; (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga6b03ffb635a9a12458fc316d49bfb18e" title="(USBHS_HSTPIPCFG[10]) Isochronous">USBHS_HSTPIPCFG_PTYPE_ISO</a>
<a name="l01047"></a>01047             | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga01cade33091230dcb050c23aadee6dde" title="(USBHS_HSTPIPCFG[10]) Interrupt">USBHS_HSTPIPCFG_PTYPE_INTRPT</a>))
<a name="l01048"></a>01048         &amp;&amp; (<a class="code" href="usbhs_8h.html#a7e40c3d1763e18ec62b55c48edadedde" title="Gets USB host interrupt status.">USBHS_HostGetToken</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe) == <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga0c650ad1cdbe06feef020ac64286b834" title="(USBHS_HSTPIPCFG[10]) OUT">USBHS_HSTPIPCFG_PTOKEN_OUT</a>))
<a name="l01049"></a>01049         <span class="comment">/*if ((Is_uhd_pipe_int(pipe) || Is_uhd_pipe_iso(pipe))</span>
<a name="l01050"></a>01050 <span class="comment">                &amp;&amp; (Is_uhd_pipe_out(pipe))) */</span>
<a name="l01051"></a>01051         pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a9c7642dff284877f8ebc741157c376e0" title="Periodic packet start for this job.">b_periodic_start</a> = <span class="keyword">true</span>;
<a name="l01052"></a>01052 
<a name="l01053"></a>01053     cpu_irq_restore(flags);
<a name="l01054"></a>01054 
<a name="l01055"></a>01055 <span class="preprocessor">#ifdef UHD_PIPE_FIFO_SUPPORTED</span>
<a name="l01056"></a>01056 <span class="preprocessor"></span>
<a name="l01057"></a>01057     <span class="comment">// No DMA support</span>
<a name="l01058"></a>01058     <span class="keywordflow">if</span> (!<a class="code" href="usbhs_8h.html#adaafe4bea8556d5c5450ea0ccd9c3a5a" title="Get DMA support of endpoints.">Is_uhd_pipe_dma_supported</a>(pipe)) {
<a name="l01059"></a>01059         flags = cpu_irq_save();
<a name="l01060"></a>01060         <a class="code" href="usbhs_8h.html#af33de4a77714a4669ec1d6c52847ce36" title="Gets USB host interrupt status.">USBHS_HostDisableAutoSw</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe);
<a name="l01061"></a>01061         <a class="code" href="usbhs_8h.html#a32c56acaace52b440a308d9bce8cafff" title="Gets USB host interrupt status.">USBHS_HostDisablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga2b99057bec6aa1f5a541cede730c657e" title="(USBHS_HSTPIPIDR[10]) Pipe Freeze Disable">USBHS_HSTPIPIDR_PFREEZEC</a>);
<a name="l01062"></a>01062 
<a name="l01063"></a>01063         <span class="keywordflow">if</span> (b_pipe_in) {
<a name="l01064"></a>01064             <a class="code" href="usbhs_8h.html#a25b8f588492bd5dfd9f527e3cf50d68e" title="Gets USB host interrupt status.">USBHS_HostEnableInReq</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe);
<a name="l01065"></a>01065             <a class="code" href="usbhs_8h.html#acd60bcdb7e5420ac4cfb8b457838f9ba" title="Gets USB host interrupt status.">USBHS_HostEnablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga1ae7fc25e5d572a2e50316b1e72cffd5" title="(USBHS_HSTPIPIER[10]) Received IN Data Interrupt Enable">USBHS_HSTPIPIER_RXINES</a>);
<a name="l01066"></a>01066 
<a name="l01067"></a>01067             <span class="keywordflow">if</span> (b_shortpacket)
<a name="l01068"></a>01068                 <a class="code" href="usbhs_8h.html#acd60bcdb7e5420ac4cfb8b457838f9ba" title="Gets USB host interrupt status.">USBHS_HostEnablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gae40f73ab2d7b4bce022171444427b847" title="(USBHS_HSTPIPIER[10]) Short Packet Interrupt Enable">USBHS_HSTPIPIER_SHORTPACKETIES</a>);
<a name="l01069"></a>01069         } <span class="keywordflow">else</span> {
<a name="l01070"></a>01070             <a class="code" href="usbhs_8h.html#a32c56acaace52b440a308d9bce8cafff" title="Gets USB host interrupt status.">USBHS_HostDisablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gad3bb07d57156a86a6ac3534c0f07c8ab" title="(USBHS_HSTPIPIDR[10]) Number of Busy Banks Disable">USBHS_HSTPIPIDR_NBUSYBKEC</a>);
<a name="l01071"></a>01071             <a class="code" href="usbhs_8h.html#acd60bcdb7e5420ac4cfb8b457838f9ba" title="Gets USB host interrupt status.">USBHS_HostEnablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga5dd1b8ced4705724713f5ec3222c8ee7" title="(USBHS_HSTPIPIER[10]) Transmitted OUT Data Interrupt Enable">USBHS_HSTPIPIER_TXOUTES</a>);
<a name="l01072"></a>01072         }
<a name="l01073"></a>01073 
<a name="l01074"></a>01074         <a class="code" href="usbhs_8h.html#abe033170285572938d1ed3fbb01e9c3e" title="Gets USB host interrupt status.">USBHS_HostPipeIntEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe);
<a name="l01075"></a>01075         cpu_irq_restore(flags);
<a name="l01076"></a>01076         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01077"></a>01077     }
<a name="l01078"></a>01078 
<a name="l01079"></a>01079 <span class="preprocessor">#endif // UHD_PIPE_FIFO_SUPPORTED</span>
<a name="l01080"></a>01080 <span class="preprocessor"></span>
<a name="l01081"></a>01081 <span class="preprocessor">#ifdef UHD_PIPE_DMA_SUPPORTED</span>
<a name="l01082"></a>01082 <span class="preprocessor"></span>    <span class="comment">// Request first transfer</span>
<a name="l01083"></a>01083     USBH_HAL_PipeXfrCmplt(pipe);
<a name="l01084"></a>01084 <span class="preprocessor">#endif</span>
<a name="l01085"></a>01085 <span class="preprocessor"></span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01086"></a>01086 }
<a name="l01087"></a>01087 
<a name="l01088"></a>01088 <span class="keywordtype">void</span> <a class="code" href="group__uhd__group.html#ga410423649d19fc0282fe5012f3455b31" title="Aborts an on-going transfer on an endpoint.">USBH_HAL_AbortEndPoint</a>(uint8_t Addr, uint8_t bEndpoint)
<a name="l01089"></a>01089 {
<a name="l01090"></a>01090     uint8_t pipe;
<a name="l01091"></a>01091 
<a name="l01092"></a>01092     pipe = USBH_HAL_GetPipe(Addr, bEndpoint);
<a name="l01093"></a>01093 
<a name="l01094"></a>01094     <span class="keywordflow">if</span> (pipe == USBHS_EPT_NUM) {
<a name="l01095"></a>01095         <span class="keywordflow">return</span>; <span class="comment">// pipe not found</span>
<a name="l01096"></a>01096     }
<a name="l01097"></a>01097 
<a name="l01098"></a>01098     USBH_HAL_PipeAbort(pipe, <a class="code" href="group__uhd__group.html#gga19c67cc9d097b54049dbc7c12119eb83ad01b0da250552801bd801152b2a8be92" title="Data transmission has been aborted.">UHD_TRANS_ABORTED</a>);
<a name="l01099"></a>01099 }
<a name="l01100"></a>01100 
<a name="l01101"></a>01101 
<a name="l01102"></a>01102 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_DelayedSuspend(<span class="keywordtype">void</span>)
<a name="l01103"></a>01103 {
<a name="l01104"></a>01104     <span class="keyword">volatile</span> uint8_t AsyncInt = (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga3da0cf2e0f5a86423269e347cb1430f8" title="(USBHS_HSTIER) Host Wake-Up Interrupt Enable">USBHS_HSTIER_HWUPIES</a> | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga5bc91aa8af1300eda6c322094655413c" title="(USBHS_HSTIER) Downstream Resume Sent Interrupt Enable">USBHS_HSTIER_RSMEDIES</a>
<a name="l01105"></a>01105                                  | USBHS_HSTIER_RXRSMIES);
<a name="l01106"></a>01106 
<a name="l01107"></a>01107     <span class="keywordflow">if</span> (--uhd_suspend_start == 0) {
<a name="l01108"></a>01108         <span class="comment">// In case of high CPU frequency,</span>
<a name="l01109"></a>01109         <span class="comment">// the current Keep-Alive/SOF can be always on-going</span>
<a name="l01110"></a>01110         <span class="comment">// then wait end of SOF generation</span>
<a name="l01111"></a>01111         <span class="comment">// to be sure that disable SOF has been accepted</span>
<a name="l01112"></a>01112         uint8_t pos =
<a name="l01113"></a>01113             (<a class="code" href="usbhs_8h.html#a23bc7c30ae1779f56b28b82cf5153866" title="Enable or disable USB address.">USBHS_GetUsbSpeed</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>) == USBHS_SR_SPEED_HIGH_SPEED) ?
<a name="l01114"></a>01114             13 : 114;
<a name="l01115"></a>01115 
<a name="l01116"></a>01116         <span class="keywordflow">while</span> (pos &lt; <a class="code" href="usbhs_8h.html#ace4d57215e8268e1e934fa376da56c83" title="Gets USB host interrupt status.">USBHS_HostGetFramePos</a>()) {
<a name="l01117"></a>01117             <span class="keywordflow">if</span> (<a class="code" href="usbhs_8h.html#a40267eb93445cc78fe9b243d25622f9c" title="Gets USB host interrupt status.">USBHS_GetHostStatus</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga9bf0cbe3f438eb0ab5d55527be1666bb" title="(USBHS_HSTISR) Device Disconnection Interrupt">USBHS_HSTISR_DDISCI</a>))
<a name="l01118"></a>01118                 <span class="keywordflow">break</span>;
<a name="l01119"></a>01119         }
<a name="l01120"></a>01120 
<a name="l01121"></a>01121         <a class="code" href="usbhs_8h.html#a8b5061d7281a8104020962d8b6291da1" title="Sets USB host disable the Generation of Start of Frame.">USBHS_DisableSOF</a>();
<a name="l01122"></a>01122 
<a name="l01123"></a>01123         <span class="comment">// When SOF is disabled, the current transmitted packet may</span>
<a name="l01124"></a>01124         <span class="comment">// cause a resume.</span>
<a name="l01125"></a>01125         <span class="comment">// Wait for a while to check this resume status and clear it.</span>
<a name="l01126"></a>01126         <span class="keywordflow">for</span> (pos = 0; pos &lt; 15; pos ++) {
<a name="l01127"></a>01127             memory_barrier();
<a name="l01128"></a>01128 
<a name="l01129"></a>01129             <span class="keywordflow">if</span> (<a class="code" href="usbhs_8h.html#a40267eb93445cc78fe9b243d25622f9c" title="Gets USB host interrupt status.">USBHS_GetHostStatus</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga63908e82e8d8280a53314644efcda9ba" title="(USBHS_HSTICR) Host Wake-Up Interrupt Clear">USBHS_HSTICR_HWUPIC</a>
<a name="l01130"></a>01130                                     | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga0051eb6033ce6b61620c7ef787defcf3" title="(USBHS_HSTICR) Downstream Resume Sent Interrupt Clear">USBHS_HSTICR_RSMEDIC</a>
<a name="l01131"></a>01131                                     | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga566346848e44c880a71dd89abcedd6ce" title="(USBHS_HSTICR) Upstream Resume Received Interrupt Clear">USBHS_HSTICR_RXRSMIC</a>))
<a name="l01132"></a>01132                 <span class="keywordflow">break</span>;
<a name="l01133"></a>01133         }
<a name="l01134"></a>01134 
<a name="l01135"></a>01135 
<a name="l01136"></a>01136         <span class="comment">// Ack previous wakeup and resumes interrupts</span>
<a name="l01137"></a>01137         <a class="code" href="usbhs_8h.html#aab0688b661054b73b5c9fe45e59ea015" title="Gets USB host interrupt status.">USBHS_ClearHostStatus</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga63908e82e8d8280a53314644efcda9ba" title="(USBHS_HSTICR) Host Wake-Up Interrupt Clear">USBHS_HSTICR_HWUPIC</a>
<a name="l01138"></a>01138                                       | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga0051eb6033ce6b61620c7ef787defcf3" title="(USBHS_HSTICR) Downstream Resume Sent Interrupt Clear">USBHS_HSTICR_RSMEDIC</a>
<a name="l01139"></a>01139                                       | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga566346848e44c880a71dd89abcedd6ce" title="(USBHS_HSTICR) Upstream Resume Received Interrupt Clear">USBHS_HSTICR_RXRSMIC</a>));
<a name="l01140"></a>01140 
<a name="l01141"></a>01141         memory_sync();
<a name="l01142"></a>01142         <span class="comment">// Enable wakeup/resumes interrupts</span>
<a name="l01143"></a>01143         <a class="code" href="usbhs_8h.html#a7ac646519dfb6c319d8a60f08b5e4c29" title="Gets USB host interrupt status.">USBHS_HostIntEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, AsyncInt);
<a name="l01144"></a>01144 
<a name="l01145"></a>01145 
<a name="l01146"></a>01146         <a class="code" href="usbhs_8h.html#a07183fee11fbf4c00401b455bdfed9dd" title="Freeze or unfreeze USB clock.">USBHS_FreezeClock</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>);
<a name="l01147"></a>01147         uhd_sleep_mode(UHD_STATE_SUSPEND);
<a name="l01148"></a>01148     }
<a name="l01149"></a>01149 }
<a name="l01150"></a>01150 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_DelayedResume(<span class="keywordtype">void</span>)
<a name="l01151"></a>01151 {
<a name="l01152"></a>01152     uint8_t pipe;
<a name="l01153"></a>01153 
<a name="l01154"></a>01154     <span class="keywordflow">if</span> (--uhd_resume_start == 0) {
<a name="l01155"></a>01155         <span class="comment">// Restore pipes unfreezed</span>
<a name="l01156"></a>01156         <span class="keywordflow">for</span> (pipe = 1; pipe &lt; USBHS_EPT_NUM; pipe++) {
<a name="l01157"></a>01157             <span class="keywordflow">if</span> ((uhd_pipes_unfreeze &gt;&gt; pipe) &amp; 0x01)
<a name="l01158"></a>01158                 <a class="code" href="usbhs_8h.html#a32c56acaace52b440a308d9bce8cafff" title="Gets USB host interrupt status.">USBHS_HostDisablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga2b99057bec6aa1f5a541cede730c657e" title="(USBHS_HSTPIPIDR[10]) Pipe Freeze Disable">USBHS_HSTPIPIDR_PFREEZEC</a>);
<a name="l01159"></a>01159         }
<a name="l01160"></a>01160 
<a name="l01161"></a>01161         <a class="code" href="group___u_s_b_h__group__interne.html#ga8793c42aa4012a8bb24364f4243b4bff" title="Notify that a resume bus occurs A resume can occur after a downstream or an upstream resume...">USBH_notify_resume</a>();
<a name="l01162"></a>01162     }
<a name="l01163"></a>01163 }
<a name="l01164"></a>01164 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_ControlTimeout(<span class="keywordtype">void</span>)
<a name="l01165"></a>01165 {
<a name="l01166"></a>01166     <span class="keywordflow">if</span> (uhd_ctrl_request_timeout) {
<a name="l01167"></a>01167         <span class="comment">// Setup request on-going</span>
<a name="l01168"></a>01168         <span class="keywordflow">if</span> (--uhd_ctrl_request_timeout == 0) {
<a name="l01169"></a>01169             TRACE_WARNING_WP(<span class="stringliteral">&quot;Timeout&quot;</span>);
<a name="l01170"></a>01170             <span class="comment">// Stop request by freezing pipe</span>
<a name="l01171"></a>01171             <a class="code" href="usbhs_8h.html#acd60bcdb7e5420ac4cfb8b457838f9ba" title="Gets USB host interrupt status.">USBHS_HostEnablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga8a09e9f1a8824d9033ebfa3a0570d848" title="(USBHS_HSTPIPIER[10]) Pipe Freeze Enable">USBHS_HSTPIPIER_PFREEZES</a>);
<a name="l01172"></a>01172             USBH_HAL_ControlReqEnd(<a class="code" href="group__uhd__group.html#gga19c67cc9d097b54049dbc7c12119eb83a5c7e1f0526fb0fbc78231246e3cc3d56" title="Data transmission not completed before timeout.">UHD_TRANS_TIMEOUT</a>);
<a name="l01173"></a>01173         }
<a name="l01174"></a>01174     }
<a name="l01175"></a>01175 }
<a name="l01176"></a>01176 <span class="comment"></span>
<a name="l01177"></a>01177 <span class="comment">/**</span>
<a name="l01178"></a>01178 <span class="comment"> * \internal</span>
<a name="l01179"></a>01179 <span class="comment"> * \brief Manages timeouts and actions based on SOF events</span>
<a name="l01180"></a>01180 <span class="comment"> * - Suspend delay</span>
<a name="l01181"></a>01181 <span class="comment"> * - Resume delay</span>
<a name="l01182"></a>01182 <span class="comment"> * - Setup packet delay</span>
<a name="l01183"></a>01183 <span class="comment"> * - Timeout on endpoint control transfer</span>
<a name="l01184"></a>01184 <span class="comment"> * - Timeouts on bulk/interrupt/isochronous endpoint transfers</span>
<a name="l01185"></a>01185 <span class="comment"> * - UHC user notification</span>
<a name="l01186"></a>01186 <span class="comment"> * - SOF user notification</span>
<a name="l01187"></a>01187 <span class="comment"> */</span>
<a name="l01188"></a>01188 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_ManageSof(<span class="keywordtype">void</span>)
<a name="l01189"></a>01189 {
<a name="l01190"></a>01190     <span class="comment">//  USBHS_HostAckPipeIntType(USBHS, USBHS_HSTICR_HSOFIC);</span>
<a name="l01191"></a>01191     uint8_t pipe;
<a name="l01192"></a>01192 
<a name="l01193"></a>01193     <span class="comment">// Manage the micro SOF</span>
<a name="l01194"></a>01194     <span class="keywordflow">if</span> (<a class="code" href="usbhs_8h.html#a3a003f0bc5f5ed08ba3253028bd04923" title="Enable or disable USB address.">USBHS_IsUsbHighSpeed</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>)) {
<a name="l01195"></a>01195         <span class="keyword">static</span> uint8_t msof_cpt = 0;
<a name="l01196"></a>01196 
<a name="l01197"></a>01197         <span class="keywordflow">if</span> (++msof_cpt % 8) {
<a name="l01198"></a>01198             <span class="comment">// It is a micro SOF</span>
<a name="l01199"></a>01199             <span class="keywordflow">if</span> (!uhd_suspend_start &amp;&amp; !uhd_resume_start) {
<a name="l01200"></a>01200                 <span class="comment">// If no resume and no suspend on going</span>
<a name="l01201"></a>01201                 <span class="comment">// then send Micro start of frame event (each 125?)</span>
<a name="l01202"></a>01202                 <a class="code" href="group___u_s_b_h__group__interne.html#gac60ed6b8615775ae9b773432d4ee8828" title="Notify each start of frame sent by driver.">USBH_notify_sof</a>(<span class="keyword">true</span>);
<a name="l01203"></a>01203             }
<a name="l01204"></a>01204 
<a name="l01205"></a>01205             <span class="keywordflow">return</span>;
<a name="l01206"></a>01206         }
<a name="l01207"></a>01207     }
<a name="l01208"></a>01208 
<a name="l01209"></a>01209     <span class="comment">// Manage a delay to enter in suspend</span>
<a name="l01210"></a>01210     <span class="keywordflow">if</span> (uhd_suspend_start) {
<a name="l01211"></a>01211         USBH_HAL_DelayedSuspend();
<a name="l01212"></a>01212         <span class="keywordflow">return</span>; <span class="comment">// Abort SOF events</span>
<a name="l01213"></a>01213     }
<a name="l01214"></a>01214 
<a name="l01215"></a>01215     <span class="comment">// Manage a delay to exit of suspend</span>
<a name="l01216"></a>01216     <span class="keywordflow">if</span> (uhd_resume_start) {
<a name="l01217"></a>01217         USBH_HAL_DelayedResume();
<a name="l01218"></a>01218         <span class="keywordflow">return</span>; <span class="comment">// Abort SOF events</span>
<a name="l01219"></a>01219     }
<a name="l01220"></a>01220 
<a name="l01221"></a>01221     <span class="comment">// Manage the timeout on endpoint control transfer</span>
<a name="l01222"></a>01222     USBH_HAL_ControlTimeout();
<a name="l01223"></a>01223 
<a name="l01224"></a>01224     <span class="comment">// Manage the timeouts on endpoint transfer</span>
<a name="l01225"></a>01225     <a class="code" href="struct_u_s_b_h___pipe_job__t.html" title="Structure definition to store registered jobs on a pipe.">USBH_PipeJob_t</a> *pJob;
<a name="l01226"></a>01226 
<a name="l01227"></a>01227     <span class="keywordflow">for</span> (pipe = 1; pipe &lt; USBHS_EPT_NUM; pipe++) {
<a name="l01228"></a>01228         pJob = &amp;uhd_pipe_job[pipe - 1];
<a name="l01229"></a>01229 
<a name="l01230"></a>01230         <span class="keywordflow">if</span> (pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a07b75fbf986996a3382967085a7362d0" title="A job is registered on this pipe.">busy</a> == <span class="keyword">true</span>) {
<a name="l01231"></a>01231             <span class="keywordflow">if</span> (pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a47c387e93b181e39d8f84bf6c7b8a016" title="timeout on this request (ms)">timeout</a>) {
<a name="l01232"></a>01232                 <span class="comment">// Timeout enabled on this job</span>
<a name="l01233"></a>01233                 <span class="keywordflow">if</span> (--(pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a47c387e93b181e39d8f84bf6c7b8a016" title="timeout on this request (ms)">timeout</a>) == 0) {
<a name="l01234"></a>01234                     <span class="comment">// Abort job</span>
<a name="l01235"></a>01235                     USBH_HAL_PipeAbort(pipe, <a class="code" href="group__uhd__group.html#gga19c67cc9d097b54049dbc7c12119eb83a5c7e1f0526fb0fbc78231246e3cc3d56" title="Data transmission not completed before timeout.">UHD_TRANS_TIMEOUT</a>);
<a name="l01236"></a>01236                 }
<a name="l01237"></a>01237             }
<a name="l01238"></a>01238 
<a name="l01239"></a>01239             <span class="keywordflow">if</span> (pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a9c7642dff284877f8ebc741157c376e0" title="Periodic packet start for this job.">b_periodic_start</a>) {
<a name="l01240"></a>01240                 pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a9c7642dff284877f8ebc741157c376e0" title="Periodic packet start for this job.">b_periodic_start</a> = <span class="keyword">false</span>;
<a name="l01241"></a>01241                 <a class="code" href="usbhs_8h.html#a32c56acaace52b440a308d9bce8cafff" title="Gets USB host interrupt status.">USBHS_HostDisablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga2b99057bec6aa1f5a541cede730c657e" title="(USBHS_HSTPIPIDR[10]) Pipe Freeze Disable">USBHS_HSTPIPIDR_PFREEZEC</a>);
<a name="l01242"></a>01242             }
<a name="l01243"></a>01243         }
<a name="l01244"></a>01244     }
<a name="l01245"></a>01245 
<a name="l01246"></a>01246     <span class="comment">// Notify the UHC</span>
<a name="l01247"></a>01247     <a class="code" href="group___u_s_b_h__group__interne.html#gac60ed6b8615775ae9b773432d4ee8828" title="Notify each start of frame sent by driver.">USBH_notify_sof</a>(<span class="keyword">false</span>);
<a name="l01248"></a>01248 
<a name="l01249"></a>01249     <span class="comment">// Notify the user application</span>
<a name="l01250"></a>01250     UHC_SOF_EVENT();
<a name="l01251"></a>01251     memory_sync();
<a name="l01252"></a>01252 }
<a name="l01253"></a>01253 <span class="comment"></span>
<a name="l01254"></a>01254 <span class="comment">/**</span>
<a name="l01255"></a>01255 <span class="comment"> * \internal</span>
<a name="l01256"></a>01256 <span class="comment"> * \brief Manages the events related to control endpoint</span>
<a name="l01257"></a>01257 <span class="comment"> */</span>
<a name="l01258"></a>01258 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_ControlInterrupt(<span class="keywordtype">void</span>)
<a name="l01259"></a>01259 {
<a name="l01260"></a>01260     <span class="comment">// A setup request is on-going</span>
<a name="l01261"></a>01261     assert(uhd_ctrl_request_timeout != 0);
<a name="l01262"></a>01262 
<a name="l01263"></a>01263     <span class="comment">// Disable setup, IN and OUT interrupts of control endpoint</span>
<a name="l01264"></a>01264     <a class="code" href="usbhs_8h.html#a32c56acaace52b440a308d9bce8cafff" title="Gets USB host interrupt status.">USBHS_HostDisablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0, (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga0c871429344a461a4e56354ffe4f699f" title="(USBHS_HSTPIPIDR[10]) Transmitted SETUP Interrupt Disable">USBHS_HSTPIPIDR_TXSTPEC</a>
<a name="l01265"></a>01265                                             | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga0d08723be4a935ed53c94f9d7f6d24a0" title="(USBHS_HSTPIPIDR[10]) Received IN Data Interrupt Disable">USBHS_HSTPIPIDR_RXINEC</a>
<a name="l01266"></a>01266                                             | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga19293155d73146950142d5284d73b490" title="(USBHS_HSTPIPIDR[10]) Transmitted OUT Data Interrupt Disable">USBHS_HSTPIPIDR_TXOUTEC</a>) );
<a name="l01267"></a>01267 
<a name="l01268"></a>01268     <span class="comment">// Search event on control endpoint</span>
<a name="l01269"></a>01269     <span class="keywordflow">if</span> (<a class="code" href="usbhs_8h.html#ae752afec4dfecc9565eaa4242ce9233f" title="Gets USB host interrupt status.">USBHS_HostGetIntTypeStatus</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga5b657f7ffb9144716c472b4873838612" title="(USBHS_HSTPIPISR[10]) Transmitted SETUP Interrupt">USBHS_HSTPIPISR_TXSTPI</a>) ) {
<a name="l01270"></a>01270         <span class="comment">// SETUP packet sent</span>
<a name="l01271"></a>01271         <a class="code" href="usbhs_8h.html#acd60bcdb7e5420ac4cfb8b457838f9ba" title="Gets USB host interrupt status.">USBHS_HostEnablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga8a09e9f1a8824d9033ebfa3a0570d848" title="(USBHS_HSTPIPIER[10]) Pipe Freeze Enable">USBHS_HSTPIPIER_PFREEZES</a>);
<a name="l01272"></a>01272         <a class="code" href="usbhs_8h.html#a97e601451758556ee0591fae627974d8" title="Gets USB host interrupt status.">USBHS_HostAckPipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga5c8293d760ef53097d408ae75d6946d2" title="(USBHS_HSTPIPICR[10]) Transmitted SETUP Interrupt Clear">USBHS_HSTPIPICR_TXSTPIC</a>);
<a name="l01273"></a>01273         assert(uhd_ctrl_request_phase == <a class="code" href="group__uhd__group.html#ggab5c14d3e2e40e55761ffe45496ae5427a4d58c9d6d4a100fafb7a2c99304ef274" title="Wait a SETUP packet.">UHD_CTRL_REQ_PHASE_SETUP</a>);
<a name="l01274"></a>01274 
<a name="l01275"></a>01275         <span class="comment">// Start DATA phase</span>
<a name="l01276"></a>01276         <span class="keywordflow">if</span> ((uhd_ctrl_request_first-&gt;<a class="code" href="structuhd__ctrl__request__t.html#af533979e39a8f0059a84a9024168faf1" title="Setup request definition.">req</a>.<a class="code" href="struct_u_s_b_generic_request.html#ac2c8db66413636cf8fe6a43be55a5c67">bmRequestType</a> &amp; <a class="code" href="group__usb__descriptor.html#gac94f5ec9106e17f2e6d927eeac3d530f" title="Mask.">USB_REQ_DIR_MASK</a>)
<a name="l01277"></a>01277             == <a class="code" href="group__usb__descriptor.html#ga3d3c24265f68a720887ae4ff7158d605" title="Device to host.">USB_REQ_DIR_IN</a>)
<a name="l01278"></a>01278             USBH_HAL_PhaseDataInStart();
<a name="l01279"></a>01279         <span class="keywordflow">else</span> {
<a name="l01280"></a>01280             <span class="keywordflow">if</span> (uhd_ctrl_request_first-&gt;<a class="code" href="structuhd__ctrl__request__t.html#af533979e39a8f0059a84a9024168faf1" title="Setup request definition.">req</a>.<a class="code" href="struct_u_s_b_generic_request.html#a5c6f6461bdcbe9ebe6fa40e88f76e94e">wLength</a>)
<a name="l01281"></a>01281                 USBH_HAL_PhaseDataOut();
<a name="l01282"></a>01282             <span class="keywordflow">else</span> {
<a name="l01283"></a>01283                 <span class="comment">// No DATA phase</span>
<a name="l01284"></a>01284                 USBH_HAL_InZLP();
<a name="l01285"></a>01285             }
<a name="l01286"></a>01286         }
<a name="l01287"></a>01287 
<a name="l01288"></a>01288         <span class="keywordflow">return</span>;
<a name="l01289"></a>01289     }
<a name="l01290"></a>01290 
<a name="l01291"></a>01291     <span class="keywordflow">if</span> (<a class="code" href="usbhs_8h.html#ae752afec4dfecc9565eaa4242ce9233f" title="Gets USB host interrupt status.">USBHS_HostGetIntTypeStatus</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gabd4bff53529d3a63d2f2a6b288ea4404" title="(USBHS_HSTPIPISR[10]) Received IN Data Interrupt">USBHS_HSTPIPISR_RXINI</a>)) {
<a name="l01292"></a>01292         <span class="comment">// In case of low USB speed and with a high CPU frequency,</span>
<a name="l01293"></a>01293         <span class="comment">// a ACK from host can be always running on USB line</span>
<a name="l01294"></a>01294         <span class="comment">// then wait end of ACK on IN pipe.</span>
<a name="l01295"></a>01295         <span class="keywordflow">while</span> (!<a class="code" href="usbhs_8h.html#a0a8e28b882f4abf73c473980d36c7e06" title="Gets USB host interrupt status.">USBHS_IsHostPipeIntTypeEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga7c445ad9e88f7bd07fa360f3ee17acbe" title="(USBHS_HSTPIPIMR[10]) Pipe Freeze">USBHS_HSTPIPIMR_PFREEZE</a>));
<a name="l01296"></a>01296 
<a name="l01297"></a>01297         <span class="comment">// IN packet received, Acknowledge</span>
<a name="l01298"></a>01298         <a class="code" href="usbhs_8h.html#a97e601451758556ee0591fae627974d8" title="Gets USB host interrupt status.">USBHS_HostAckPipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga9067ea47ec30664e8fd73e8ab7e35181" title="(USBHS_HSTPIPICR[10]) Received IN Data Interrupt Clear">USBHS_HSTPIPICR_RXINIC</a>);
<a name="l01299"></a>01299 
<a name="l01300"></a>01300         <span class="keywordflow">switch</span> (uhd_ctrl_request_phase) {
<a name="l01301"></a>01301         <span class="keywordflow">case</span> <a class="code" href="group__uhd__group.html#ggab5c14d3e2e40e55761ffe45496ae5427adad9d075f8a169516efd6b29961612a5" title="Wait a IN data packet.">UHD_CTRL_REQ_PHASE_DATA_IN</a>:
<a name="l01302"></a>01302             USBH_HAL_PhaseDataIn();
<a name="l01303"></a>01303             <span class="keywordflow">break</span>;
<a name="l01304"></a>01304 
<a name="l01305"></a>01305         <span class="keywordflow">case</span> <a class="code" href="group__uhd__group.html#ggab5c14d3e2e40e55761ffe45496ae5427acb0a9b7a084121f4ff48cd53ad76842a" title="Wait a IN ZLP packet.">UHD_CTRL_REQ_PHASE_ZLP_IN</a>:
<a name="l01306"></a>01306             USBH_HAL_ControlReqEnd(<a class="code" href="group__uhd__group.html#gga19c67cc9d097b54049dbc7c12119eb83a51f2cf9245d0e0d3e7b421c9e6b301b8" title="Transaction is successful.">UHD_TRANS_NOERROR</a>);
<a name="l01307"></a>01307             <span class="keywordflow">break</span>;
<a name="l01308"></a>01308 
<a name="l01309"></a>01309         <span class="keywordflow">default</span>:
<a name="l01310"></a>01310             assert(<span class="keyword">false</span>);
<a name="l01311"></a>01311             <span class="keywordflow">break</span>;
<a name="l01312"></a>01312         }
<a name="l01313"></a>01313 
<a name="l01314"></a>01314         <span class="keywordflow">return</span>;
<a name="l01315"></a>01315     }
<a name="l01316"></a>01316 
<a name="l01317"></a>01317     <span class="keywordflow">if</span> (<a class="code" href="usbhs_8h.html#ae752afec4dfecc9565eaa4242ce9233f" title="Gets USB host interrupt status.">USBHS_HostGetIntTypeStatus</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gab412d773f75086777987bce75d9c2c79" title="(USBHS_HSTPIPISR[10]) Transmitted OUT Data Interrupt">USBHS_HSTPIPISR_TXOUTI</a>)) {
<a name="l01318"></a>01318         <span class="comment">// OUT packet sent</span>
<a name="l01319"></a>01319         <a class="code" href="usbhs_8h.html#acd60bcdb7e5420ac4cfb8b457838f9ba" title="Gets USB host interrupt status.">USBHS_HostEnablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga8a09e9f1a8824d9033ebfa3a0570d848" title="(USBHS_HSTPIPIER[10]) Pipe Freeze Enable">USBHS_HSTPIPIER_PFREEZES</a>);
<a name="l01320"></a>01320         <a class="code" href="usbhs_8h.html#a97e601451758556ee0591fae627974d8" title="Gets USB host interrupt status.">USBHS_HostAckPipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga0dee7d148bee9d67b2d3f846b2d642b3" title="(USBHS_HSTPIPICR[10]) Transmitted OUT Data Interrupt Clear">USBHS_HSTPIPICR_TXOUTIC</a>);
<a name="l01321"></a>01321 
<a name="l01322"></a>01322         <span class="keywordflow">switch</span> (uhd_ctrl_request_phase) {
<a name="l01323"></a>01323         <span class="keywordflow">case</span> <a class="code" href="group__uhd__group.html#ggab5c14d3e2e40e55761ffe45496ae5427aab15b28a6a920b07a0cc82de1d0c414a" title="Wait a OUT data packet.">UHD_CTRL_REQ_PHASE_DATA_OUT</a>:
<a name="l01324"></a>01324             USBH_HAL_PhaseDataOut();
<a name="l01325"></a>01325             <span class="keywordflow">break</span>;
<a name="l01326"></a>01326 
<a name="l01327"></a>01327         <span class="keywordflow">case</span> <a class="code" href="group__uhd__group.html#ggab5c14d3e2e40e55761ffe45496ae5427a62b5126d713b2ed56894a6899fda885e" title="Wait a OUT ZLP packet.">UHD_CTRL_REQ_PHASE_ZLP_OUT</a>:
<a name="l01328"></a>01328             USBH_HAL_ControlReqEnd(<a class="code" href="group__uhd__group.html#gga19c67cc9d097b54049dbc7c12119eb83a51f2cf9245d0e0d3e7b421c9e6b301b8" title="Transaction is successful.">UHD_TRANS_NOERROR</a>);
<a name="l01329"></a>01329             <span class="keywordflow">break</span>;
<a name="l01330"></a>01330 
<a name="l01331"></a>01331         <span class="keywordflow">default</span>:
<a name="l01332"></a>01332             assert(<span class="keyword">false</span>);
<a name="l01333"></a>01333             <span class="keywordflow">break</span>;
<a name="l01334"></a>01334         }
<a name="l01335"></a>01335 
<a name="l01336"></a>01336         <span class="keywordflow">return</span>;
<a name="l01337"></a>01337     }
<a name="l01338"></a>01338 
<a name="l01339"></a>01339     <span class="keywordflow">if</span> (<a class="code" href="usbhs_8h.html#ae752afec4dfecc9565eaa4242ce9233f" title="Gets USB host interrupt status.">USBHS_HostGetIntTypeStatus</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga49bab8fafde4c709dd7decb1c97b0503" title="(USBHS_HSTPIPISR[10]) Received STALLed Interrupt">USBHS_HSTPIPISR_RXSTALLDI</a>)) {
<a name="l01340"></a>01340         <span class="comment">// Stall Handshake received</span>
<a name="l01341"></a>01341         <a class="code" href="usbhs_8h.html#a97e601451758556ee0591fae627974d8" title="Gets USB host interrupt status.">USBHS_HostAckPipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gaae263c0a5e8d2cd8c473fe9219cc66a8" title="(USBHS_HSTPIPICR[10]) Received STALLed Interrupt Clear">USBHS_HSTPIPICR_RXSTALLDIC</a>);
<a name="l01342"></a>01342         USBH_HAL_ControlReqEnd(<a class="code" href="group__uhd__group.html#gga19c67cc9d097b54049dbc7c12119eb83a5743eea90e7ad818b4c29ff54cfc67a9" title="The endpoint returned a STALL PID.">UHD_TRANS_STALL</a>);
<a name="l01343"></a>01343         <span class="keywordflow">return</span>;
<a name="l01344"></a>01344     }
<a name="l01345"></a>01345 
<a name="l01346"></a>01346     <span class="keywordflow">if</span> (<a class="code" href="usbhs_8h.html#ae752afec4dfecc9565eaa4242ce9233f" title="Gets USB host interrupt status.">USBHS_HostGetIntTypeStatus</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga73998e12ffdfca1ab0bc9cf53797332c" title="(USBHS_HSTPIPISR[10]) Pipe Error Interrupt">USBHS_HSTPIPISR_PERRI</a>)) {
<a name="l01347"></a>01347         <span class="comment">// Get and ack error</span>
<a name="l01348"></a>01348         USBH_HAL_ControlReqEnd(USBH_HAL_GetPipeError(0));
<a name="l01349"></a>01349         printf(<span class="stringliteral">&quot;Control pipe error \n\r&quot;</span>);
<a name="l01350"></a>01350         <span class="keywordflow">return</span>;
<a name="l01351"></a>01351     }
<a name="l01352"></a>01352 
<a name="l01353"></a>01353     memory_sync();
<a name="l01354"></a>01354     assert(<span class="keyword">false</span>); <span class="comment">// Error system</span>
<a name="l01355"></a>01355 }
<a name="l01356"></a>01356 <span class="comment"></span>
<a name="l01357"></a>01357 <span class="comment">/**</span>
<a name="l01358"></a>01358 <span class="comment"> * \internal</span>
<a name="l01359"></a>01359 <span class="comment"> * \brief Sends a USB setup packet to start a control request sequence</span>
<a name="l01360"></a>01360 <span class="comment"> */</span>
<a name="l01361"></a>01361 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_PhaseControlSetup(<span class="keywordtype">void</span>)
<a name="l01362"></a>01362 {
<a name="l01363"></a>01363     <span class="keyword">union </span>{
<a name="l01364"></a>01364         <span class="keyword">volatile</span> uint64_t value64;
<a name="l01365"></a>01365         <a class="code" href="struct_u_s_b_generic_request.html">USBGenericRequest</a> req;
<a name="l01366"></a>01366     } setup;
<a name="l01367"></a>01367     <span class="keyword">volatile</span> uint64_t *pEpData;
<a name="l01368"></a>01368 
<a name="l01369"></a>01369     uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_SETUP;
<a name="l01370"></a>01370     memcpy(&amp;setup.req, &amp;uhd_ctrl_request_first-&gt;<a class="code" href="structuhd__ctrl__request__t.html#af533979e39a8f0059a84a9024168faf1" title="Setup request definition.">req</a>, <span class="keyword">sizeof</span>(<a class="code" href="struct_u_s_b_generic_request.html">USBGenericRequest</a>));
<a name="l01371"></a>01371     memory_sync();
<a name="l01372"></a>01372 
<a name="l01373"></a>01373     uhd_ctrl_nb_trans = 0;
<a name="l01374"></a>01374 
<a name="l01375"></a>01375     <span class="comment">// Check pipe</span>
<a name="l01376"></a>01376 <span class="preprocessor">#ifdef USB_HOST_HUB_SUPPORT</span>
<a name="l01377"></a>01377 <span class="preprocessor"></span>
<a name="l01378"></a>01378     <span class="keywordflow">if</span> (!<a class="code" href="usbhs_8h.html#aca1a73918c77f0aaa82395b55d760ae8" title="Gets USB host interrupt status.">USBHS_IsHostPipeEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0)) {
<a name="l01379"></a>01379         USBH_HAL_ControlReqEnd(<a class="code" href="group__uhd__group.html#gga19c67cc9d097b54049dbc7c12119eb83a43222d17d7126cc526f3e96b9e3cb26e" title="Device is disconnected.">UHD_TRANS_DISCONNECT</a>);
<a name="l01380"></a>01380         <span class="keywordflow">return</span>; <span class="comment">// Endpoint not valid</span>
<a name="l01381"></a>01381     }
<a name="l01382"></a>01382 
<a name="l01383"></a>01383 <span class="preprocessor">#error TODO check address in list</span>
<a name="l01384"></a>01384 <span class="preprocessor"></span>    <span class="comment">// Reconfigure USB address of pipe 0 used for all control endpoints</span>
<a name="l01385"></a>01385     uhd_configure_address(0, uhd_ctrl_request_first-&gt;<a class="code" href="structuhd__ctrl__request__t.html#a4172d80c6e98235ed2d65a16513e3640" title="USB address of control endpoint.">add</a>);
<a name="l01386"></a>01386 <span class="preprocessor">#else</span>
<a name="l01387"></a>01387 <span class="preprocessor"></span>
<a name="l01388"></a>01388     <span class="keywordflow">if</span> (!<a class="code" href="usbhs_8h.html#aca1a73918c77f0aaa82395b55d760ae8" title="Gets USB host interrupt status.">USBHS_IsHostPipeEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0) ||
<a name="l01389"></a>01389         (uhd_ctrl_request_first-&gt;<a class="code" href="structuhd__ctrl__request__t.html#a4172d80c6e98235ed2d65a16513e3640" title="USB address of control endpoint.">add</a> != USBHS_HostGetAddr(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0))) {
<a name="l01390"></a>01390         USBH_HAL_ControlReqEnd(<a class="code" href="group__uhd__group.html#gga19c67cc9d097b54049dbc7c12119eb83a43222d17d7126cc526f3e96b9e3cb26e" title="Device is disconnected.">UHD_TRANS_DISCONNECT</a>);
<a name="l01391"></a>01391         <span class="keywordflow">return</span>; <span class="comment">// Endpoint not valid</span>
<a name="l01392"></a>01392     }
<a name="l01393"></a>01393 
<a name="l01394"></a>01394 <span class="preprocessor">#endif</span>
<a name="l01395"></a>01395 <span class="preprocessor"></span>
<a name="l01396"></a>01396     <span class="comment">// Fill pipe</span>
<a name="l01397"></a>01397     <a class="code" href="usbhs_8h.html#a48f3b4774877abb73ad633b904e4caee" title="Gets USB host interrupt status.">USBHS_HostSetToken</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga13977671c7a6080fe0a24e1fa20b55b2" title="(USBHS_HSTPIPCFG[10]) SETUP">USBHS_HSTPIPCFG_PTOKEN_SETUP</a>);
<a name="l01398"></a>01398     <a class="code" href="usbhs_8h.html#a97e601451758556ee0591fae627974d8" title="Gets USB host interrupt status.">USBHS_HostAckPipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga5c8293d760ef53097d408ae75d6946d2" title="(USBHS_HSTPIPICR[10]) Transmitted SETUP Interrupt Clear">USBHS_HSTPIPICR_TXSTPIC</a>);
<a name="l01399"></a>01399     assert(<span class="keyword">sizeof</span>(setup) == <span class="keyword">sizeof</span>(uint64_t));
<a name="l01400"></a>01400 
<a name="l01401"></a>01401     pEpData = (<span class="keyword">volatile</span> uint64_t *)<a class="code" href="group___s_a_m_e70_q21__definitions.html#ga509eeb3745bd4057d342dd132dd2cecf">USBHS_RAM_ADDR</a>;
<a name="l01402"></a>01402     memory_sync();
<a name="l01403"></a>01403     *pEpData = setup.value64;
<a name="l01404"></a>01404     memory_barrier();
<a name="l01405"></a>01405 
<a name="l01406"></a>01406     uhd_ctrl_request_timeout = 5000;
<a name="l01407"></a>01407     <a class="code" href="usbhs_8h.html#acd60bcdb7e5420ac4cfb8b457838f9ba" title="Gets USB host interrupt status.">USBHS_HostEnablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gadcd0d2d010e615f198d7e3a6913290d0" title="(USBHS_HSTPIPIER[10]) Transmitted SETUP Interrupt Enable">USBHS_HSTPIPIER_TXSTPES</a>);
<a name="l01408"></a>01408     <span class="comment">// Acknowledge FIFO control and unfreeze Pipe</span>
<a name="l01409"></a>01409     <a class="code" href="usbhs_8h.html#a32c56acaace52b440a308d9bce8cafff" title="Gets USB host interrupt status.">USBHS_HostDisablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0,
<a name="l01410"></a>01410                                  (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gabcec9beefeab1700242da4c88f1b7a51" title="(USBHS_HSTPIPIDR[10]) FIFO Control Disable">USBHS_HSTPIPIDR_FIFOCONC</a> | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga2b99057bec6aa1f5a541cede730c657e" title="(USBHS_HSTPIPIDR[10]) Pipe Freeze Disable">USBHS_HSTPIPIDR_PFREEZEC</a>));
<a name="l01411"></a>01411 
<a name="l01412"></a>01412 }
<a name="l01413"></a>01413 <span class="comment"></span>
<a name="l01414"></a>01414 <span class="comment">/**</span>
<a name="l01415"></a>01415 <span class="comment"> * \internal</span>
<a name="l01416"></a>01416 <span class="comment"> * \brief Starts the DATA IN phase on control endpoint</span>
<a name="l01417"></a>01417 <span class="comment"> */</span>
<a name="l01418"></a>01418 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_PhaseDataInStart(<span class="keywordtype">void</span>)
<a name="l01419"></a>01419 {
<a name="l01420"></a>01420     uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_DATA_IN;
<a name="l01421"></a>01421     <span class="comment">// set pipe token</span>
<a name="l01422"></a>01422     <a class="code" href="usbhs_8h.html#a48f3b4774877abb73ad633b904e4caee" title="Gets USB host interrupt status.">USBHS_HostSetToken</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga05aed341b46e5deb78532b4e66ad3170" title="(USBHS_HSTPIPCFG[10]) IN">USBHS_HSTPIPCFG_PTOKEN_IN</a>);
<a name="l01423"></a>01423     <span class="comment">// Ack In and Short packet</span>
<a name="l01424"></a>01424     <a class="code" href="usbhs_8h.html#a97e601451758556ee0591fae627974d8" title="Gets USB host interrupt status.">USBHS_HostAckPipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0,
<a name="l01425"></a>01425                              (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga9067ea47ec30664e8fd73e8ab7e35181" title="(USBHS_HSTPIPICR[10]) Received IN Data Interrupt Clear">USBHS_HSTPIPICR_RXINIC</a> | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga78cb30399ab291612e71d221afe83b74" title="(USBHS_HSTPIPICR[10]) Short Packet Interrupt Clear">USBHS_HSTPIPICR_SHORTPACKETIC</a>) );
<a name="l01426"></a>01426 
<a name="l01427"></a>01427     <a class="code" href="usbhs_8h.html#acd60bcdb7e5420ac4cfb8b457838f9ba" title="Gets USB host interrupt status.">USBHS_HostEnablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga1ae7fc25e5d572a2e50316b1e72cffd5" title="(USBHS_HSTPIPIER[10]) Received IN Data Interrupt Enable">USBHS_HSTPIPIER_RXINES</a>);
<a name="l01428"></a>01428     <span class="comment">// Acknowledge FIFO control and unfreeze Pipe</span>
<a name="l01429"></a>01429     <a class="code" href="usbhs_8h.html#a32c56acaace52b440a308d9bce8cafff" title="Gets USB host interrupt status.">USBHS_HostDisablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0,
<a name="l01430"></a>01430                                  (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gabcec9beefeab1700242da4c88f1b7a51" title="(USBHS_HSTPIPIDR[10]) FIFO Control Disable">USBHS_HSTPIPIDR_FIFOCONC</a> | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga2b99057bec6aa1f5a541cede730c657e" title="(USBHS_HSTPIPIDR[10]) Pipe Freeze Disable">USBHS_HSTPIPIDR_PFREEZEC</a>) );
<a name="l01431"></a>01431 
<a name="l01432"></a>01432     memory_sync();
<a name="l01433"></a>01433 }
<a name="l01434"></a>01434 <span class="comment"></span>
<a name="l01435"></a>01435 <span class="comment">/**</span>
<a name="l01436"></a>01436 <span class="comment"> * \internal</span>
<a name="l01437"></a>01437 <span class="comment"> * \brief Manages the DATA IN phase on control endpoint</span>
<a name="l01438"></a>01438 <span class="comment"> */</span>
<a name="l01439"></a>01439 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_PhaseDataIn(<span class="keywordtype">void</span>)
<a name="l01440"></a>01440 {
<a name="l01441"></a>01441     <span class="keywordtype">bool</span> b_short_packet;
<a name="l01442"></a>01442     uint8_t *pEpData;
<a name="l01443"></a>01443     uint8_t bPipe = 0;
<a name="l01444"></a>01444     uint8_t nb_byte_received;
<a name="l01445"></a>01445 
<a name="l01446"></a>01446     <span class="comment">// Get information to read data</span>
<a name="l01447"></a>01447     nb_byte_received = <a class="code" href="usbhs_8h.html#a917ce318855654bd4d1ff18a24248899" title="Gets USB host interrupt status.">USBHS_HostGetPipeByteCount</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, bPipe);
<a name="l01448"></a>01448 <span class="preprocessor">#ifdef USB_HOST_HUB_SUPPORT</span>
<a name="l01449"></a>01449 <span class="preprocessor"></span><span class="comment">    //! In HUB mode, the control pipe is always configured to 64B</span>
<a name="l01450"></a>01450 <span class="comment"></span><span class="comment">    //! thus the short packet flag must be computed</span>
<a name="l01451"></a>01451 <span class="comment"></span>    b_short_packet = (nb_byte_received != <a class="code" href="usbhs_8h.html#ac13debb9eb4e51de70e9086d6264ee88" title="Gets USB host interrupt status.">USBHS_HostGetSize</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0));
<a name="l01452"></a>01452     <a class="code" href="usbhs_8h.html#a97e601451758556ee0591fae627974d8" title="Gets USB host interrupt status.">USBHS_HostAckPipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga78cb30399ab291612e71d221afe83b74" title="(USBHS_HSTPIPICR[10]) Short Packet Interrupt Clear">USBHS_HSTPIPICR_SHORTPACKETIC</a>);
<a name="l01453"></a>01453 <span class="preprocessor">#else</span>
<a name="l01454"></a>01454 <span class="preprocessor"></span>    b_short_packet = (<a class="code" href="usbhs_8h.html#ae752afec4dfecc9565eaa4242ce9233f" title="Gets USB host interrupt status.">USBHS_HostGetIntTypeStatus</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0,
<a name="l01455"></a>01455                       <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga24f69fdd9e7c0327a46178c23dffba8a" title="(USBHS_HSTPIPISR[10]) Short Packet Interrupt">USBHS_HSTPIPISR_SHORTPACKETI</a>) == USBHS_HSTPIPISR_SHORTPACKETI) ? <span class="keyword">true</span> : <span class="keyword">false</span>;
<a name="l01456"></a>01456 <span class="preprocessor">#endif</span>
<a name="l01457"></a>01457 <span class="preprocessor"></span>
<a name="l01458"></a>01458     pEpData = (uint8_t *)((uint32_t *)<a class="code" href="group___s_a_m_e70_q21__definitions.html#ga509eeb3745bd4057d342dd132dd2cecf">USBHS_RAM_ADDR</a>
<a name="l01459"></a>01459                           + (<a class="code" href="usbhs_8h.html#a19e18c1683b682fc01056cbf2b2b92f6">EPT_VIRTUAL_SIZE</a> * bPipe));
<a name="l01460"></a>01460 uhd_ctrl_receiv_in_read_data:
<a name="l01461"></a>01461     memory_sync();
<a name="l01462"></a>01462 
<a name="l01463"></a>01463     <span class="comment">// Copy data from pipe to payload buffer</span>
<a name="l01464"></a>01464     <span class="keywordflow">while</span> (uhd_ctrl_request_first-&gt;<a class="code" href="structuhd__ctrl__request__t.html#aab546d1e52187d029085b16b03b2c197" title="Size of buffer used in DATA phase.">payload_size</a> &amp;&amp; nb_byte_received) {
<a name="l01465"></a>01465         *uhd_ctrl_request_first-&gt;<a class="code" href="structuhd__ctrl__request__t.html#a44aa00d0c9a6f68f208329f0fbbbf214" title="Buffer to store the setup DATA phase.">payload</a>++ = *pEpData++;
<a name="l01466"></a>01466         memory_sync();
<a name="l01467"></a>01467         uhd_ctrl_nb_trans++;
<a name="l01468"></a>01468         uhd_ctrl_request_first-&gt;<a class="code" href="structuhd__ctrl__request__t.html#aab546d1e52187d029085b16b03b2c197" title="Size of buffer used in DATA phase.">payload_size</a>--;
<a name="l01469"></a>01469         nb_byte_received--;
<a name="l01470"></a>01470         memory_barrier();
<a name="l01471"></a>01471     }
<a name="l01472"></a>01472 
<a name="l01473"></a>01473     <span class="keywordflow">if</span> (!uhd_ctrl_request_first-&gt;<a class="code" href="structuhd__ctrl__request__t.html#aab546d1e52187d029085b16b03b2c197" title="Size of buffer used in DATA phase.">payload_size</a> &amp;&amp; nb_byte_received) {
<a name="l01474"></a>01474         <span class="comment">// payload buffer is full to store data remaining</span>
<a name="l01475"></a>01475         <span class="keywordflow">if</span> (uhd_ctrl_request_first-&gt;<a class="code" href="structuhd__ctrl__request__t.html#aab515926dcc24785d888351fb22b4952" title="Callback called when buffer is empty or full.">callback_run</a> == NULL
<a name="l01476"></a>01476             || !uhd_ctrl_request_first-&gt;<a class="code" href="structuhd__ctrl__request__t.html#aab515926dcc24785d888351fb22b4952" title="Callback called when buffer is empty or full.">callback_run</a>(
<a name="l01477"></a>01477                 USBHS_HostGetAddr(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, bPipe),
<a name="l01478"></a>01478                 &amp;uhd_ctrl_request_first-&gt;<a class="code" href="structuhd__ctrl__request__t.html#a44aa00d0c9a6f68f208329f0fbbbf214" title="Buffer to store the setup DATA phase.">payload</a>,
<a name="l01479"></a>01479                 &amp;uhd_ctrl_request_first-&gt;<a class="code" href="structuhd__ctrl__request__t.html#aab546d1e52187d029085b16b03b2c197" title="Size of buffer used in DATA phase.">payload_size</a>)) {
<a name="l01480"></a>01480             <span class="comment">// DATA phase aborted by host</span>
<a name="l01481"></a>01481             <span class="keywordflow">goto</span> uhd_ctrl_phase_data_in_end;
<a name="l01482"></a>01482         }
<a name="l01483"></a>01483 
<a name="l01484"></a>01484         <span class="comment">// The payload buffer has been updated by the callback</span>
<a name="l01485"></a>01485         <span class="comment">// thus the data load can restart.</span>
<a name="l01486"></a>01486         <span class="keywordflow">goto</span> uhd_ctrl_receiv_in_read_data;
<a name="l01487"></a>01487     }
<a name="l01488"></a>01488 
<a name="l01489"></a>01489     <span class="comment">// Test short packet</span>
<a name="l01490"></a>01490     <span class="keywordflow">if</span> ((uhd_ctrl_nb_trans == uhd_ctrl_request_first-&gt;<a class="code" href="structuhd__ctrl__request__t.html#af533979e39a8f0059a84a9024168faf1" title="Setup request definition.">req</a>.<a class="code" href="struct_u_s_b_generic_request.html#a5c6f6461bdcbe9ebe6fa40e88f76e94e">wLength</a>)
<a name="l01491"></a>01491         || b_short_packet) {
<a name="l01492"></a>01492         <span class="comment">// End of DATA phase or DATA phase abort from device</span>
<a name="l01493"></a>01493 uhd_ctrl_phase_data_in_end:
<a name="l01494"></a>01494         USBH_HAL_OutZLP();
<a name="l01495"></a>01495         <span class="keywordflow">return</span>;
<a name="l01496"></a>01496     }
<a name="l01497"></a>01497 
<a name="l01498"></a>01498     <span class="comment">// Send a new IN packet request</span>
<a name="l01499"></a>01499     <a class="code" href="usbhs_8h.html#acd60bcdb7e5420ac4cfb8b457838f9ba" title="Gets USB host interrupt status.">USBHS_HostEnablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, bPipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga1ae7fc25e5d572a2e50316b1e72cffd5" title="(USBHS_HSTPIPIER[10]) Received IN Data Interrupt Enable">USBHS_HSTPIPIER_RXINES</a>);
<a name="l01500"></a>01500     <span class="comment">// ack Fifocon and unfreeze pipe</span>
<a name="l01501"></a>01501     <a class="code" href="usbhs_8h.html#a32c56acaace52b440a308d9bce8cafff" title="Gets USB host interrupt status.">USBHS_HostDisablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, bPipe,
<a name="l01502"></a>01502                                  (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gabcec9beefeab1700242da4c88f1b7a51" title="(USBHS_HSTPIPIDR[10]) FIFO Control Disable">USBHS_HSTPIPIDR_FIFOCONC</a> | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga2b99057bec6aa1f5a541cede730c657e" title="(USBHS_HSTPIPIDR[10]) Pipe Freeze Disable">USBHS_HSTPIPIDR_PFREEZEC</a>));
<a name="l01503"></a>01503 }
<a name="l01504"></a>01504 <span class="comment"></span>
<a name="l01505"></a>01505 <span class="comment">/**</span>
<a name="l01506"></a>01506 <span class="comment"> * \internal</span>
<a name="l01507"></a>01507 <span class="comment"> * \brief Starts the ZLP IN phase on control endpoint</span>
<a name="l01508"></a>01508 <span class="comment"> */</span>
<a name="l01509"></a>01509 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_InZLP(<span class="keywordtype">void</span>)
<a name="l01510"></a>01510 {
<a name="l01511"></a>01511     uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_ZLP_IN;
<a name="l01512"></a>01512     <a class="code" href="usbhs_8h.html#a48f3b4774877abb73ad633b904e4caee" title="Gets USB host interrupt status.">USBHS_HostSetToken</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga05aed341b46e5deb78532b4e66ad3170" title="(USBHS_HSTPIPCFG[10]) IN">USBHS_HSTPIPCFG_PTOKEN_IN</a>);
<a name="l01513"></a>01513     <a class="code" href="usbhs_8h.html#a97e601451758556ee0591fae627974d8" title="Gets USB host interrupt status.">USBHS_HostAckPipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0,
<a name="l01514"></a>01514                              (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga9067ea47ec30664e8fd73e8ab7e35181" title="(USBHS_HSTPIPICR[10]) Received IN Data Interrupt Clear">USBHS_HSTPIPICR_RXINIC</a> | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga78cb30399ab291612e71d221afe83b74" title="(USBHS_HSTPIPICR[10]) Short Packet Interrupt Clear">USBHS_HSTPIPICR_SHORTPACKETIC</a>));
<a name="l01515"></a>01515     <span class="comment">/*uhd_ack_in_received(0);</span>
<a name="l01516"></a>01516 <span class="comment">    uhd_ack_short_packet(0);*/</span>
<a name="l01517"></a>01517     <a class="code" href="usbhs_8h.html#acd60bcdb7e5420ac4cfb8b457838f9ba" title="Gets USB host interrupt status.">USBHS_HostEnablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga1ae7fc25e5d572a2e50316b1e72cffd5" title="(USBHS_HSTPIPIER[10]) Received IN Data Interrupt Enable">USBHS_HSTPIPIER_RXINES</a>);
<a name="l01518"></a>01518     <span class="comment">// ack Fifocon and unfreeze pipe</span>
<a name="l01519"></a>01519     <a class="code" href="usbhs_8h.html#a32c56acaace52b440a308d9bce8cafff" title="Gets USB host interrupt status.">USBHS_HostDisablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, 0,
<a name="l01520"></a>01520                                  (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gabcec9beefeab1700242da4c88f1b7a51" title="(USBHS_HSTPIPIDR[10]) FIFO Control Disable">USBHS_HSTPIPIDR_FIFOCONC</a> | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga2b99057bec6aa1f5a541cede730c657e" title="(USBHS_HSTPIPIDR[10]) Pipe Freeze Disable">USBHS_HSTPIPIDR_PFREEZEC</a>));
<a name="l01521"></a>01521     memory_sync();
<a name="l01522"></a>01522 }
<a name="l01523"></a>01523 <span class="comment"></span>
<a name="l01524"></a>01524 <span class="comment">/**</span>
<a name="l01525"></a>01525 <span class="comment"> * \internal</span>
<a name="l01526"></a>01526 <span class="comment"> * \brief Manages the DATA OUT phase on control endpoint</span>
<a name="l01527"></a>01527 <span class="comment"> */</span>
<a name="l01528"></a>01528 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_PhaseDataOut(<span class="keywordtype">void</span>)
<a name="l01529"></a>01529 {
<a name="l01530"></a>01530     uint8_t *pEpData;
<a name="l01531"></a>01531     uint8_t bPipe = 0;
<a name="l01532"></a>01532     uint8_t ep_ctrl_size;
<a name="l01533"></a>01533 
<a name="l01534"></a>01534     uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_DATA_OUT;
<a name="l01535"></a>01535 
<a name="l01536"></a>01536     <span class="keywordflow">if</span> (uhd_ctrl_nb_trans == uhd_ctrl_request_first-&gt;<a class="code" href="structuhd__ctrl__request__t.html#af533979e39a8f0059a84a9024168faf1" title="Setup request definition.">req</a>.<a class="code" href="struct_u_s_b_generic_request.html#a5c6f6461bdcbe9ebe6fa40e88f76e94e">wLength</a>) {
<a name="l01537"></a>01537         <span class="comment">// End of DATA phase</span>
<a name="l01538"></a>01538         USBH_HAL_InZLP();
<a name="l01539"></a>01539         <span class="keywordflow">return</span>;
<a name="l01540"></a>01540     }
<a name="l01541"></a>01541 
<a name="l01542"></a>01542     <span class="keywordflow">if</span> (!uhd_ctrl_request_first-&gt;<a class="code" href="structuhd__ctrl__request__t.html#aab546d1e52187d029085b16b03b2c197" title="Size of buffer used in DATA phase.">payload_size</a>) {
<a name="l01543"></a>01543         <span class="comment">// Buffer empty, then request a new buffer</span>
<a name="l01544"></a>01544         <span class="keywordflow">if</span> (uhd_ctrl_request_first-&gt;<a class="code" href="structuhd__ctrl__request__t.html#aab515926dcc24785d888351fb22b4952" title="Callback called when buffer is empty or full.">callback_run</a> == NULL
<a name="l01545"></a>01545             || !uhd_ctrl_request_first-&gt;<a class="code" href="structuhd__ctrl__request__t.html#aab515926dcc24785d888351fb22b4952" title="Callback called when buffer is empty or full.">callback_run</a>(
<a name="l01546"></a>01546                 USBHS_HostGetAddr(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, bPipe),
<a name="l01547"></a>01547                 &amp;uhd_ctrl_request_first-&gt;<a class="code" href="structuhd__ctrl__request__t.html#a44aa00d0c9a6f68f208329f0fbbbf214" title="Buffer to store the setup DATA phase.">payload</a>,
<a name="l01548"></a>01548                 &amp;uhd_ctrl_request_first-&gt;<a class="code" href="structuhd__ctrl__request__t.html#aab546d1e52187d029085b16b03b2c197" title="Size of buffer used in DATA phase.">payload_size</a>)) {
<a name="l01549"></a>01549             <span class="comment">// DATA phase aborted by host</span>
<a name="l01550"></a>01550             USBH_HAL_InZLP();
<a name="l01551"></a>01551             <span class="keywordflow">return</span>;
<a name="l01552"></a>01552         }
<a name="l01553"></a>01553     }
<a name="l01554"></a>01554 
<a name="l01555"></a>01555 <span class="preprocessor">#ifdef USB_HOST_HUB_SUPPORT</span>
<a name="l01556"></a>01556 <span class="preprocessor"></span>    <span class="comment">// TODO</span>
<a name="l01557"></a>01557 <span class="preprocessor">#else</span>
<a name="l01558"></a>01558 <span class="preprocessor"></span>    ep_ctrl_size = <a class="code" href="usbhs_8h.html#ac13debb9eb4e51de70e9086d6264ee88" title="Gets USB host interrupt status.">USBHS_HostGetSize</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, bPipe);
<a name="l01559"></a>01559 <span class="preprocessor">#endif</span>
<a name="l01560"></a>01560 <span class="preprocessor"></span>
<a name="l01561"></a>01561     <span class="comment">// Fill pipe</span>
<a name="l01562"></a>01562     <a class="code" href="usbhs_8h.html#a48f3b4774877abb73ad633b904e4caee" title="Gets USB host interrupt status.">USBHS_HostSetToken</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, bPipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga0c650ad1cdbe06feef020ac64286b834" title="(USBHS_HSTPIPCFG[10]) OUT">USBHS_HSTPIPCFG_PTOKEN_OUT</a>);
<a name="l01563"></a>01563     <span class="comment">//uhd_configure_pipe_token(0, USBHS_HSTPIPCFG_PTOKEN_OUT);</span>
<a name="l01564"></a>01564     <span class="comment">//uhd_ack_out_ready(0);</span>
<a name="l01565"></a>01565     <a class="code" href="usbhs_8h.html#a97e601451758556ee0591fae627974d8" title="Gets USB host interrupt status.">USBHS_HostAckPipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, bPipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga0dee7d148bee9d67b2d3f846b2d642b3" title="(USBHS_HSTPIPICR[10]) Transmitted OUT Data Interrupt Clear">USBHS_HSTPIPICR_TXOUTIC</a>);
<a name="l01566"></a>01566     pEpData = (uint8_t *)((uint32_t *)<a class="code" href="group___s_a_m_e70_q21__definitions.html#ga509eeb3745bd4057d342dd132dd2cecf">USBHS_RAM_ADDR</a>
<a name="l01567"></a>01567                           + (<a class="code" href="usbhs_8h.html#a19e18c1683b682fc01056cbf2b2b92f6">EPT_VIRTUAL_SIZE</a> * bPipe));
<a name="l01568"></a>01568     memory_sync();
<a name="l01569"></a>01569 
<a name="l01570"></a>01570     <span class="keywordflow">while</span> ((uhd_ctrl_nb_trans &lt; uhd_ctrl_request_first-&gt;req.<a class="code" href="struct_u_s_b_generic_request.html#a5c6f6461bdcbe9ebe6fa40e88f76e94e">wLength</a>)
<a name="l01571"></a>01571            &amp;&amp; ep_ctrl_size &amp;&amp; uhd_ctrl_request_first-&gt;<a class="code" href="structuhd__ctrl__request__t.html#aab546d1e52187d029085b16b03b2c197" title="Size of buffer used in DATA phase.">payload_size</a>) {
<a name="l01572"></a>01572         *pEpData++ = *uhd_ctrl_request_first-&gt;<a class="code" href="structuhd__ctrl__request__t.html#a44aa00d0c9a6f68f208329f0fbbbf214" title="Buffer to store the setup DATA phase.">payload</a>++;
<a name="l01573"></a>01573         memory_sync();
<a name="l01574"></a>01574         uhd_ctrl_nb_trans++;
<a name="l01575"></a>01575         ep_ctrl_size--;
<a name="l01576"></a>01576         uhd_ctrl_request_first-&gt;<a class="code" href="structuhd__ctrl__request__t.html#aab546d1e52187d029085b16b03b2c197" title="Size of buffer used in DATA phase.">payload_size</a>--;
<a name="l01577"></a>01577         memory_barrier();
<a name="l01578"></a>01578     }
<a name="l01579"></a>01579 
<a name="l01580"></a>01580     <span class="comment">//uhd_enable_out_ready_interrupt(0);</span>
<a name="l01581"></a>01581     <a class="code" href="usbhs_8h.html#acd60bcdb7e5420ac4cfb8b457838f9ba" title="Gets USB host interrupt status.">USBHS_HostEnablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, bPipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga5dd1b8ced4705724713f5ec3222c8ee7" title="(USBHS_HSTPIPIER[10]) Transmitted OUT Data Interrupt Enable">USBHS_HSTPIPIER_TXOUTES</a>);
<a name="l01582"></a>01582     <a class="code" href="usbhs_8h.html#a32c56acaace52b440a308d9bce8cafff" title="Gets USB host interrupt status.">USBHS_HostDisablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, bPipe,
<a name="l01583"></a>01583                                  (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gabcec9beefeab1700242da4c88f1b7a51" title="(USBHS_HSTPIPIDR[10]) FIFO Control Disable">USBHS_HSTPIPIDR_FIFOCONC</a> | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga2b99057bec6aa1f5a541cede730c657e" title="(USBHS_HSTPIPIDR[10]) Pipe Freeze Disable">USBHS_HSTPIPIDR_PFREEZEC</a> ) );
<a name="l01584"></a>01584     <span class="comment">//uhd_unfreeze_pipe(0);</span>
<a name="l01585"></a>01585 }
<a name="l01586"></a>01586 <span class="comment"></span>
<a name="l01587"></a>01587 <span class="comment">/**</span>
<a name="l01588"></a>01588 <span class="comment"> * \internal</span>
<a name="l01589"></a>01589 <span class="comment"> * \brief Starts the ZLP OUT phase on control endpoint</span>
<a name="l01590"></a>01590 <span class="comment"> */</span>
<a name="l01591"></a>01591 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_OutZLP(<span class="keywordtype">void</span>)
<a name="l01592"></a>01592 {
<a name="l01593"></a>01593     uint8_t bPipe = 0;
<a name="l01594"></a>01594     uhd_ctrl_request_phase = UHD_CTRL_REQ_PHASE_ZLP_OUT;
<a name="l01595"></a>01595     <a class="code" href="usbhs_8h.html#a48f3b4774877abb73ad633b904e4caee" title="Gets USB host interrupt status.">USBHS_HostSetToken</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, bPipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga0c650ad1cdbe06feef020ac64286b834" title="(USBHS_HSTPIPCFG[10]) OUT">USBHS_HSTPIPCFG_PTOKEN_OUT</a>);
<a name="l01596"></a>01596     <span class="comment">//uhd_configure_pipe_token(0, USBHS_HSTPIPCFG_PTOKEN_OUT);</span>
<a name="l01597"></a>01597     <a class="code" href="usbhs_8h.html#a97e601451758556ee0591fae627974d8" title="Gets USB host interrupt status.">USBHS_HostAckPipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, bPipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga0dee7d148bee9d67b2d3f846b2d642b3" title="(USBHS_HSTPIPICR[10]) Transmitted OUT Data Interrupt Clear">USBHS_HSTPIPICR_TXOUTIC</a>);
<a name="l01598"></a>01598     <span class="comment">//uhd_ack_out_ready(0);</span>
<a name="l01599"></a>01599     <a class="code" href="usbhs_8h.html#acd60bcdb7e5420ac4cfb8b457838f9ba" title="Gets USB host interrupt status.">USBHS_HostEnablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, bPipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga5dd1b8ced4705724713f5ec3222c8ee7" title="(USBHS_HSTPIPIER[10]) Transmitted OUT Data Interrupt Enable">USBHS_HSTPIPIER_TXOUTES</a>);
<a name="l01600"></a>01600     <span class="comment">//uhd_enable_out_ready_interrupt(0);</span>
<a name="l01601"></a>01601     <a class="code" href="usbhs_8h.html#a32c56acaace52b440a308d9bce8cafff" title="Gets USB host interrupt status.">USBHS_HostDisablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, bPipe,
<a name="l01602"></a>01602                                  (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gabcec9beefeab1700242da4c88f1b7a51" title="(USBHS_HSTPIPIDR[10]) FIFO Control Disable">USBHS_HSTPIPIDR_FIFOCONC</a> | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga2b99057bec6aa1f5a541cede730c657e" title="(USBHS_HSTPIPIDR[10]) Pipe Freeze Disable">USBHS_HSTPIPIDR_PFREEZEC</a>));
<a name="l01603"></a>01603     <span class="comment">//uhd_unfreeze_pipe(0);</span>
<a name="l01604"></a>01604 }
<a name="l01605"></a>01605 <span class="comment"></span>
<a name="l01606"></a>01606 <span class="comment">/**</span>
<a name="l01607"></a>01607 <span class="comment"> * \internal</span>
<a name="l01608"></a>01608 <span class="comment"> * \brief Call the callback linked to control request</span>
<a name="l01609"></a>01609 <span class="comment"> * and start the next request from the queue.</span>
<a name="l01610"></a>01610 <span class="comment">*/</span>
<a name="l01611"></a>01611 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_ControlReqEnd(<a class="code" href="group__uhd__group.html#ga19c67cc9d097b54049dbc7c12119eb83" title="Endpoint transfer status The status field is updated after each transaction attempt, whether successful or not.">USBH_XfrStatus_t</a> status)
<a name="l01612"></a>01612 {
<a name="l01613"></a>01613     uint8_t bPipe = 0;
<a name="l01614"></a>01614     irqflags_t flags;
<a name="l01615"></a>01615     <a class="code" href="group__uhd__group.html#ga48eac59f68de74c0ce604429cb46510e" title="End of setup callback function type. Registered by USBH_HAL_SetupReq() Called when the setup request ...">uhd_callback_setup_end_t</a> callback_end;
<a name="l01616"></a>01616     <span class="keyword">struct </span><a class="code" href="structuhd__ctrl__request__t.html" title="Structure to store the high level setup request.">uhd_ctrl_request_t</a> *request_to_free;
<a name="l01617"></a>01617     <span class="keywordtype">bool</span> b_new_request;
<a name="l01618"></a>01618 
<a name="l01619"></a>01619     uhd_ctrl_request_timeout = 0;
<a name="l01620"></a>01620 
<a name="l01621"></a>01621     <span class="comment">// Remove request from the control request list</span>
<a name="l01622"></a>01622     callback_end = uhd_ctrl_request_first-&gt;<a class="code" href="structuhd__ctrl__request__t.html#a499487997bb0cccd2194fcdf0504386f" title="Callback called when request is completed.">callback_end</a>;
<a name="l01623"></a>01623     request_to_free = uhd_ctrl_request_first;
<a name="l01624"></a>01624     flags = cpu_irq_save();
<a name="l01625"></a>01625     uhd_ctrl_request_first = uhd_ctrl_request_first-&gt;<a class="code" href="structuhd__ctrl__request__t.html#a158d16ea2e48d975b22443a9a4bc20e2" title="Next setup request to process.">next_request</a>;
<a name="l01626"></a>01626     b_new_request = (uhd_ctrl_request_first != NULL);
<a name="l01627"></a>01627     cpu_irq_restore(flags);
<a name="l01628"></a>01628     free(request_to_free);
<a name="l01629"></a>01629 
<a name="l01630"></a>01630     <span class="comment">// Call callback</span>
<a name="l01631"></a>01631     <span class="keywordflow">if</span> (callback_end != NULL)
<a name="l01632"></a>01632         <a class="code" href="structuhd__ctrl__request__t.html#a499487997bb0cccd2194fcdf0504386f" title="Callback called when request is completed.">callback_end</a>(USBHS_HostGetAddr(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, bPipe), status, uhd_ctrl_nb_trans);
<a name="l01633"></a>01633 
<a name="l01634"></a>01634     <span class="comment">// If a setup request is pending and no started by previous callback</span>
<a name="l01635"></a>01635     <span class="keywordflow">if</span> (b_new_request)
<a name="l01636"></a>01636         USBH_HAL_PhaseControlSetup();
<a name="l01637"></a>01637 
<a name="l01638"></a>01638     <span class="keywordflow">if</span> (uhd_b_suspend_requested) {
<a name="l01639"></a>01639         <span class="comment">// A suspend request has been delay after all setup request</span>
<a name="l01640"></a>01640         uhd_b_suspend_requested = <span class="keyword">false</span>;
<a name="l01641"></a>01641         <a class="code" href="group__uhd__group.html#ga108d6958efd3c7337897ae40963e3f58" title="Enables the suspend state on the USB line. The SUSPEND state is enable when SOF are disabled on USB l...">USBH_HAL_Suspend</a>();
<a name="l01642"></a>01642     }
<a name="l01643"></a>01643 }
<a name="l01644"></a>01644 <span class="comment"></span>
<a name="l01645"></a>01645 <span class="comment">/**</span>
<a name="l01646"></a>01646 <span class="comment"> * \internal</span>
<a name="l01647"></a>01647 <span class="comment"> * \brief Translates the USBHS pipe error to UHD error</span>
<a name="l01648"></a>01648 <span class="comment"> *</span>
<a name="l01649"></a>01649 <span class="comment"> * \param pipe Pipe number to use</span>
<a name="l01650"></a>01650 <span class="comment"> *</span>
<a name="l01651"></a>01651 <span class="comment"> * \return UHD transfer error</span>
<a name="l01652"></a>01652 <span class="comment"> */</span>
<a name="l01653"></a>01653 <span class="keyword">static</span> <a class="code" href="group__uhd__group.html#ga19c67cc9d097b54049dbc7c12119eb83" title="Endpoint transfer status The status field is updated after each transaction attempt, whether successful or not.">USBH_XfrStatus_t</a> USBH_HAL_GetPipeError(uint8_t pipe)
<a name="l01654"></a>01654 {
<a name="l01655"></a>01655     uint32_t error = <a class="code" href="usbhs_8h.html#ac3696a9240e22b2d40ee76d19633bed5" title="Gets USB host interrupt status.">USBHS_HostGetErr</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga600320ddbdac73e695233b7fc6b21b3e" title="(USBHS_HSTPIPERR[10]) Data Toggle Error">USBHS_HSTPIPERR_DATATGL</a> |
<a name="l01656"></a>01656                                       <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga5200b876ec983cceb30c0012a359c7ea" title="(USBHS_HSTPIPERR[10]) Time-Out Error">USBHS_HSTPIPERR_TIMEOUT</a> |
<a name="l01657"></a>01657                                       <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga278a87268f584e9dc0a8cc132662a75f" title="(USBHS_HSTPIPERR[10]) Data PID Error">USBHS_HSTPIPERR_PID</a> |
<a name="l01658"></a>01658                                       <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga8c93574c440f71759d7bbf5cec635d4a" title="(USBHS_HSTPIPERR[10]) Data PID Error">USBHS_HSTPIPERR_DATAPID</a>));
<a name="l01659"></a>01659     <a class="code" href="usbhs_8h.html#a5d2c49f1194cc78dea81c614f36a06e8" title="Gets USB host interrupt status.">USBHS_HostClearErr</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, 0xFF);
<a name="l01660"></a>01660 
<a name="l01661"></a>01661     <span class="keywordflow">switch</span> (error) {
<a name="l01662"></a>01662     <span class="keywordflow">case</span> <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga600320ddbdac73e695233b7fc6b21b3e" title="(USBHS_HSTPIPERR[10]) Data Toggle Error">USBHS_HSTPIPERR_DATATGL</a>:
<a name="l01663"></a>01663         <span class="keywordflow">return</span> UHD_TRANS_DT_MISMATCH;
<a name="l01664"></a>01664 
<a name="l01665"></a>01665     <span class="keywordflow">case</span> <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga5200b876ec983cceb30c0012a359c7ea" title="(USBHS_HSTPIPERR[10]) Time-Out Error">USBHS_HSTPIPERR_TIMEOUT</a>:
<a name="l01666"></a>01666         <span class="keywordflow">return</span> UHD_TRANS_NOTRESPONDING;
<a name="l01667"></a>01667 
<a name="l01668"></a>01668     <span class="keywordflow">case</span> <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga8c93574c440f71759d7bbf5cec635d4a" title="(USBHS_HSTPIPERR[10]) Data PID Error">USBHS_HSTPIPERR_DATAPID</a>:
<a name="l01669"></a>01669     <span class="keywordflow">case</span> <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga278a87268f584e9dc0a8cc132662a75f" title="(USBHS_HSTPIPERR[10]) Data PID Error">USBHS_HSTPIPERR_PID</a>:
<a name="l01670"></a>01670     <span class="keywordflow">default</span>:
<a name="l01671"></a>01671         <span class="keywordflow">return</span> UHD_TRANS_PIDFAILURE;
<a name="l01672"></a>01672     }
<a name="l01673"></a>01673 }
<a name="l01674"></a>01674 <span class="comment"></span>
<a name="l01675"></a>01675 <span class="comment">/**</span>
<a name="l01676"></a>01676 <span class="comment"> * \internal</span>
<a name="l01677"></a>01677 <span class="comment"> * \brief Returns the pipe number matching a USB endpoint</span>
<a name="l01678"></a>01678 <span class="comment"> *</span>
<a name="l01679"></a>01679 <span class="comment"> * \param Addr USB address</span>
<a name="l01680"></a>01680 <span class="comment"> * \param bEndpoint  Endpoint number</span>
<a name="l01681"></a>01681 <span class="comment"> *</span>
<a name="l01682"></a>01682 <span class="comment"> * \return Pipe number</span>
<a name="l01683"></a>01683 <span class="comment"> */</span>
<a name="l01684"></a>01684 <span class="keyword">static</span> uint8_t USBH_HAL_GetPipe(uint8_t Addr, uint8_t bEndpoint)
<a name="l01685"></a>01685 {
<a name="l01686"></a>01686     uint8_t pipe;
<a name="l01687"></a>01687 
<a name="l01688"></a>01688     <span class="comment">// Search pipe</span>
<a name="l01689"></a>01689     <span class="keywordflow">for</span> (pipe = 0; pipe &lt; USBHS_EPT_NUM; pipe++) {
<a name="l01690"></a>01690         <span class="keywordflow">if</span> (!<a class="code" href="usbhs_8h.html#aca1a73918c77f0aaa82395b55d760ae8" title="Gets USB host interrupt status.">USBHS_IsHostPipeEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe))
<a name="l01691"></a>01691             <span class="keywordflow">continue</span>;
<a name="l01692"></a>01692 
<a name="l01693"></a>01693         <span class="keywordflow">if</span> (Addr != USBHS_HostGetAddr(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe))
<a name="l01694"></a>01694             <span class="keywordflow">continue</span>;
<a name="l01695"></a>01695 
<a name="l01696"></a>01696         <span class="keywordflow">if</span> (bEndpoint != USBHS_GetPipeEpAddr(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe))
<a name="l01697"></a>01697             <span class="keywordflow">continue</span>;
<a name="l01698"></a>01698 
<a name="l01699"></a>01699         <span class="keywordflow">break</span>;
<a name="l01700"></a>01700     }
<a name="l01701"></a>01701 
<a name="l01702"></a>01702     <span class="keywordflow">return</span> pipe;
<a name="l01703"></a>01703 }
<a name="l01704"></a>01704 
<a name="l01705"></a>01705 <span class="preprocessor">#ifdef UHD_PIPE_FIFO_SUPPORTED</span>
<a name="l01706"></a>01706 <span class="preprocessor"></span><span class="comment">/**</span>
<a name="l01707"></a>01707 <span class="comment"> * \internal</span>
<a name="l01708"></a>01708 <span class="comment"> */</span>
<a name="l01709"></a>01709 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_PipeInReceived(uint8_t pipe)
<a name="l01710"></a>01710 {
<a name="l01711"></a>01711     <a class="code" href="struct_u_s_b_h___pipe_job__t.html" title="Structure definition to store registered jobs on a pipe.">USBH_PipeJob_t</a> *pJob = &amp;uhd_pipe_job[pipe - 1];
<a name="l01712"></a>01712     uint32_t nb_data = 0, i;
<a name="l01713"></a>01713     uint32_t nb_remain = pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a9f7a2c3bfe2d805a5328dae0dd3d6648" title="Size of buffer to send or fill.">buf_size</a> - pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#afd8c90263aef338ab94344013a0c8162" title="Total number of transfered data on endpoint.">nb_trans</a>;
<a name="l01714"></a>01714     uint32_t pkt_size = <a class="code" href="usbhs_8h.html#ac13debb9eb4e51de70e9086d6264ee88" title="Gets USB host interrupt status.">USBHS_HostGetSize</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe);
<a name="l01715"></a>01715     uint8_t *ptr_src = (uint8_t *)((uint32_t *)<a class="code" href="group___s_a_m_e70_q21__definitions.html#ga509eeb3745bd4057d342dd132dd2cecf">USBHS_RAM_ADDR</a>
<a name="l01716"></a>01716                                    + (<a class="code" href="usbhs_8h.html#a19e18c1683b682fc01056cbf2b2b92f6">EPT_VIRTUAL_SIZE</a> * pipe));
<a name="l01717"></a>01717     uint8_t *ptr_dst = &amp;pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#aecfd98dfe2e19e4fc0e92fa30fee7b2e" title="Buffer located in internal RAM to send or fill during job.">buf</a>[pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#afd8c90263aef338ab94344013a0c8162" title="Total number of transfered data on endpoint.">nb_trans</a>];
<a name="l01718"></a>01718     <span class="keywordtype">bool</span> b_full = <span class="keyword">false</span>, b_short = <span class="keyword">false</span>;
<a name="l01719"></a>01719 
<a name="l01720"></a>01720     <span class="keywordflow">if</span> (!pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a07b75fbf986996a3382967085a7362d0" title="A job is registered on this pipe.">busy</a>) {
<a name="l01721"></a>01721         <span class="keywordflow">return</span>; <span class="comment">// No job is running, then ignore it (system error)</span>
<a name="l01722"></a>01722     }
<a name="l01723"></a>01723 
<a name="l01724"></a>01724     <span class="comment">// Read byte count</span>
<a name="l01725"></a>01725     nb_data = <a class="code" href="usbhs_8h.html#a917ce318855654bd4d1ff18a24248899" title="Gets USB host interrupt status.">USBHS_HostGetPipeByteCount</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe);
<a name="l01726"></a>01726 
<a name="l01727"></a>01727     <span class="keywordflow">if</span> (nb_data &lt; pkt_size)
<a name="l01728"></a>01728         b_short = <span class="keyword">true</span>;
<a name="l01729"></a>01729 
<a name="l01730"></a>01730     <span class="comment">// Copy data if there is</span>
<a name="l01731"></a>01731     <span class="keywordflow">if</span> (nb_data &gt; 0) {
<a name="l01732"></a>01732         <span class="keywordflow">if</span> (nb_data &gt;= nb_remain) {
<a name="l01733"></a>01733             nb_data = nb_remain;
<a name="l01734"></a>01734             b_full = <span class="keyword">true</span>;
<a name="l01735"></a>01735         }
<a name="l01736"></a>01736 
<a name="l01737"></a>01737         <span class="comment">// Modify job information</span>
<a name="l01738"></a>01738         pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#afd8c90263aef338ab94344013a0c8162" title="Total number of transfered data on endpoint.">nb_trans</a> += nb_data;
<a name="l01739"></a>01739 
<a name="l01740"></a>01740         <span class="comment">// Copy FIFO to buffer</span>
<a name="l01741"></a>01741         <span class="keywordflow">for</span> (i = 0; i &lt; nb_data; i++) {
<a name="l01742"></a>01742             *ptr_dst++ = *ptr_src++;
<a name="l01743"></a>01743             memory_sync();
<a name="l01744"></a>01744         }
<a name="l01745"></a>01745     }
<a name="l01746"></a>01746 
<a name="l01747"></a>01747     <span class="comment">// Clear FIFO Status</span>
<a name="l01748"></a>01748     <a class="code" href="usbhs_8h.html#a32c56acaace52b440a308d9bce8cafff" title="Gets USB host interrupt status.">USBHS_HostDisablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gabcec9beefeab1700242da4c88f1b7a51" title="(USBHS_HSTPIPIDR[10]) FIFO Control Disable">USBHS_HSTPIPIDR_FIFOCONC</a>);
<a name="l01749"></a>01749 
<a name="l01750"></a>01750     <span class="comment">// Finish job on error or short packet</span>
<a name="l01751"></a>01751     <span class="keywordflow">if</span> (b_full || b_short) {
<a name="l01752"></a>01752         <a class="code" href="usbhs_8h.html#acd60bcdb7e5420ac4cfb8b457838f9ba" title="Gets USB host interrupt status.">USBHS_HostEnablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga8a09e9f1a8824d9033ebfa3a0570d848" title="(USBHS_HSTPIPIER[10]) Pipe Freeze Enable">USBHS_HSTPIPIER_PFREEZES</a>);
<a name="l01753"></a>01753         <a class="code" href="usbhs_8h.html#a32c56acaace52b440a308d9bce8cafff" title="Gets USB host interrupt status.">USBHS_HostDisablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe,
<a name="l01754"></a>01754                                      (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga9b96d50e478dde0b204c5eb294171bf9" title="(USBHS_HSTPIPIDR[10]) Short Packet Interrupt Disable">USBHS_HSTPIPIDR_SHORTPACKETIEC</a> | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga0d08723be4a935ed53c94f9d7f6d24a0" title="(USBHS_HSTPIPIDR[10]) Received IN Data Interrupt Disable">USBHS_HSTPIPIDR_RXINEC</a>));
<a name="l01755"></a>01755         <span class="comment">//uhd_disable_short_packet_interrupt(pipe);</span>
<a name="l01756"></a>01756         <span class="comment">//uhd_disable_in_received_interrupt(pipe);</span>
<a name="l01757"></a>01757         <a class="code" href="usbhs_8h.html#a4706c65710ae219aab80c2645d24fa81" title="Gets USB host interrupt status.">USBHS_HostPipeIntDisable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe);
<a name="l01758"></a>01758         <span class="comment">//uhd_disable_pipe_interrupt(pipe);</span>
<a name="l01759"></a>01759         <a class="code" href="usbhs_8h.html#ac0d1007b23379af5c4d286a243b4f5e1" title="Gets USB host interrupt status.">USBHS_HostDisableInReq</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe);
<a name="l01760"></a>01760         <span class="comment">//uhd_disable_continuous_in_mode(pipe);</span>
<a name="l01761"></a>01761         USBH_HAL_PipeXfrEnd(pipe, <a class="code" href="group__uhd__group.html#gga19c67cc9d097b54049dbc7c12119eb83a51f2cf9245d0e0d3e7b421c9e6b301b8" title="Transaction is successful.">UHD_TRANS_NOERROR</a>);
<a name="l01762"></a>01762     }
<a name="l01763"></a>01763 }
<a name="l01764"></a>01764 <span class="comment"></span>
<a name="l01765"></a>01765 <span class="comment">/**</span>
<a name="l01766"></a>01766 <span class="comment"> * \internal</span>
<a name="l01767"></a>01767 <span class="comment"> */</span>
<a name="l01768"></a>01768 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_PipeOutReady(uint8_t pipe)
<a name="l01769"></a>01769 {
<a name="l01770"></a>01770     <a class="code" href="struct_u_s_b_h___pipe_job__t.html" title="Structure definition to store registered jobs on a pipe.">USBH_PipeJob_t</a> *pJob = &amp;uhd_pipe_job[pipe - 1];
<a name="l01771"></a>01771     uint32_t pkt_size = <a class="code" href="usbhs_8h.html#ac13debb9eb4e51de70e9086d6264ee88" title="Gets USB host interrupt status.">USBHS_HostGetSize</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe);
<a name="l01772"></a>01772     uint32_t nb_data = 0, i;
<a name="l01773"></a>01773     uint32_t nb_remain;
<a name="l01774"></a>01774     uint8_t *ptr_src;
<a name="l01775"></a>01775     uint8_t *ptr_dst;
<a name="l01776"></a>01776 
<a name="l01777"></a>01777     <span class="keywordflow">if</span> (!pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a07b75fbf986996a3382967085a7362d0" title="A job is registered on this pipe.">busy</a>) {
<a name="l01778"></a>01778         <span class="keywordflow">return</span>; <span class="comment">// No job is running, then ignore it (system error)</span>
<a name="l01779"></a>01779     }
<a name="l01780"></a>01780 
<a name="l01781"></a>01781     <span class="comment">// Transfer data</span>
<a name="l01782"></a>01782     <a class="code" href="usbhs_8h.html#a97e601451758556ee0591fae627974d8" title="Gets USB host interrupt status.">USBHS_HostAckPipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga0dee7d148bee9d67b2d3f846b2d642b3" title="(USBHS_HSTPIPICR[10]) Transmitted OUT Data Interrupt Clear">USBHS_HSTPIPICR_TXOUTIC</a>);
<a name="l01783"></a>01783 
<a name="l01784"></a>01784     nb_remain = pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a9f7a2c3bfe2d805a5328dae0dd3d6648" title="Size of buffer to send or fill.">buf_size</a> - pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#afd8c90263aef338ab94344013a0c8162" title="Total number of transfered data on endpoint.">nb_trans</a>;
<a name="l01785"></a>01785     nb_data = min(nb_remain, pkt_size);
<a name="l01786"></a>01786 
<a name="l01787"></a>01787     <span class="comment">// If not ZLP, fill FIFO</span>
<a name="l01788"></a>01788     <span class="keywordflow">if</span> (nb_data) {
<a name="l01789"></a>01789         <span class="comment">// Fill FIFO</span>
<a name="l01790"></a>01790         ptr_dst = (uint8_t *)((uint32_t *)<a class="code" href="group___s_a_m_e70_q21__definitions.html#ga509eeb3745bd4057d342dd132dd2cecf">USBHS_RAM_ADDR</a>
<a name="l01791"></a>01791                               + (<a class="code" href="usbhs_8h.html#a19e18c1683b682fc01056cbf2b2b92f6">EPT_VIRTUAL_SIZE</a> * pipe));
<a name="l01792"></a>01792         ptr_src = &amp;pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#aecfd98dfe2e19e4fc0e92fa30fee7b2e" title="Buffer located in internal RAM to send or fill during job.">buf</a>[pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#afd8c90263aef338ab94344013a0c8162" title="Total number of transfered data on endpoint.">nb_trans</a>];
<a name="l01793"></a>01793         <span class="comment">// Modify job information</span>
<a name="l01794"></a>01794         pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#afd8c90263aef338ab94344013a0c8162" title="Total number of transfered data on endpoint.">nb_trans</a> += nb_data;
<a name="l01795"></a>01795 
<a name="l01796"></a>01796         memory_sync();
<a name="l01797"></a>01797 
<a name="l01798"></a>01798         <span class="comment">// Copy buffer to FIFO</span>
<a name="l01799"></a>01799         <span class="keywordflow">for</span> (i = 0; i &lt; nb_data; i++) {
<a name="l01800"></a>01800             *ptr_dst++ = *ptr_src++;
<a name="l01801"></a>01801             memory_sync();
<a name="l01802"></a>01802         }
<a name="l01803"></a>01803     }
<a name="l01804"></a>01804 
<a name="l01805"></a>01805     <span class="comment">// Switch to next bank</span>
<a name="l01806"></a>01806     <a class="code" href="usbhs_8h.html#a32c56acaace52b440a308d9bce8cafff" title="Gets USB host interrupt status.">USBHS_HostDisablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gabcec9beefeab1700242da4c88f1b7a51" title="(USBHS_HSTPIPIDR[10]) FIFO Control Disable">USBHS_HSTPIPIDR_FIFOCONC</a>);
<a name="l01807"></a>01807 
<a name="l01808"></a>01808     <span class="comment">// ZLP is cleared if last packet is short</span>
<a name="l01809"></a>01809     <span class="keywordflow">if</span> (nb_data &lt; pkt_size)
<a name="l01810"></a>01810         pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a21a69dca8be71be6f87e4809f4c83922" title="A short packet is requested for this job on endpoint IN.">b_shortpacket</a> = <span class="keyword">false</span>;
<a name="l01811"></a>01811 
<a name="l01812"></a>01812     <span class="comment">// All transfer done, including ZLP, Finish Job</span>
<a name="l01813"></a>01813     <span class="keywordflow">if</span> (pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#afd8c90263aef338ab94344013a0c8162" title="Total number of transfered data on endpoint.">nb_trans</a> &gt;= pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a9f7a2c3bfe2d805a5328dae0dd3d6648" title="Size of buffer to send or fill.">buf_size</a> &amp;&amp; !pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a21a69dca8be71be6f87e4809f4c83922" title="A short packet is requested for this job on endpoint IN.">b_shortpacket</a>) {
<a name="l01814"></a>01814         <span class="comment">// At least one bank there, wait to freeze pipe</span>
<a name="l01815"></a>01815         <a class="code" href="usbhs_8h.html#a32c56acaace52b440a308d9bce8cafff" title="Gets USB host interrupt status.">USBHS_HostDisablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga19293155d73146950142d5284d73b490" title="(USBHS_HSTPIPIDR[10]) Transmitted OUT Data Interrupt Disable">USBHS_HSTPIPIDR_TXOUTEC</a>);
<a name="l01816"></a>01816         <span class="comment">//uhd_disable_out_ready_interrupt(pipe);</span>
<a name="l01817"></a>01817         <a class="code" href="usbhs_8h.html#acd60bcdb7e5420ac4cfb8b457838f9ba" title="Gets USB host interrupt status.">USBHS_HostEnablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga8cd1bd3dd202a99c1e4a2f80539dc31c" title="(USBHS_HSTPIPIER[10]) Number of Busy Banks Enable">USBHS_HSTPIPIER_NBUSYBKES</a>);
<a name="l01818"></a>01818         <span class="keywordflow">return</span>;
<a name="l01819"></a>01819     }
<a name="l01820"></a>01820 }
<a name="l01821"></a>01821 
<a name="l01822"></a>01822 <span class="preprocessor">#endif // #ifdef UHD_PIPE_FIFO_SUPPORTED</span>
<a name="l01823"></a>01823 <span class="preprocessor"></span>
<a name="l01824"></a>01824 <span class="preprocessor">#ifdef UHD_PIPE_DMA_SUPPORTED</span>
<a name="l01825"></a>01825 <span class="preprocessor"></span><span class="comment">/**</span>
<a name="l01826"></a>01826 <span class="comment"> * \internal</span>
<a name="l01827"></a>01827 <span class="comment"> * \brief Computes and starts the next transfer on a pipe</span>
<a name="l01828"></a>01828 <span class="comment"> *</span>
<a name="l01829"></a>01829 <span class="comment"> * \param pipe  Pipe number</span>
<a name="l01830"></a>01830 <span class="comment"> */</span>
<a name="l01831"></a>01831 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_PipeXfrCmplt(uint8_t pipe)
<a name="l01832"></a>01832 {
<a name="l01833"></a>01833     uint32_t uhd_dma_ctrl = 0;
<a name="l01834"></a>01834     <a class="code" href="struct_u_s_b_h___pipe_job__t.html" title="Structure definition to store registered jobs on a pipe.">USBH_PipeJob_t</a> *pJob;
<a name="l01835"></a>01835     uint32_t max_trans;
<a name="l01836"></a>01836     uint32_t next_trans;
<a name="l01837"></a>01837     irqflags_t flags;
<a name="l01838"></a>01838     <a class="code" href="struct_usbhs.html">Usbhs</a>  *pUdp  = USBHS;
<a name="l01839"></a>01839     <a class="code" href="struct_usbhs_hstdma.html" title="UsbhsHstdma hardware registers.">UsbhsHstdma</a> *pUsbDma = &amp;pUdp-&gt;<a class="code" href="struct_usbhs.html#a890006cc761be0b8d6e267edf6fa616c" title="(Usbhs Offset: 0x710) n = 1 .. 7">USBHS_HSTDMA</a>[pipe - 1];
<a name="l01840"></a>01840 
<a name="l01841"></a>01841     <span class="comment">// Get job corresponding at endpoint</span>
<a name="l01842"></a>01842     pJob = &amp;uhd_pipe_job[pipe - 1];
<a name="l01843"></a>01843 
<a name="l01844"></a>01844     <span class="keywordflow">if</span> (!pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a07b75fbf986996a3382967085a7362d0" title="A job is registered on this pipe.">busy</a>) {
<a name="l01845"></a>01845         <span class="keywordflow">return</span>; <span class="comment">// No job is running, then ignore it (system error)</span>
<a name="l01846"></a>01846     }
<a name="l01847"></a>01847 
<a name="l01848"></a>01848     <span class="keywordflow">if</span> (pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#afd8c90263aef338ab94344013a0c8162" title="Total number of transfered data on endpoint.">nb_trans</a> != pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a9f7a2c3bfe2d805a5328dae0dd3d6648" title="Size of buffer to send or fill.">buf_size</a>) {
<a name="l01849"></a>01849         <span class="comment">// Need to send or receive other data</span>
<a name="l01850"></a>01850         next_trans = pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a9f7a2c3bfe2d805a5328dae0dd3d6648" title="Size of buffer to send or fill.">buf_size</a> - pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#afd8c90263aef338ab94344013a0c8162" title="Total number of transfered data on endpoint.">nb_trans</a>;
<a name="l01851"></a>01851         max_trans = UHD_PIPE_MAX_TRANS;
<a name="l01852"></a>01852 
<a name="l01853"></a>01853         <span class="keywordflow">if</span> (<a class="code" href="usbhs_8h.html#a7e40c3d1763e18ec62b55c48edadedde" title="Gets USB host interrupt status.">USBHS_HostGetToken</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe) == <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga05aed341b46e5deb78532b4e66ad3170" title="(USBHS_HSTPIPCFG[10]) IN">USBHS_HSTPIPCFG_PTOKEN_IN</a>) {
<a name="l01854"></a>01854             <span class="comment">// 256 is the maximum of IN requests via UPINRQ</span>
<a name="l01855"></a>01855             <span class="keywordflow">if</span> ((256L * <a class="code" href="usbhs_8h.html#ac13debb9eb4e51de70e9086d6264ee88" title="Gets USB host interrupt status.">USBHS_HostGetSize</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe)) &lt; <a class="code" href="usbhs_8h.html#a11838ca412e5e6a51e9a3769bfa989f5" title="Maximum transfer size on USB DMA.">UHD_PIPE_MAX_TRANS</a>)
<a name="l01856"></a>01856                 max_trans = 256L * <a class="code" href="usbhs_8h.html#ac13debb9eb4e51de70e9086d6264ee88" title="Gets USB host interrupt status.">USBHS_HostGetSize</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe);
<a name="l01857"></a>01857         }
<a name="l01858"></a>01858 
<a name="l01859"></a>01859         <span class="keywordflow">if</span> (max_trans &lt; next_trans) {
<a name="l01860"></a>01860             <span class="comment">// The USB hardware supports a maximum</span>
<a name="l01861"></a>01861             <span class="comment">// transfer size of UHD_PIPE_MAX_TRANS Bytes</span>
<a name="l01862"></a>01862             next_trans = max_trans;
<a name="l01863"></a>01863         }
<a name="l01864"></a>01864 
<a name="l01865"></a>01865         <span class="keywordflow">if</span> (next_trans == <a class="code" href="usbhs_8h.html#a11838ca412e5e6a51e9a3769bfa989f5" title="Maximum transfer size on USB DMA.">UHD_PIPE_MAX_TRANS</a>) {
<a name="l01866"></a>01866             <span class="comment">// Set 0 to transfer the maximum</span>
<a name="l01867"></a>01867             uhd_dma_ctrl = USBHS_HSTDMACONTROL_BUFF_LENGTH(0);
<a name="l01868"></a>01868         } <span class="keywordflow">else</span>
<a name="l01869"></a>01869             uhd_dma_ctrl = USBHS_HSTDMACONTROL_BUFF_LENGTH(next_trans);
<a name="l01870"></a>01870 
<a name="l01871"></a>01871         <span class="keywordflow">if</span> (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga0c650ad1cdbe06feef020ac64286b834" title="(USBHS_HSTPIPCFG[10]) OUT">USBHS_HSTPIPCFG_PTOKEN_OUT</a> == <a class="code" href="usbhs_8h.html#a7e40c3d1763e18ec62b55c48edadedde" title="Gets USB host interrupt status.">USBHS_HostGetToken</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe)) {
<a name="l01872"></a>01872             <span class="keywordflow">if</span> (0 != (next_trans % <a class="code" href="usbhs_8h.html#ac13debb9eb4e51de70e9086d6264ee88" title="Gets USB host interrupt status.">USBHS_HostGetSize</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe))) {
<a name="l01873"></a>01873                 <span class="comment">// Enable short packet option</span>
<a name="l01874"></a>01874                 <span class="comment">// else the DMA transfer is accepted</span>
<a name="l01875"></a>01875                 <span class="comment">// and interrupt DMA valid but nothing is sent.</span>
<a name="l01876"></a>01876                 uhd_dma_ctrl |= USBHS_HSTDMACONTROL_END_B_EN;
<a name="l01877"></a>01877                 <span class="comment">// No need to request another ZLP</span>
<a name="l01878"></a>01878                 pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a21a69dca8be71be6f87e4809f4c83922" title="A short packet is requested for this job on endpoint IN.">b_shortpacket</a> = <span class="keyword">false</span>;
<a name="l01879"></a>01879             }
<a name="l01880"></a>01880         } <span class="keywordflow">else</span> {
<a name="l01881"></a>01881             <span class="keywordflow">if</span> ((<a class="code" href="group__usb__ep__type.html#ga68191dae196f962d68287947f9466b4d">USBEndpointDescriptor_ISOCHRONOUS</a> != <a class="code" href="usbhs_8h.html#a568fb6f40affb306e060461fe065a516" title="Gets USB host interrupt status.">USBHS_HostGetPipeType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe))
<a name="l01882"></a>01882                 || ((<span class="keywordtype">int</span>)next_trans &lt;= <a class="code" href="usbhs_8h.html#ac13debb9eb4e51de70e9086d6264ee88" title="Gets USB host interrupt status.">USBHS_HostGetSize</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe))) {
<a name="l01883"></a>01883                 <span class="comment">// Enable short packet reception</span>
<a name="l01884"></a>01884                 uhd_dma_ctrl |= <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga363d9c6d460e65cc48615bd6cda95322" title="(USBHS_HSTDMACONTROL) End of Transfer Interrupt Enable">USBHS_HSTDMACONTROL_END_TR_IT</a>
<a name="l01885"></a>01885                                 | USBHS_HSTDMACONTROL_END_TR_EN;
<a name="l01886"></a>01886             }
<a name="l01887"></a>01887         }
<a name="l01888"></a>01888 
<a name="l01889"></a>01889         <span class="comment">// Start USB DMA to fill or read fifo of the selected endpoint</span>
<a name="l01890"></a>01890         <a class="code" href="usbhs_8h.html#a7b7dcd419b41dc75bdf1ed56fea79075" title="Sets USBHS&amp;#39;s DMA Buffer addresse.">USBHS_SetHostDmaBuffAdd</a>(pUsbDma, (uint32_t) &amp;pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#aecfd98dfe2e19e4fc0e92fa30fee7b2e" title="Buffer located in internal RAM to send or fill during job.">buf</a>[pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#afd8c90263aef338ab94344013a0c8162" title="Total number of transfered data on endpoint.">nb_trans</a>]);
<a name="l01891"></a>01891         uhd_dma_ctrl |= <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga7d9141f74b0c766a0e33e65dd31bfc39" title="(USBHS_HSTDMACONTROL) End of Buffer Interrupt Enable">USBHS_HSTDMACONTROL_END_BUFFIT</a> |
<a name="l01892"></a>01892                         USBHS_HSTDMACONTROL_CHANN_ENB;
<a name="l01893"></a>01893 
<a name="l01894"></a>01894         <span class="comment">// Disable IRQs to have a short sequence</span>
<a name="l01895"></a>01895         <span class="comment">// between read of EOT_STA and DMA enable</span>
<a name="l01896"></a>01896         flags = cpu_irq_save();
<a name="l01897"></a>01897 
<a name="l01898"></a>01898         <span class="keywordflow">if</span> (!(<a class="code" href="usbhs_8h.html#a867c067ec59082580389661c677469ea" title="Get Dma Status.">USBHS_GetHostPipeDmaStatus</a>(pUsbDma)
<a name="l01899"></a>01899               &amp; <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gadc4e65fa1832fc585dd17d89c66ff067" title="(USBHS_HSTDMASTATUS) End of Channel Transfer Status">USBHS_HSTDMASTATUS_END_TR_ST</a>)) {
<a name="l01900"></a>01900             <span class="keywordflow">if</span> (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga05aed341b46e5deb78532b4e66ad3170" title="(USBHS_HSTPIPCFG[10]) IN">USBHS_HSTPIPCFG_PTOKEN_IN</a> == <a class="code" href="usbhs_8h.html#a7e40c3d1763e18ec62b55c48edadedde" title="Gets USB host interrupt status.">USBHS_HostGetToken</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe)) {
<a name="l01901"></a>01901                 uint32_t pipe_size = <a class="code" href="usbhs_8h.html#ac13debb9eb4e51de70e9086d6264ee88" title="Gets USB host interrupt status.">USBHS_HostGetSize</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe);
<a name="l01902"></a>01902                 <a class="code" href="usbhs_8h.html#aedba0b8562b6d4aa35096f3db61f18c6" title="Gets USB host interrupt status.">USBHS_HostInReq</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, (next_trans + pipe_size - 1) / pipe_size);
<a name="l01903"></a>01903             }
<a name="l01904"></a>01904 
<a name="l01905"></a>01905             <span class="keywordflow">if</span> (!pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a9c7642dff284877f8ebc741157c376e0" title="Periodic packet start for this job.">b_periodic_start</a>) {
<a name="l01906"></a>01906                 <a class="code" href="usbhs_8h.html#a32c56acaace52b440a308d9bce8cafff" title="Gets USB host interrupt status.">USBHS_HostDisablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gad3bb07d57156a86a6ac3534c0f07c8ab" title="(USBHS_HSTPIPIDR[10]) Number of Busy Banks Disable">USBHS_HSTPIPIDR_NBUSYBKEC</a>);
<a name="l01907"></a>01907                 <a class="code" href="usbhs_8h.html#a32c56acaace52b440a308d9bce8cafff" title="Gets USB host interrupt status.">USBHS_HostDisablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga2b99057bec6aa1f5a541cede730c657e" title="(USBHS_HSTPIPIDR[10]) Pipe Freeze Disable">USBHS_HSTPIPIDR_PFREEZEC</a>);
<a name="l01908"></a>01908             } <span class="keywordflow">else</span> {
<a name="l01909"></a>01909                 <span class="comment">// Last bank not sent, just start</span>
<a name="l01910"></a>01910                 <span class="keywordflow">if</span> (<a class="code" href="usbhs_8h.html#a0a8e28b882f4abf73c473980d36c7e06" title="Gets USB host interrupt status.">USBHS_IsHostPipeIntTypeEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga52f9964410273efb2afbcb794ec3619e" title="(USBHS_HSTPIPIMR[10]) Number of Busy Banks Interrupt Enable">USBHS_HSTPIPIMR_NBUSYBKE</a>))
<a name="l01911"></a>01911                     <a class="code" href="usbhs_8h.html#a32c56acaace52b440a308d9bce8cafff" title="Gets USB host interrupt status.">USBHS_HostDisablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe,
<a name="l01912"></a>01912                                                  (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gad3bb07d57156a86a6ac3534c0f07c8ab" title="(USBHS_HSTPIPIDR[10]) Number of Busy Banks Disable">USBHS_HSTPIPIDR_NBUSYBKEC</a> | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga2b99057bec6aa1f5a541cede730c657e" title="(USBHS_HSTPIPIDR[10]) Pipe Freeze Disable">USBHS_HSTPIPIDR_PFREEZEC</a>));
<a name="l01913"></a>01913                 <span class="keywordflow">else</span> {
<a name="l01914"></a>01914                     <span class="comment">// Wait SOF to start</span>
<a name="l01915"></a>01915                 }
<a name="l01916"></a>01916             }
<a name="l01917"></a>01917 
<a name="l01918"></a>01918             SCB_CleanInvalidateDCache();
<a name="l01919"></a>01919             <a class="code" href="usbhs_8h.html#ad212cc35348ff023533b9a47aba79345" title="Setup the USBHS DMA.">USBHS_HostConfigureDma</a>(pUsbDma, uhd_dma_ctrl);
<a name="l01920"></a>01920             pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#afd8c90263aef338ab94344013a0c8162" title="Total number of transfered data on endpoint.">nb_trans</a> += next_trans;
<a name="l01921"></a>01921             cpu_irq_restore(flags);
<a name="l01922"></a>01922             <span class="keywordflow">return</span>;
<a name="l01923"></a>01923         }
<a name="l01924"></a>01924 
<a name="l01925"></a>01925         cpu_irq_restore(flags);
<a name="l01926"></a>01926         <span class="comment">// Here a ZLP has been received</span>
<a name="l01927"></a>01927         <span class="comment">// and the DMA transfer must be not started.</span>
<a name="l01928"></a>01928         <span class="comment">// It is the end of transfer</span>
<a name="l01929"></a>01929         pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a9f7a2c3bfe2d805a5328dae0dd3d6648" title="Size of buffer to send or fill.">buf_size</a> = pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#afd8c90263aef338ab94344013a0c8162" title="Total number of transfered data on endpoint.">nb_trans</a>;
<a name="l01930"></a>01930     }
<a name="l01931"></a>01931 
<a name="l01932"></a>01932     <span class="keywordflow">if</span> (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga0c650ad1cdbe06feef020ac64286b834" title="(USBHS_HSTPIPCFG[10]) OUT">USBHS_HSTPIPCFG_PTOKEN_OUT</a> == <a class="code" href="usbhs_8h.html#a7e40c3d1763e18ec62b55c48edadedde" title="Gets USB host interrupt status.">USBHS_HostGetToken</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe)) {
<a name="l01933"></a>01933         <span class="keywordflow">if</span> (pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a21a69dca8be71be6f87e4809f4c83922" title="A short packet is requested for this job on endpoint IN.">b_shortpacket</a>) {
<a name="l01934"></a>01934             <span class="comment">// Need to send a ZLP (No possible with USB DMA)</span>
<a name="l01935"></a>01935             <span class="comment">// enable interrupt to wait a free bank to sent ZLP</span>
<a name="l01936"></a>01936             <a class="code" href="usbhs_8h.html#a97e601451758556ee0591fae627974d8" title="Gets USB host interrupt status.">USBHS_HostAckPipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga0dee7d148bee9d67b2d3f846b2d642b3" title="(USBHS_HSTPIPICR[10]) Transmitted OUT Data Interrupt Clear">USBHS_HSTPIPICR_TXOUTIC</a>);
<a name="l01937"></a>01937 
<a name="l01938"></a>01938             <span class="keywordflow">if</span> (<a class="code" href="usbhs_8h.html#ae752afec4dfecc9565eaa4242ce9233f" title="Gets USB host interrupt status.">USBHS_HostGetIntTypeStatus</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga281964646ce15b9f3f7f0a95160ec1a8" title="(USBHS_HSTPIPISR[10]) Read/Write Allowed">USBHS_HSTPIPISR_RWALL</a>)) {
<a name="l01939"></a>01939                 <span class="comment">// Force interrupt in case of pipe already free</span>
<a name="l01940"></a>01940                 <a class="code" href="usbhs_8h.html#aadbfa6cd7ed91815f4a40b2a92c6d9eb" title="Gets USB host interrupt status.">USBHS_HostSetPipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gae32e0484f0ccbe73701fa041f563eef4" title="(USBHS_HSTPIPIFR[10]) Transmitted OUT Data Interrupt Set">USBHS_HSTPIPIFR_TXOUTIS</a>);
<a name="l01941"></a>01941             }
<a name="l01942"></a>01942 
<a name="l01943"></a>01943             <a class="code" href="usbhs_8h.html#acd60bcdb7e5420ac4cfb8b457838f9ba" title="Gets USB host interrupt status.">USBHS_HostEnablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga5dd1b8ced4705724713f5ec3222c8ee7" title="(USBHS_HSTPIPIER[10]) Transmitted OUT Data Interrupt Enable">USBHS_HSTPIPIER_TXOUTES</a>);
<a name="l01944"></a>01944             <span class="keywordflow">return</span>;
<a name="l01945"></a>01945         }
<a name="l01946"></a>01946     }
<a name="l01947"></a>01947 
<a name="l01948"></a>01948     <span class="comment">// Call callback to signal end of transfer</span>
<a name="l01949"></a>01949     USBH_HAL_PipeXfrEnd(pipe, <a class="code" href="group__uhd__group.html#gga19c67cc9d097b54049dbc7c12119eb83a51f2cf9245d0e0d3e7b421c9e6b301b8" title="Transaction is successful.">UHD_TRANS_NOERROR</a>);
<a name="l01950"></a>01950 }
<a name="l01951"></a>01951 <span class="comment"></span>
<a name="l01952"></a>01952 <span class="comment">/**</span>
<a name="l01953"></a>01953 <span class="comment"> * \internal</span>
<a name="l01954"></a>01954 <span class="comment"> * \brief Manages the pipe DMA interrupt</span>
<a name="l01955"></a>01955 <span class="comment"> *</span>
<a name="l01956"></a>01956 <span class="comment"> * \param pipe  Pipe number</span>
<a name="l01957"></a>01957 <span class="comment"> */</span>
<a name="l01958"></a>01958 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_PipeDmaInterrupt(uint8_t pipe)
<a name="l01959"></a>01959 {
<a name="l01960"></a>01960     <a class="code" href="struct_u_s_b_h___pipe_job__t.html" title="Structure definition to store registered jobs on a pipe.">USBH_PipeJob_t</a> *pJob;
<a name="l01961"></a>01961     uint32_t nb_remaining;
<a name="l01962"></a>01962     <a class="code" href="struct_usbhs.html">Usbhs</a>  *pUdp = USBHS;
<a name="l01963"></a>01963     <a class="code" href="struct_usbhs_hstdma.html" title="UsbhsHstdma hardware registers.">UsbhsHstdma</a> *pUsbDma = &amp;pUdp-&gt;<a class="code" href="struct_usbhs.html#a890006cc761be0b8d6e267edf6fa616c" title="(Usbhs Offset: 0x710) n = 1 .. 7">USBHS_HSTDMA</a>[pipe - 1];
<a name="l01964"></a>01964 
<a name="l01965"></a>01965     SCB_CleanInvalidateDCache();
<a name="l01966"></a>01966 
<a name="l01967"></a>01967     <span class="keywordflow">if</span> (<a class="code" href="usbhs_8h.html#a867c067ec59082580389661c677469ea" title="Get Dma Status.">USBHS_GetHostPipeDmaStatus</a>(pUsbDma) &amp; <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga0319af24ed59957f9bd0fb1ea88cd649" title="(USBHS_HSTDMASTATUS) Channel Enable Status">USBHS_HSTDMASTATUS_CHANN_ENB</a>) {
<a name="l01968"></a>01968         <span class="keywordflow">return</span>; <span class="comment">// Ignore EOT_STA interrupt</span>
<a name="l01969"></a>01969     }
<a name="l01970"></a>01970 
<a name="l01971"></a>01971     <span class="comment">// Save number of data no transfered</span>
<a name="l01972"></a>01972     nb_remaining = ( (<a class="code" href="usbhs_8h.html#a867c067ec59082580389661c677469ea" title="Get Dma Status.">USBHS_GetHostPipeDmaStatus</a>(pUsbDma) &amp;
<a name="l01973"></a>01973                       USBHS_HSTDMASTATUS_BUFF_COUNT_Msk) &gt;&gt; USBHS_HSTDMASTATUS_BUFF_COUNT_Pos);
<a name="l01974"></a>01974     memory_sync();
<a name="l01975"></a>01975 
<a name="l01976"></a>01976     <span class="keywordflow">if</span> (nb_remaining) {
<a name="l01977"></a>01977         <span class="comment">// Get job corresponding at endpoint</span>
<a name="l01978"></a>01978         pJob = &amp;uhd_pipe_job[pipe - 1];
<a name="l01979"></a>01979 
<a name="l01980"></a>01980         <span class="comment">// Transfer no complete (short packet or ZLP) then:</span>
<a name="l01981"></a>01981         <span class="comment">// Update number of transfered data</span>
<a name="l01982"></a>01982         pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#afd8c90263aef338ab94344013a0c8162" title="Total number of transfered data on endpoint.">nb_trans</a> -= nb_remaining;
<a name="l01983"></a>01983 
<a name="l01984"></a>01984         <span class="comment">// Set transfer complete to stop the transfer</span>
<a name="l01985"></a>01985         pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a9f7a2c3bfe2d805a5328dae0dd3d6648" title="Size of buffer to send or fill.">buf_size</a> = pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#afd8c90263aef338ab94344013a0c8162" title="Total number of transfered data on endpoint.">nb_trans</a>;
<a name="l01986"></a>01986     }
<a name="l01987"></a>01987 
<a name="l01988"></a>01988     <span class="keywordflow">if</span> (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga0c650ad1cdbe06feef020ac64286b834" title="(USBHS_HSTPIPCFG[10]) OUT">USBHS_HSTPIPCFG_PTOKEN_OUT</a> == <a class="code" href="usbhs_8h.html#a7e40c3d1763e18ec62b55c48edadedde" title="Gets USB host interrupt status.">USBHS_HostGetToken</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe)) {
<a name="l01989"></a>01989         <span class="comment">// Wait that all banks are free to freeze clock of OUT endpoint</span>
<a name="l01990"></a>01990         <span class="comment">// and call callback</span>
<a name="l01991"></a>01991         <a class="code" href="usbhs_8h.html#acd60bcdb7e5420ac4cfb8b457838f9ba" title="Gets USB host interrupt status.">USBHS_HostEnablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga8cd1bd3dd202a99c1e4a2f80539dc31c" title="(USBHS_HSTPIPIER[10]) Number of Busy Banks Enable">USBHS_HSTPIPIER_NBUSYBKES</a>);
<a name="l01992"></a>01992 
<a name="l01993"></a>01993         <span class="comment">// For ISO out, start another DMA transfer since no ACK needed</span>
<a name="l01994"></a>01994         <span class="keywordflow">if</span> (<a class="code" href="usbhs_8h.html#a568fb6f40affb306e060461fe065a516" title="Gets USB host interrupt status.">USBHS_HostGetPipeType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe) == <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga6b03ffb635a9a12458fc316d49bfb18e" title="(USBHS_HSTPIPCFG[10]) Isochronous">USBHS_HSTPIPCFG_PTYPE_ISO</a>)
<a name="l01995"></a>01995             USBH_HAL_PipeXfrEnd(pipe, <a class="code" href="group__uhd__group.html#gga19c67cc9d097b54049dbc7c12119eb83a51f2cf9245d0e0d3e7b421c9e6b301b8" title="Transaction is successful.">UHD_TRANS_NOERROR</a>);
<a name="l01996"></a>01996     } <span class="keywordflow">else</span> {
<a name="l01997"></a>01997         <span class="keywordflow">if</span> (!<a class="code" href="usbhs_8h.html#a0a8e28b882f4abf73c473980d36c7e06" title="Gets USB host interrupt status.">USBHS_IsHostPipeIntTypeEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga7c445ad9e88f7bd07fa360f3ee17acbe" title="(USBHS_HSTPIPIMR[10]) Pipe Freeze">USBHS_HSTPIPIMR_PFREEZE</a>)) {
<a name="l01998"></a>01998             <span class="comment">// Pipe is not freeze in case of :</span>
<a name="l01999"></a>01999             <span class="comment">// - incomplete transfer when the request number INRQ is not complete.</span>
<a name="l02000"></a>02000             <span class="comment">// - low USB speed and with a high CPU frequency,</span>
<a name="l02001"></a>02001             <span class="comment">// a ACK from host can be always running on USB line.</span>
<a name="l02002"></a>02002 
<a name="l02003"></a>02003             <span class="keywordflow">if</span> (nb_remaining) {
<a name="l02004"></a>02004                 <span class="comment">// Freeze pipe in case of incomplete transfer</span>
<a name="l02005"></a>02005                 <a class="code" href="usbhs_8h.html#acd60bcdb7e5420ac4cfb8b457838f9ba" title="Gets USB host interrupt status.">USBHS_HostEnablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga8a09e9f1a8824d9033ebfa3a0570d848" title="(USBHS_HSTPIPIER[10]) Pipe Freeze Enable">USBHS_HSTPIPIER_PFREEZES</a>);
<a name="l02006"></a>02006             } <span class="keywordflow">else</span> {
<a name="l02007"></a>02007                 <span class="comment">// Wait freeze in case of ASK on going</span>
<a name="l02008"></a>02008                 <span class="keywordflow">while</span> (!<a class="code" href="usbhs_8h.html#a0a8e28b882f4abf73c473980d36c7e06" title="Gets USB host interrupt status.">USBHS_IsHostPipeIntTypeEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga7c445ad9e88f7bd07fa360f3ee17acbe" title="(USBHS_HSTPIPIMR[10]) Pipe Freeze">USBHS_HSTPIPIMR_PFREEZE</a>)) {
<a name="l02009"></a>02009                 }
<a name="l02010"></a>02010             }
<a name="l02011"></a>02011         }
<a name="l02012"></a>02012 
<a name="l02013"></a>02013         USBH_HAL_PipeXfrCmplt(pipe);
<a name="l02014"></a>02014     }
<a name="l02015"></a>02015 }
<a name="l02016"></a>02016 <span class="preprocessor">#endif // ifdef UHD_PIPE_DMA_SUPPORTED</span>
<a name="l02017"></a>02017 <span class="preprocessor"></span><span class="comment"></span>
<a name="l02018"></a>02018 <span class="comment">/**</span>
<a name="l02019"></a>02019 <span class="comment"> * \internal</span>
<a name="l02020"></a>02020 <span class="comment"> * \brief Manages the following pipe interrupts:</span>
<a name="l02021"></a>02021 <span class="comment"> * - Real end of USB transfers (bank empty)</span>
<a name="l02022"></a>02022 <span class="comment"> * - One bank is free to send a OUT ZLP</span>
<a name="l02023"></a>02023 <span class="comment"> * - Stall received</span>
<a name="l02024"></a>02024 <span class="comment"> * - Error during transfer</span>
<a name="l02025"></a>02025 <span class="comment"> *</span>
<a name="l02026"></a>02026 <span class="comment"> * \param pipe  Pipe number</span>
<a name="l02027"></a>02027 <span class="comment"> */</span>
<a name="l02028"></a>02028 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_PipeInterrupt(uint8_t pipe)
<a name="l02029"></a>02029 {
<a name="l02030"></a>02030     uint32_t status = <a class="code" href="usbhs_8h.html#ae752afec4dfecc9565eaa4242ce9233f" title="Gets USB host interrupt status.">USBHS_HostGetIntTypeStatus</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, 0xFFFFFFFF);
<a name="l02031"></a>02031     uint32_t statusInt = status &amp; <a class="code" href="usbhs_8h.html#a0a8e28b882f4abf73c473980d36c7e06" title="Gets USB host interrupt status.">USBHS_IsHostPipeIntTypeEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe,
<a name="l02032"></a>02032                          0xFFFFFFFF);
<a name="l02033"></a>02033 <span class="preprocessor">#ifdef UHD_PIPE_FIFO_SUPPORTED</span>
<a name="l02034"></a>02034 <span class="preprocessor"></span>
<a name="l02035"></a>02035     <span class="comment">// for none DMA endpoints</span>
<a name="l02036"></a>02036     <span class="keywordflow">if</span> (!<a class="code" href="usbhs_8h.html#adaafe4bea8556d5c5450ea0ccd9c3a5a" title="Get DMA support of endpoints.">Is_uhd_pipe_dma_supported</a>(pipe)) {
<a name="l02037"></a>02037         <span class="comment">// SHORTPACKETI: Short received</span>
<a name="l02038"></a>02038         <span class="keywordflow">if</span> (statusInt &amp; <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga24f69fdd9e7c0327a46178c23dffba8a" title="(USBHS_HSTPIPISR[10]) Short Packet Interrupt">USBHS_HSTPIPISR_SHORTPACKETI</a>) {
<a name="l02039"></a>02039             <a class="code" href="usbhs_8h.html#a97e601451758556ee0591fae627974d8" title="Gets USB host interrupt status.">USBHS_HostAckPipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe,
<a name="l02040"></a>02040                                      <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga78cb30399ab291612e71d221afe83b74" title="(USBHS_HSTPIPICR[10]) Short Packet Interrupt Clear">USBHS_HSTPIPICR_SHORTPACKETIC</a>); <span class="comment">//uhd_ack_short_packet(pipe);</span>
<a name="l02041"></a>02041             USBH_HAL_PipeInReceived(pipe);
<a name="l02042"></a>02042             <span class="keywordflow">return</span>;
<a name="l02043"></a>02043         }
<a name="l02044"></a>02044 
<a name="l02045"></a>02045         <span class="comment">// RXIN: Full packet received</span>
<a name="l02046"></a>02046         <span class="keywordflow">if</span> (statusInt &amp; <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gaf9ad12bf25420763cff4831d07b0e40b" title="(USBHS_HSTPIPIMR[10]) Received IN Data Interrupt Enable">USBHS_HSTPIPIMR_RXINE</a> ) {
<a name="l02047"></a>02047             <a class="code" href="usbhs_8h.html#a97e601451758556ee0591fae627974d8" title="Gets USB host interrupt status.">USBHS_HostAckPipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe,
<a name="l02048"></a>02048                                      <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga9067ea47ec30664e8fd73e8ab7e35181" title="(USBHS_HSTPIPICR[10]) Received IN Data Interrupt Clear">USBHS_HSTPIPICR_RXINIC</a>);<span class="comment">//uhd_ack_in_received(pipe);</span>
<a name="l02049"></a>02049             USBH_HAL_PipeInReceived(pipe);
<a name="l02050"></a>02050             <span class="keywordflow">return</span>;
<a name="l02051"></a>02051         }
<a name="l02052"></a>02052 
<a name="l02053"></a>02053         <span class="comment">// TXOUT: packet sent</span>
<a name="l02054"></a>02054         <span class="keywordflow">if</span> (statusInt &amp; <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gab412d773f75086777987bce75d9c2c79" title="(USBHS_HSTPIPISR[10]) Transmitted OUT Data Interrupt">USBHS_HSTPIPISR_TXOUTI</a>) {
<a name="l02055"></a>02055             USBH_HAL_PipeOutReady(pipe);
<a name="l02056"></a>02056             <span class="keywordflow">return</span>;
<a name="l02057"></a>02057         }
<a name="l02058"></a>02058 
<a name="l02059"></a>02059         <span class="comment">// OUT: all banks sent</span>
<a name="l02060"></a>02060         <span class="keywordflow">if</span> (<a class="code" href="usbhs_8h.html#a0a8e28b882f4abf73c473980d36c7e06" title="Gets USB host interrupt status.">USBHS_IsHostPipeIntTypeEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga52f9964410273efb2afbcb794ec3619e" title="(USBHS_HSTPIPIMR[10]) Number of Busy Banks Interrupt Enable">USBHS_HSTPIPIMR_NBUSYBKE</a>)
<a name="l02061"></a>02061             &amp;&amp; (0 == <a class="code" href="usbhs_8h.html#a556066e182615fc6072e5b6ad6a915c0" title="Gets USB host interrupt status.">USBHS_HostGetNumOfBusyBank</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe))) {
<a name="l02062"></a>02062             <a class="code" href="usbhs_8h.html#acd60bcdb7e5420ac4cfb8b457838f9ba" title="Gets USB host interrupt status.">USBHS_HostEnablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga8a09e9f1a8824d9033ebfa3a0570d848" title="(USBHS_HSTPIPIER[10]) Pipe Freeze Enable">USBHS_HSTPIPIER_PFREEZES</a>);
<a name="l02063"></a>02063             <a class="code" href="usbhs_8h.html#a32c56acaace52b440a308d9bce8cafff" title="Gets USB host interrupt status.">USBHS_HostDisablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gad3bb07d57156a86a6ac3534c0f07c8ab" title="(USBHS_HSTPIPIDR[10]) Number of Busy Banks Disable">USBHS_HSTPIPIDR_NBUSYBKEC</a> );
<a name="l02064"></a>02064             <span class="comment">//uhd_disable_bank_interrupt(pipe);</span>
<a name="l02065"></a>02065             <a class="code" href="usbhs_8h.html#a4706c65710ae219aab80c2645d24fa81" title="Gets USB host interrupt status.">USBHS_HostPipeIntDisable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe);
<a name="l02066"></a>02066             <span class="comment">//uhd_disable_pipe_interrupt(pipe);</span>
<a name="l02067"></a>02067             <a class="code" href="usbhs_8h.html#aa347527d17e6ee48869cabe3344f0b8e" title="Gets USB host interrupt status.">USBHS_HostEnableAutoSw</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe);
<a name="l02068"></a>02068             <span class="comment">//uhd_enable_pipe_bank_autoswitch (pipe);</span>
<a name="l02069"></a>02069             USBH_HAL_PipeXfrEnd(pipe, <a class="code" href="group__uhd__group.html#gga19c67cc9d097b54049dbc7c12119eb83a51f2cf9245d0e0d3e7b421c9e6b301b8" title="Transaction is successful.">UHD_TRANS_NOERROR</a>);
<a name="l02070"></a>02070             <span class="keywordflow">return</span>;
<a name="l02071"></a>02071         }
<a name="l02072"></a>02072 
<a name="l02073"></a>02073         <span class="keywordflow">if</span> (status &amp; <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga49bab8fafde4c709dd7decb1c97b0503" title="(USBHS_HSTPIPISR[10]) Received STALLed Interrupt">USBHS_HSTPIPISR_RXSTALLDI</a>) {
<a name="l02074"></a>02074             <a class="code" href="usbhs_8h.html#a97e601451758556ee0591fae627974d8" title="Gets USB host interrupt status.">USBHS_HostAckPipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe,
<a name="l02075"></a>02075                                      <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gaae263c0a5e8d2cd8c473fe9219cc66a8" title="(USBHS_HSTPIPICR[10]) Received STALLed Interrupt Clear">USBHS_HSTPIPICR_RXSTALLDIC</a>); <span class="comment">//uhd_ack_stall(pipe);</span>
<a name="l02076"></a>02076             <a class="code" href="usbhs_8h.html#acd60bcdb7e5420ac4cfb8b457838f9ba" title="Gets USB host interrupt status.">USBHS_HostEnablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gaf62474721067494d9ab289d8167421b3" title="(USBHS_HSTPIPIER[10]) Reset Data Toggle Enable">USBHS_HSTPIPIER_RSTDTS</a>);
<a name="l02077"></a>02077             <span class="comment">//uhd_reset_data_toggle(pipe);</span>
<a name="l02078"></a>02078             USBH_HAL_PipeAbort(pipe, <a class="code" href="group__uhd__group.html#gga19c67cc9d097b54049dbc7c12119eb83a5743eea90e7ad818b4c29ff54cfc67a9" title="The endpoint returned a STALL PID.">UHD_TRANS_STALL</a>);
<a name="l02079"></a>02079             <span class="keywordflow">return</span>;
<a name="l02080"></a>02080         }
<a name="l02081"></a>02081 
<a name="l02082"></a>02082         <span class="keywordflow">if</span> (status &amp; <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga73998e12ffdfca1ab0bc9cf53797332c" title="(USBHS_HSTPIPISR[10]) Pipe Error Interrupt">USBHS_HSTPIPISR_PERRI</a>) {
<a name="l02083"></a>02083             <span class="comment">// Get and ack error</span>
<a name="l02084"></a>02084             USBH_HAL_PipeAbort(pipe, USBH_HAL_GetPipeError(pipe));
<a name="l02085"></a>02085             <span class="keywordflow">return</span>;
<a name="l02086"></a>02086         }
<a name="l02087"></a>02087 
<a name="l02088"></a>02088         assert(<span class="keyword">false</span>); <span class="comment">// Error system</span>
<a name="l02089"></a>02089         <span class="keywordflow">return</span>;
<a name="l02090"></a>02090     }
<a name="l02091"></a>02091 
<a name="l02092"></a>02092 <span class="preprocessor">#endif // UDD_EP_FIFO_SUPPORTED</span>
<a name="l02093"></a>02093 <span class="preprocessor"></span>
<a name="l02094"></a>02094 <span class="preprocessor">#ifdef UHD_PIPE_DMA_SUPPORTED</span>
<a name="l02095"></a>02095 <span class="preprocessor"></span>
<a name="l02096"></a>02096     <span class="comment">// for DMA endpoints</span>
<a name="l02097"></a>02097     <span class="keywordflow">if</span> (<a class="code" href="usbhs_8h.html#a0a8e28b882f4abf73c473980d36c7e06" title="Gets USB host interrupt status.">USBHS_IsHostPipeIntTypeEnable</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga52f9964410273efb2afbcb794ec3619e" title="(USBHS_HSTPIPIMR[10]) Number of Busy Banks Interrupt Enable">USBHS_HSTPIPIMR_NBUSYBKE</a>)
<a name="l02098"></a>02098         &amp;&amp; (0 == <a class="code" href="usbhs_8h.html#a556066e182615fc6072e5b6ad6a915c0" title="Gets USB host interrupt status.">USBHS_HostGetNumOfBusyBank</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe))) {
<a name="l02099"></a>02099         <a class="code" href="usbhs_8h.html#acd60bcdb7e5420ac4cfb8b457838f9ba" title="Gets USB host interrupt status.">USBHS_HostEnablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe,
<a name="l02100"></a>02100                                     <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga8a09e9f1a8824d9033ebfa3a0570d848" title="(USBHS_HSTPIPIER[10]) Pipe Freeze Enable">USBHS_HSTPIPIER_PFREEZES</a>);<span class="comment">//uhd_freeze_pipe(pipe);</span>
<a name="l02101"></a>02101         <a class="code" href="usbhs_8h.html#a32c56acaace52b440a308d9bce8cafff" title="Gets USB host interrupt status.">USBHS_HostDisablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe,
<a name="l02102"></a>02102                                      <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gad3bb07d57156a86a6ac3534c0f07c8ab" title="(USBHS_HSTPIPIDR[10]) Number of Busy Banks Disable">USBHS_HSTPIPIDR_NBUSYBKEC</a>);<span class="comment">//uhd_disable_bank_interrupt(pipe);</span>
<a name="l02103"></a>02103 
<a name="l02104"></a>02104         <span class="comment">// For ISO, no ACK, finished when DMA done</span>
<a name="l02105"></a>02105         <span class="keywordflow">if</span> (!(<a class="code" href="usbhs_8h.html#a568fb6f40affb306e060461fe065a516" title="Gets USB host interrupt status.">USBHS_HostGetPipeType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe) == <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga6b03ffb635a9a12458fc316d49bfb18e" title="(USBHS_HSTPIPCFG[10]) Isochronous">USBHS_HSTPIPCFG_PTYPE_ISO</a>))
<a name="l02106"></a>02106             USBH_HAL_PipeXfrEnd(pipe, <a class="code" href="group__uhd__group.html#gga19c67cc9d097b54049dbc7c12119eb83a51f2cf9245d0e0d3e7b421c9e6b301b8" title="Transaction is successful.">UHD_TRANS_NOERROR</a>);
<a name="l02107"></a>02107 
<a name="l02108"></a>02108         <span class="keywordflow">return</span>;
<a name="l02109"></a>02109     }
<a name="l02110"></a>02110 
<a name="l02111"></a>02111     <span class="keywordflow">if</span> (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga0539e2356a3f274b330397c434ea986f" title="(USBHS_HSTPIPIMR[10]) Transmitted OUT Data Interrupt Enable">USBHS_HSTPIPIMR_TXOUTE</a> &amp; statusInt) {
<a name="l02112"></a>02112         <a class="code" href="usbhs_8h.html#a32c56acaace52b440a308d9bce8cafff" title="Gets USB host interrupt status.">USBHS_HostDisablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga19293155d73146950142d5284d73b490" title="(USBHS_HSTPIPIDR[10]) Transmitted OUT Data Interrupt Disable">USBHS_HSTPIPIDR_TXOUTEC</a>);
<a name="l02113"></a>02113         <span class="comment">//uhd_disable_out_ready_interrupt(pipe);</span>
<a name="l02114"></a>02114         <span class="comment">// One bank is free then send a ZLP</span>
<a name="l02115"></a>02115         <a class="code" href="usbhs_8h.html#a97e601451758556ee0591fae627974d8" title="Gets USB host interrupt status.">USBHS_HostAckPipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe,
<a name="l02116"></a>02116                                  <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga0dee7d148bee9d67b2d3f846b2d642b3" title="(USBHS_HSTPIPICR[10]) Transmitted OUT Data Interrupt Clear">USBHS_HSTPIPICR_TXOUTIC</a>); <span class="comment">//uhd_ack_out_ready(pipe);</span>
<a name="l02117"></a>02117         <a class="code" href="usbhs_8h.html#a32c56acaace52b440a308d9bce8cafff" title="Gets USB host interrupt status.">USBHS_HostDisablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe,
<a name="l02118"></a>02118                                      (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gabcec9beefeab1700242da4c88f1b7a51" title="(USBHS_HSTPIPIDR[10]) FIFO Control Disable">USBHS_HSTPIPIDR_FIFOCONC</a> | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga2b99057bec6aa1f5a541cede730c657e" title="(USBHS_HSTPIPIDR[10]) Pipe Freeze Disable">USBHS_HSTPIPIDR_PFREEZEC</a>));
<a name="l02119"></a>02119         <span class="comment">//USBHS_HostDisablePipeIntType(USBHS, pipe, );</span>
<a name="l02120"></a>02120         <a class="code" href="usbhs_8h.html#acd60bcdb7e5420ac4cfb8b457838f9ba" title="Gets USB host interrupt status.">USBHS_HostEnablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga8cd1bd3dd202a99c1e4a2f80539dc31c" title="(USBHS_HSTPIPIER[10]) Number of Busy Banks Enable">USBHS_HSTPIPIER_NBUSYBKES</a>);
<a name="l02121"></a>02121         <span class="keywordflow">return</span>;
<a name="l02122"></a>02122     }
<a name="l02123"></a>02123 
<a name="l02124"></a>02124     <span class="keywordflow">if</span> (status &amp; USBHS_HSTPIPISR_RXSTALLDI) {
<a name="l02125"></a>02125         <a class="code" href="usbhs_8h.html#a97e601451758556ee0591fae627974d8" title="Gets USB host interrupt status.">USBHS_HostAckPipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe,
<a name="l02126"></a>02126                                  <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gaae263c0a5e8d2cd8c473fe9219cc66a8" title="(USBHS_HSTPIPICR[10]) Received STALLed Interrupt Clear">USBHS_HSTPIPICR_RXSTALLDIC</a>);<span class="comment">//uhd_ack_stall(pipe);</span>
<a name="l02127"></a>02127         <a class="code" href="usbhs_8h.html#acd60bcdb7e5420ac4cfb8b457838f9ba" title="Gets USB host interrupt status.">USBHS_HostEnablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gaf62474721067494d9ab289d8167421b3" title="(USBHS_HSTPIPIER[10]) Reset Data Toggle Enable">USBHS_HSTPIPIER_RSTDTS</a>);
<a name="l02128"></a>02128         USBH_HAL_PipeAbort(pipe, <a class="code" href="group__uhd__group.html#gga19c67cc9d097b54049dbc7c12119eb83a5743eea90e7ad818b4c29ff54cfc67a9" title="The endpoint returned a STALL PID.">UHD_TRANS_STALL</a>);
<a name="l02129"></a>02129         <span class="keywordflow">return</span>;
<a name="l02130"></a>02130     }
<a name="l02131"></a>02131 
<a name="l02132"></a>02132     <span class="keywordflow">if</span> (status &amp; USBHS_HSTPIPISR_PERRI) {
<a name="l02133"></a>02133         <span class="comment">// Get and ack error</span>
<a name="l02134"></a>02134         USBH_HAL_PipeAbort(pipe, USBH_HAL_GetPipeError(pipe));
<a name="l02135"></a>02135         <span class="keywordflow">return</span>;
<a name="l02136"></a>02136     }
<a name="l02137"></a>02137 
<a name="l02138"></a>02138     assert(<span class="keyword">false</span>); <span class="comment">// Error system</span>
<a name="l02139"></a>02139 <span class="preprocessor">#endif // UHD_PIPE_DMA_SUPPORTED</span>
<a name="l02140"></a>02140 <span class="preprocessor"></span>}
<a name="l02141"></a>02141 <span class="comment"></span>
<a name="l02142"></a>02142 <span class="comment">/**</span>
<a name="l02143"></a>02143 <span class="comment"> * \internal</span>
<a name="l02144"></a>02144 <span class="comment"> * \brief Aborts the on going transfer on a pipe</span>
<a name="l02145"></a>02145 <span class="comment"> *</span>
<a name="l02146"></a>02146 <span class="comment"> * \param pipe Pipe number</span>
<a name="l02147"></a>02147 <span class="comment"> * \param status Reason of abort</span>
<a name="l02148"></a>02148 <span class="comment"> */</span>
<a name="l02149"></a>02149 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_PipeAbort(uint8_t pipe, <a class="code" href="group__uhd__group.html#ga19c67cc9d097b54049dbc7c12119eb83" title="Endpoint transfer status The status field is updated after each transaction attempt, whether successful or not.">USBH_XfrStatus_t</a> status)
<a name="l02150"></a>02150 {
<a name="l02151"></a>02151     <a class="code" href="struct_usbhs.html">Usbhs</a> *pUdp = USBHS;
<a name="l02152"></a>02152     <a class="code" href="struct_usbhs_hstdma.html" title="UsbhsHstdma hardware registers.">UsbhsHstdma</a> *pUsbDma = &amp;pUdp-&gt;<a class="code" href="struct_usbhs.html#a890006cc761be0b8d6e267edf6fa616c" title="(Usbhs Offset: 0x710) n = 1 .. 7">USBHS_HSTDMA</a>[pipe - 1];
<a name="l02153"></a>02153     <span class="comment">// Stop transfer</span>
<a name="l02154"></a>02154     <a class="code" href="usbhs_8h.html#af0f50fcf9d7a16354a3a3a1b22140a4c" title="Gets USB host interrupt status.">USBHS_HostPipeReset</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe);
<a name="l02155"></a>02155 
<a name="l02156"></a>02156     <span class="comment">// Autoswitch bank and interrupts has been reseted, then re-enable it</span>
<a name="l02157"></a>02157     <a class="code" href="usbhs_8h.html#aa347527d17e6ee48869cabe3344f0b8e" title="Gets USB host interrupt status.">USBHS_HostEnableAutoSw</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe);
<a name="l02158"></a>02158     <a class="code" href="usbhs_8h.html#acd60bcdb7e5420ac4cfb8b457838f9ba" title="Gets USB host interrupt status.">USBHS_HostEnablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe,
<a name="l02159"></a>02159                                 (<a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#gab16e4bf12ba2658f953e4deaaa5dd511" title="(USBHS_HSTPIPIER[10]) Received STALLed Interrupt Enable">USBHS_HSTPIPIER_RXSTALLDES</a> | <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga233107ba8d4fb36bc0362bf1628b4570" title="(USBHS_HSTPIPIER[10]) Pipe Error Interrupt Enable">USBHS_HSTPIPIER_PERRES</a>) );
<a name="l02160"></a>02160     <span class="comment">//uhd_enable_pipe_error_interrupt(pipe);</span>
<a name="l02161"></a>02161     <a class="code" href="usbhs_8h.html#a32c56acaace52b440a308d9bce8cafff" title="Gets USB host interrupt status.">USBHS_HostDisablePipeIntType</a>(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe, <a class="code" href="group___s_a_m_e70___u_s_b_h_s.html#ga19293155d73146950142d5284d73b490" title="(USBHS_HSTPIPIDR[10]) Transmitted OUT Data Interrupt Disable">USBHS_HSTPIPIDR_TXOUTEC</a>);
<a name="l02162"></a>02162 <span class="preprocessor">#ifdef UHD_PIPE_DMA_SUPPORTED</span>
<a name="l02163"></a>02163 <span class="preprocessor"></span>
<a name="l02164"></a>02164     <span class="keywordflow">if</span> (<a class="code" href="usbhs_8h.html#adaafe4bea8556d5c5450ea0ccd9c3a5a" title="Get DMA support of endpoints.">Is_uhd_pipe_dma_supported</a>(pipe))
<a name="l02165"></a>02165         <a class="code" href="usbhs_8h.html#ad212cc35348ff023533b9a47aba79345" title="Setup the USBHS DMA.">USBHS_HostConfigureDma</a>(pUsbDma, 0);
<a name="l02166"></a>02166 
<a name="l02167"></a>02167 <span class="preprocessor">#endif</span>
<a name="l02168"></a>02168 <span class="preprocessor"></span>    USBH_HAL_PipeXfrEnd(pipe, status);
<a name="l02169"></a>02169 }
<a name="l02170"></a>02170 <span class="comment"></span>
<a name="l02171"></a>02171 <span class="comment">/**</span>
<a name="l02172"></a>02172 <span class="comment"> * \internal</span>
<a name="l02173"></a>02173 <span class="comment"> * \brief Call the callback linked to the end of pipe transfer</span>
<a name="l02174"></a>02174 <span class="comment"> *</span>
<a name="l02175"></a>02175 <span class="comment"> * \param pipe Pipe number</span>
<a name="l02176"></a>02176 <span class="comment"> * \param status Status of the transfer</span>
<a name="l02177"></a>02177 <span class="comment"> */</span>
<a name="l02178"></a>02178 <span class="keyword">static</span> <span class="keywordtype">void</span> USBH_HAL_PipeXfrEnd(uint8_t pipe, <a class="code" href="group__uhd__group.html#ga19c67cc9d097b54049dbc7c12119eb83" title="Endpoint transfer status The status field is updated after each transaction attempt, whether successful or not.">USBH_XfrStatus_t</a> status)
<a name="l02179"></a>02179 {
<a name="l02180"></a>02180     uint32_t dev_addr , dev_ep;
<a name="l02181"></a>02181     <a class="code" href="struct_u_s_b_h___pipe_job__t.html" title="Structure definition to store registered jobs on a pipe.">USBH_PipeJob_t</a> *pJob;
<a name="l02182"></a>02182 
<a name="l02183"></a>02183     <span class="comment">// Get job corresponding at endpoint</span>
<a name="l02184"></a>02184     pJob = &amp;uhd_pipe_job[pipe - 1];
<a name="l02185"></a>02185 
<a name="l02186"></a>02186     <span class="keywordflow">if</span> (pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a07b75fbf986996a3382967085a7362d0" title="A job is registered on this pipe.">busy</a> == <span class="keyword">false</span>) {
<a name="l02187"></a>02187         <span class="keywordflow">return</span>; <span class="comment">// No job running</span>
<a name="l02188"></a>02188     }
<a name="l02189"></a>02189 
<a name="l02190"></a>02190     pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#a07b75fbf986996a3382967085a7362d0" title="A job is registered on this pipe.">busy</a> = <span class="keyword">false</span>;
<a name="l02191"></a>02191 
<a name="l02192"></a>02192     <span class="keywordflow">if</span> (NULL == pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#ac42e3e3067edeba6bbb5831de8270f06" title="Callback to call at the end of transfer.">call_end</a>) {
<a name="l02193"></a>02193         <span class="keywordflow">return</span>; <span class="comment">// No callback linked to job</span>
<a name="l02194"></a>02194     }
<a name="l02195"></a>02195 
<a name="l02196"></a>02196     dev_addr = USBHS_HostGetAddr(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe);
<a name="l02197"></a>02197     dev_ep = USBHS_GetPipeEpAddr(<a class="code" href="group___s_a_m_e70_j19__base.html#ga583c4e09fb87b6c2e14fd1f6c8f344f9" title="(USBHS ) Base Address">USBHS</a>, pipe);
<a name="l02198"></a>02198     pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#ac42e3e3067edeba6bbb5831de8270f06" title="Callback to call at the end of transfer.">call_end</a>(dev_addr, dev_ep, status, pJob-&gt;<a class="code" href="struct_u_s_b_h___pipe_job__t.html#afd8c90263aef338ab94344013a0c8162" title="Total number of transfered data on endpoint.">nb_trans</a>);
<a name="l02199"></a>02199 }
<a name="l02200"></a>02200 <span class="comment"></span>
<a name="l02201"></a>02201 <span class="comment">//@}</span>
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
