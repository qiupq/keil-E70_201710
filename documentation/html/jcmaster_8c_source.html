<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SAME70 Xplained Software Package: libraries/libjpeg/source/jcmaster.c Source File</title>
<link href="common/style.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
    <div id="body">
        <div id="title">  SAME70 Xplained Software Package 1.5</div>
        <div id="banner"></div>

<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="dir_81818f1c1b01098ad6d8389f2aaf9f72.html">libraries</a>      </li>
      <li><a class="el" href="dir_8389523b68569e491c127b14eb10550e.html">libjpeg</a>      </li>
      <li><a class="el" href="dir_42075f322a856ce8045a3da18b3efa6e.html">source</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>jcmaster.c</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * jcmaster.c</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * Copyright (C) 1991-1997, Thomas G. Lane.</span>
<a name="l00005"></a>00005 <span class="comment"> * Modified 2003-2010 by Guido Vollbeding.</span>
<a name="l00006"></a>00006 <span class="comment"> * This file is part of the Independent JPEG Group&#39;s software.</span>
<a name="l00007"></a>00007 <span class="comment"> * For conditions of distribution and use, see the accompanying README file.</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> * This file contains master control logic for the JPEG compressor.</span>
<a name="l00010"></a>00010 <span class="comment"> * These routines are concerned with parameter validation, initial setup,</span>
<a name="l00011"></a>00011 <span class="comment"> * and inter-pass control (determining the number of passes and the work </span>
<a name="l00012"></a>00012 <span class="comment"> * to be done in each pass).</span>
<a name="l00013"></a>00013 <span class="comment"> */</span>
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 <span class="preprocessor">#define JPEG_INTERNALS</span>
<a name="l00016"></a>00016 <span class="preprocessor"></span><span class="preprocessor">#include &quot;jinclude.h&quot;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &quot;jpeglib.h&quot;</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="comment">/* Private state */</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="keyword">typedef</span> <span class="keyword">enum</span> {
<a name="l00023"></a>00023     main_pass,      <span class="comment">/* input data, also do first output step */</span>
<a name="l00024"></a>00024     huff_opt_pass,      <span class="comment">/* Huffman code optimization pass */</span>
<a name="l00025"></a>00025     output_pass     <span class="comment">/* data output pass */</span>
<a name="l00026"></a>00026 } c_pass_type;
<a name="l00027"></a>00027 
<a name="l00028"></a><a class="code" href="structmy__comp__master.html">00028</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00029"></a>00029   <span class="keyword">struct </span><a class="code" href="structjpeg__comp__master.html">jpeg_comp_master</a> pub;  <span class="comment">/* public fields */</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031   c_pass_type pass_type;    <span class="comment">/* the type of the current pass */</span>
<a name="l00032"></a>00032 
<a name="l00033"></a>00033   <span class="keywordtype">int</span> pass_number;      <span class="comment">/* # of passes completed */</span>
<a name="l00034"></a>00034   <span class="keywordtype">int</span> total_passes;     <span class="comment">/* total # of passes needed */</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036   <span class="keywordtype">int</span> scan_number;      <span class="comment">/* current index in scan_info[] */</span>
<a name="l00037"></a>00037 } <a class="code" href="structmy__comp__master.html">my_comp_master</a>;
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="keyword">typedef</span> <a class="code" href="structmy__comp__master.html">my_comp_master</a> * <a class="code" href="structmy__comp__master.html">my_master_ptr</a>;
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="comment">/*</span>
<a name="l00043"></a>00043 <span class="comment"> * Support routines that do various essential calculations.</span>
<a name="l00044"></a>00044 <span class="comment"> */</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="comment">/*</span>
<a name="l00047"></a>00047 <span class="comment"> * Compute JPEG image dimensions and related values.</span>
<a name="l00048"></a>00048 <span class="comment"> * NOTE: this is exported for possible use by application.</span>
<a name="l00049"></a>00049 <span class="comment"> * Hence it mustn&#39;t do anything that can&#39;t be done twice.</span>
<a name="l00050"></a>00050 <span class="comment"> */</span>
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 GLOBAL(<span class="keywordtype">void</span>)
<a name="l00053"></a>00053 jpeg_calc_jpeg_dimensions (j_compress_ptr cinfo)
<a name="l00054"></a>00054 <span class="comment">/* Do computations that are needed before master selection phase */</span>
<a name="l00055"></a>00055 {
<a name="l00056"></a>00056 <span class="preprocessor">#ifdef DCT_SCALING_SUPPORTED</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span>
<a name="l00058"></a>00058   <span class="comment">/* Compute actual JPEG image dimensions and DCT scaling choices. */</span>
<a name="l00059"></a>00059   <span class="keywordflow">if</span> (cinfo-&gt;scale_num &gt;= cinfo-&gt;scale_denom * 8) {
<a name="l00060"></a>00060     <span class="comment">/* Provide 8/1 scaling */</span>
<a name="l00061"></a>00061     cinfo-&gt;jpeg_width = cinfo-&gt;image_width &lt;&lt; 3;
<a name="l00062"></a>00062     cinfo-&gt;jpeg_height = cinfo-&gt;image_height &lt;&lt; 3;
<a name="l00063"></a>00063     cinfo-&gt;min_DCT_h_scaled_size = 1;
<a name="l00064"></a>00064     cinfo-&gt;min_DCT_v_scaled_size = 1;
<a name="l00065"></a>00065   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cinfo-&gt;scale_num &gt;= cinfo-&gt;scale_denom * 4) {
<a name="l00066"></a>00066     <span class="comment">/* Provide 4/1 scaling */</span>
<a name="l00067"></a>00067     cinfo-&gt;jpeg_width = cinfo-&gt;image_width &lt;&lt; 2;
<a name="l00068"></a>00068     cinfo-&gt;jpeg_height = cinfo-&gt;image_height &lt;&lt; 2;
<a name="l00069"></a>00069     cinfo-&gt;min_DCT_h_scaled_size = 2;
<a name="l00070"></a>00070     cinfo-&gt;min_DCT_v_scaled_size = 2;
<a name="l00071"></a>00071   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cinfo-&gt;scale_num * 3 &gt;= cinfo-&gt;scale_denom * 8) {
<a name="l00072"></a>00072     <span class="comment">/* Provide 8/3 scaling */</span>
<a name="l00073"></a>00073     cinfo-&gt;jpeg_width = (cinfo-&gt;image_width &lt;&lt; 1) + (JDIMENSION)
<a name="l00074"></a>00074       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;image_width * 2, 3L);
<a name="l00075"></a>00075     cinfo-&gt;jpeg_height = (cinfo-&gt;image_height &lt;&lt; 1) + (JDIMENSION)
<a name="l00076"></a>00076       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;image_height * 2, 3L);
<a name="l00077"></a>00077     cinfo-&gt;min_DCT_h_scaled_size = 3;
<a name="l00078"></a>00078     cinfo-&gt;min_DCT_v_scaled_size = 3;
<a name="l00079"></a>00079   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cinfo-&gt;scale_num &gt;= cinfo-&gt;scale_denom * 2) {
<a name="l00080"></a>00080     <span class="comment">/* Provide 2/1 scaling */</span>
<a name="l00081"></a>00081     cinfo-&gt;jpeg_width = cinfo-&gt;image_width &lt;&lt; 1;
<a name="l00082"></a>00082     cinfo-&gt;jpeg_height = cinfo-&gt;image_height &lt;&lt; 1;
<a name="l00083"></a>00083     cinfo-&gt;min_DCT_h_scaled_size = 4;
<a name="l00084"></a>00084     cinfo-&gt;min_DCT_v_scaled_size = 4;
<a name="l00085"></a>00085   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cinfo-&gt;scale_num * 5 &gt;= cinfo-&gt;scale_denom * 8) {
<a name="l00086"></a>00086     <span class="comment">/* Provide 8/5 scaling */</span>
<a name="l00087"></a>00087     cinfo-&gt;jpeg_width = cinfo-&gt;image_width + (JDIMENSION)
<a name="l00088"></a>00088       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;image_width * 3, 5L);
<a name="l00089"></a>00089     cinfo-&gt;jpeg_height = cinfo-&gt;image_height + (JDIMENSION)
<a name="l00090"></a>00090       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;image_height * 3, 5L);
<a name="l00091"></a>00091     cinfo-&gt;min_DCT_h_scaled_size = 5;
<a name="l00092"></a>00092     cinfo-&gt;min_DCT_v_scaled_size = 5;
<a name="l00093"></a>00093   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cinfo-&gt;scale_num * 3 &gt;= cinfo-&gt;scale_denom * 4) {
<a name="l00094"></a>00094     <span class="comment">/* Provide 4/3 scaling */</span>
<a name="l00095"></a>00095     cinfo-&gt;jpeg_width = cinfo-&gt;image_width + (JDIMENSION)
<a name="l00096"></a>00096       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;image_width, 3L);
<a name="l00097"></a>00097     cinfo-&gt;jpeg_height = cinfo-&gt;image_height + (JDIMENSION)
<a name="l00098"></a>00098       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;image_height, 3L);
<a name="l00099"></a>00099     cinfo-&gt;min_DCT_h_scaled_size = 6;
<a name="l00100"></a>00100     cinfo-&gt;min_DCT_v_scaled_size = 6;
<a name="l00101"></a>00101   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cinfo-&gt;scale_num * 7 &gt;= cinfo-&gt;scale_denom * 8) {
<a name="l00102"></a>00102     <span class="comment">/* Provide 8/7 scaling */</span>
<a name="l00103"></a>00103     cinfo-&gt;jpeg_width = cinfo-&gt;image_width + (JDIMENSION)
<a name="l00104"></a>00104       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;image_width, 7L);
<a name="l00105"></a>00105     cinfo-&gt;jpeg_height = cinfo-&gt;image_height + (JDIMENSION)
<a name="l00106"></a>00106       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;image_height, 7L);
<a name="l00107"></a>00107     cinfo-&gt;min_DCT_h_scaled_size = 7;
<a name="l00108"></a>00108     cinfo-&gt;min_DCT_v_scaled_size = 7;
<a name="l00109"></a>00109   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cinfo-&gt;scale_num &gt;= cinfo-&gt;scale_denom) {
<a name="l00110"></a>00110     <span class="comment">/* Provide 1/1 scaling */</span>
<a name="l00111"></a>00111     cinfo-&gt;jpeg_width = cinfo-&gt;image_width;
<a name="l00112"></a>00112     cinfo-&gt;jpeg_height = cinfo-&gt;image_height;
<a name="l00113"></a>00113     cinfo-&gt;min_DCT_h_scaled_size = 8;
<a name="l00114"></a>00114     cinfo-&gt;min_DCT_v_scaled_size = 8;
<a name="l00115"></a>00115   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cinfo-&gt;scale_num * 9 &gt;= cinfo-&gt;scale_denom * 8) {
<a name="l00116"></a>00116     <span class="comment">/* Provide 8/9 scaling */</span>
<a name="l00117"></a>00117     cinfo-&gt;jpeg_width = (JDIMENSION)
<a name="l00118"></a>00118       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;image_width * 8, 9L);
<a name="l00119"></a>00119     cinfo-&gt;jpeg_height = (JDIMENSION)
<a name="l00120"></a>00120       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;image_height * 8, 9L);
<a name="l00121"></a>00121     cinfo-&gt;min_DCT_h_scaled_size = 9;
<a name="l00122"></a>00122     cinfo-&gt;min_DCT_v_scaled_size = 9;
<a name="l00123"></a>00123   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cinfo-&gt;scale_num * 5 &gt;= cinfo-&gt;scale_denom * 4) {
<a name="l00124"></a>00124     <span class="comment">/* Provide 4/5 scaling */</span>
<a name="l00125"></a>00125     cinfo-&gt;jpeg_width = (JDIMENSION)
<a name="l00126"></a>00126       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;image_width * 4, 5L);
<a name="l00127"></a>00127     cinfo-&gt;jpeg_height = (JDIMENSION)
<a name="l00128"></a>00128       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;image_height * 4, 5L);
<a name="l00129"></a>00129     cinfo-&gt;min_DCT_h_scaled_size = 10;
<a name="l00130"></a>00130     cinfo-&gt;min_DCT_v_scaled_size = 10;
<a name="l00131"></a>00131   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cinfo-&gt;scale_num * 11 &gt;= cinfo-&gt;scale_denom * 8) {
<a name="l00132"></a>00132     <span class="comment">/* Provide 8/11 scaling */</span>
<a name="l00133"></a>00133     cinfo-&gt;jpeg_width = (JDIMENSION)
<a name="l00134"></a>00134       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;image_width * 8, 11L);
<a name="l00135"></a>00135     cinfo-&gt;jpeg_height = (JDIMENSION)
<a name="l00136"></a>00136       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;image_height * 8, 11L);
<a name="l00137"></a>00137     cinfo-&gt;min_DCT_h_scaled_size = 11;
<a name="l00138"></a>00138     cinfo-&gt;min_DCT_v_scaled_size = 11;
<a name="l00139"></a>00139   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cinfo-&gt;scale_num * 3 &gt;= cinfo-&gt;scale_denom * 2) {
<a name="l00140"></a>00140     <span class="comment">/* Provide 2/3 scaling */</span>
<a name="l00141"></a>00141     cinfo-&gt;jpeg_width = (JDIMENSION)
<a name="l00142"></a>00142       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;image_width * 2, 3L);
<a name="l00143"></a>00143     cinfo-&gt;jpeg_height = (JDIMENSION)
<a name="l00144"></a>00144       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;image_height * 2, 3L);
<a name="l00145"></a>00145     cinfo-&gt;min_DCT_h_scaled_size = 12;
<a name="l00146"></a>00146     cinfo-&gt;min_DCT_v_scaled_size = 12;
<a name="l00147"></a>00147   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cinfo-&gt;scale_num * 13 &gt;= cinfo-&gt;scale_denom * 8) {
<a name="l00148"></a>00148     <span class="comment">/* Provide 8/13 scaling */</span>
<a name="l00149"></a>00149     cinfo-&gt;jpeg_width = (JDIMENSION)
<a name="l00150"></a>00150       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;image_width * 8, 13L);
<a name="l00151"></a>00151     cinfo-&gt;jpeg_height = (JDIMENSION)
<a name="l00152"></a>00152       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;image_height * 8, 13L);
<a name="l00153"></a>00153     cinfo-&gt;min_DCT_h_scaled_size = 13;
<a name="l00154"></a>00154     cinfo-&gt;min_DCT_v_scaled_size = 13;
<a name="l00155"></a>00155   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cinfo-&gt;scale_num * 7 &gt;= cinfo-&gt;scale_denom * 4) {
<a name="l00156"></a>00156     <span class="comment">/* Provide 4/7 scaling */</span>
<a name="l00157"></a>00157     cinfo-&gt;jpeg_width = (JDIMENSION)
<a name="l00158"></a>00158       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;image_width * 4, 7L);
<a name="l00159"></a>00159     cinfo-&gt;jpeg_height = (JDIMENSION)
<a name="l00160"></a>00160       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;image_height * 4, 7L);
<a name="l00161"></a>00161     cinfo-&gt;min_DCT_h_scaled_size = 14;
<a name="l00162"></a>00162     cinfo-&gt;min_DCT_v_scaled_size = 14;
<a name="l00163"></a>00163   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cinfo-&gt;scale_num * 15 &gt;= cinfo-&gt;scale_denom * 8) {
<a name="l00164"></a>00164     <span class="comment">/* Provide 8/15 scaling */</span>
<a name="l00165"></a>00165     cinfo-&gt;jpeg_width = (JDIMENSION)
<a name="l00166"></a>00166       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;image_width * 8, 15L);
<a name="l00167"></a>00167     cinfo-&gt;jpeg_height = (JDIMENSION)
<a name="l00168"></a>00168       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;image_height * 8, 15L);
<a name="l00169"></a>00169     cinfo-&gt;min_DCT_h_scaled_size = 15;
<a name="l00170"></a>00170     cinfo-&gt;min_DCT_v_scaled_size = 15;
<a name="l00171"></a>00171   } <span class="keywordflow">else</span> {
<a name="l00172"></a>00172     <span class="comment">/* Provide 1/2 scaling */</span>
<a name="l00173"></a>00173     cinfo-&gt;jpeg_width = (JDIMENSION)
<a name="l00174"></a>00174       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;image_width, 2L);
<a name="l00175"></a>00175     cinfo-&gt;jpeg_height = (JDIMENSION)
<a name="l00176"></a>00176       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;image_height, 2L);
<a name="l00177"></a>00177     cinfo-&gt;min_DCT_h_scaled_size = 16;
<a name="l00178"></a>00178     cinfo-&gt;min_DCT_v_scaled_size = 16;
<a name="l00179"></a>00179   }
<a name="l00180"></a>00180 
<a name="l00181"></a>00181 <span class="preprocessor">#else </span><span class="comment">/* !DCT_SCALING_SUPPORTED */</span>
<a name="l00182"></a>00182 
<a name="l00183"></a>00183   <span class="comment">/* Hardwire it to &quot;no scaling&quot; */</span>
<a name="l00184"></a>00184   cinfo-&gt;jpeg_width = cinfo-&gt;image_width;
<a name="l00185"></a>00185   cinfo-&gt;jpeg_height = cinfo-&gt;image_height;
<a name="l00186"></a>00186   cinfo-&gt;min_DCT_h_scaled_size = DCTSIZE;
<a name="l00187"></a>00187   cinfo-&gt;min_DCT_v_scaled_size = DCTSIZE;
<a name="l00188"></a>00188 
<a name="l00189"></a>00189 <span class="preprocessor">#endif </span><span class="comment">/* DCT_SCALING_SUPPORTED */</span>
<a name="l00190"></a>00190 }
<a name="l00191"></a>00191 
<a name="l00192"></a>00192 
<a name="l00193"></a>00193 LOCAL(<span class="keywordtype">void</span>)
<a name="l00194"></a>00194 jpeg_calc_trans_dimensions (j_compress_ptr cinfo)
<a name="l00195"></a>00195 {
<a name="l00196"></a>00196   <span class="keywordflow">if</span> (cinfo-&gt;min_DCT_h_scaled_size &lt; 1 || cinfo-&gt;min_DCT_h_scaled_size &gt; 16
<a name="l00197"></a>00197       || cinfo-&gt;min_DCT_h_scaled_size != cinfo-&gt;min_DCT_v_scaled_size)
<a name="l00198"></a>00198     ERREXIT2(cinfo, JERR_BAD_DCTSIZE,
<a name="l00199"></a>00199          cinfo-&gt;min_DCT_h_scaled_size, cinfo-&gt;min_DCT_v_scaled_size);
<a name="l00200"></a>00200 
<a name="l00201"></a>00201   cinfo-&gt;block_size = cinfo-&gt;min_DCT_h_scaled_size;
<a name="l00202"></a>00202 
<a name="l00203"></a>00203   <span class="keywordflow">switch</span> (cinfo-&gt;block_size) {
<a name="l00204"></a>00204   <span class="keywordflow">case</span> 2: cinfo-&gt;natural_order = jpeg_natural_order2; <span class="keywordflow">break</span>;
<a name="l00205"></a>00205   <span class="keywordflow">case</span> 3: cinfo-&gt;natural_order = jpeg_natural_order3; <span class="keywordflow">break</span>;
<a name="l00206"></a>00206   <span class="keywordflow">case</span> 4: cinfo-&gt;natural_order = jpeg_natural_order4; <span class="keywordflow">break</span>;
<a name="l00207"></a>00207   <span class="keywordflow">case</span> 5: cinfo-&gt;natural_order = jpeg_natural_order5; <span class="keywordflow">break</span>;
<a name="l00208"></a>00208   <span class="keywordflow">case</span> 6: cinfo-&gt;natural_order = jpeg_natural_order6; <span class="keywordflow">break</span>;
<a name="l00209"></a>00209   <span class="keywordflow">case</span> 7: cinfo-&gt;natural_order = jpeg_natural_order7; <span class="keywordflow">break</span>;
<a name="l00210"></a>00210   <span class="keywordflow">default</span>: cinfo-&gt;natural_order = jpeg_natural_order; <span class="keywordflow">break</span>;
<a name="l00211"></a>00211   }
<a name="l00212"></a>00212 
<a name="l00213"></a>00213   cinfo-&gt;lim_Se = cinfo-&gt;block_size &lt; DCTSIZE ?
<a name="l00214"></a>00214     cinfo-&gt;block_size * cinfo-&gt;block_size - 1 : DCTSIZE2-1;
<a name="l00215"></a>00215 }
<a name="l00216"></a>00216 
<a name="l00217"></a>00217 
<a name="l00218"></a>00218 LOCAL(<span class="keywordtype">void</span>)
<a name="l00219"></a>00219 initial_setup (j_compress_ptr cinfo, <span class="keywordtype">boolean</span> transcode_only)
<a name="l00220"></a>00220 <span class="comment">/* Do computations that are needed before master selection phase */</span>
<a name="l00221"></a>00221 {
<a name="l00222"></a>00222   <span class="keywordtype">int</span> ci, ssize;
<a name="l00223"></a>00223   <a class="code" href="structjpeg__component__info.html">jpeg_component_info</a> *compptr;
<a name="l00224"></a>00224   <span class="keywordtype">long</span> samplesperrow;
<a name="l00225"></a>00225   JDIMENSION jd_samplesperrow;
<a name="l00226"></a>00226 
<a name="l00227"></a>00227   <span class="keywordflow">if</span> (transcode_only)
<a name="l00228"></a>00228     jpeg_calc_trans_dimensions(cinfo);
<a name="l00229"></a>00229   <span class="keywordflow">else</span>
<a name="l00230"></a>00230     jpeg_calc_jpeg_dimensions(cinfo);
<a name="l00231"></a>00231 
<a name="l00232"></a>00232   <span class="comment">/* Sanity check on image dimensions */</span>
<a name="l00233"></a>00233   <span class="keywordflow">if</span> (cinfo-&gt;jpeg_height &lt;= 0 || cinfo-&gt;jpeg_width &lt;= 0 ||
<a name="l00234"></a>00234       cinfo-&gt;num_components &lt;= 0 || cinfo-&gt;input_components &lt;= 0)
<a name="l00235"></a>00235     ERREXIT(cinfo, JERR_EMPTY_IMAGE);
<a name="l00236"></a>00236 
<a name="l00237"></a>00237   <span class="comment">/* Make sure image isn&#39;t bigger than I can handle */</span>
<a name="l00238"></a>00238   <span class="keywordflow">if</span> ((<span class="keywordtype">long</span>) cinfo-&gt;jpeg_height &gt; (<span class="keywordtype">long</span>) JPEG_MAX_DIMENSION ||
<a name="l00239"></a>00239       (<span class="keywordtype">long</span>) cinfo-&gt;jpeg_width &gt; (<span class="keywordtype">long</span>) JPEG_MAX_DIMENSION)
<a name="l00240"></a>00240     ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) JPEG_MAX_DIMENSION);
<a name="l00241"></a>00241 
<a name="l00242"></a>00242   <span class="comment">/* Width of an input scanline must be representable as JDIMENSION. */</span>
<a name="l00243"></a>00243   samplesperrow = (long) cinfo-&gt;image_width * (<span class="keywordtype">long</span>) cinfo-&gt;input_components;
<a name="l00244"></a>00244   jd_samplesperrow = (JDIMENSION) samplesperrow;
<a name="l00245"></a>00245   <span class="keywordflow">if</span> ((<span class="keywordtype">long</span>) jd_samplesperrow != samplesperrow)
<a name="l00246"></a>00246     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
<a name="l00247"></a>00247 
<a name="l00248"></a>00248   <span class="comment">/* For now, precision must match compiled-in value... */</span>
<a name="l00249"></a>00249   <span class="keywordflow">if</span> (cinfo-&gt;data_precision != BITS_IN_JSAMPLE)
<a name="l00250"></a>00250     ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo-&gt;data_precision);
<a name="l00251"></a>00251 
<a name="l00252"></a>00252   <span class="comment">/* Check that number of components won&#39;t exceed internal array sizes */</span>
<a name="l00253"></a>00253   <span class="keywordflow">if</span> (cinfo-&gt;num_components &gt; MAX_COMPONENTS)
<a name="l00254"></a>00254     ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo-&gt;num_components,
<a name="l00255"></a>00255          MAX_COMPONENTS);
<a name="l00256"></a>00256 
<a name="l00257"></a>00257   <span class="comment">/* Compute maximum sampling factors; check factor validity */</span>
<a name="l00258"></a>00258   cinfo-&gt;max_h_samp_factor = 1;
<a name="l00259"></a>00259   cinfo-&gt;max_v_samp_factor = 1;
<a name="l00260"></a>00260   <span class="keywordflow">for</span> (ci = 0, compptr = cinfo-&gt;comp_info; ci &lt; cinfo-&gt;num_components;
<a name="l00261"></a>00261        ci++, compptr++) {
<a name="l00262"></a>00262     <span class="keywordflow">if</span> (compptr-&gt;h_samp_factor&lt;=0 || compptr-&gt;h_samp_factor&gt;MAX_SAMP_FACTOR ||
<a name="l00263"></a>00263     compptr-&gt;v_samp_factor&lt;=0 || compptr-&gt;v_samp_factor&gt;MAX_SAMP_FACTOR)
<a name="l00264"></a>00264       ERREXIT(cinfo, JERR_BAD_SAMPLING);
<a name="l00265"></a>00265     cinfo-&gt;max_h_samp_factor = MAX(cinfo-&gt;max_h_samp_factor,
<a name="l00266"></a>00266                    compptr-&gt;h_samp_factor);
<a name="l00267"></a>00267     cinfo-&gt;max_v_samp_factor = MAX(cinfo-&gt;max_v_samp_factor,
<a name="l00268"></a>00268                    compptr-&gt;v_samp_factor);
<a name="l00269"></a>00269   }
<a name="l00270"></a>00270 
<a name="l00271"></a>00271   <span class="comment">/* Compute dimensions of components */</span>
<a name="l00272"></a>00272   <span class="keywordflow">for</span> (ci = 0, compptr = cinfo-&gt;comp_info; ci &lt; cinfo-&gt;num_components;
<a name="l00273"></a>00273        ci++, compptr++) {
<a name="l00274"></a>00274     <span class="comment">/* Fill in the correct component_index value; don&#39;t rely on application */</span>
<a name="l00275"></a>00275     compptr-&gt;component_index = ci;
<a name="l00276"></a>00276     <span class="comment">/* In selecting the actual DCT scaling for each component, we try to</span>
<a name="l00277"></a>00277 <span class="comment">     * scale down the chroma components via DCT scaling rather than downsampling.</span>
<a name="l00278"></a>00278 <span class="comment">     * This saves time if the downsampler gets to use 1:1 scaling.</span>
<a name="l00279"></a>00279 <span class="comment">     * Note this code adapts subsampling ratios which are powers of 2.</span>
<a name="l00280"></a>00280 <span class="comment">     */</span>
<a name="l00281"></a>00281     ssize = 1;
<a name="l00282"></a>00282 <span class="preprocessor">#ifdef DCT_SCALING_SUPPORTED</span>
<a name="l00283"></a>00283 <span class="preprocessor"></span>    <span class="keywordflow">while</span> (cinfo-&gt;min_DCT_h_scaled_size * ssize &lt;=
<a name="l00284"></a>00284        (cinfo-&gt;do_fancy_downsampling ? DCTSIZE : DCTSIZE / 2) &amp;&amp;
<a name="l00285"></a>00285        (cinfo-&gt;max_h_samp_factor % (compptr-&gt;h_samp_factor * ssize * 2)) == 0) {
<a name="l00286"></a>00286       ssize = ssize * 2;
<a name="l00287"></a>00287     }
<a name="l00288"></a>00288 <span class="preprocessor">#endif</span>
<a name="l00289"></a>00289 <span class="preprocessor"></span>    compptr-&gt;DCT_h_scaled_size = cinfo-&gt;min_DCT_h_scaled_size * ssize;
<a name="l00290"></a>00290     ssize = 1;
<a name="l00291"></a>00291 <span class="preprocessor">#ifdef DCT_SCALING_SUPPORTED</span>
<a name="l00292"></a>00292 <span class="preprocessor"></span>    <span class="keywordflow">while</span> (cinfo-&gt;min_DCT_v_scaled_size * ssize &lt;=
<a name="l00293"></a>00293        (cinfo-&gt;do_fancy_downsampling ? DCTSIZE : DCTSIZE / 2) &amp;&amp;
<a name="l00294"></a>00294        (cinfo-&gt;max_v_samp_factor % (compptr-&gt;v_samp_factor * ssize * 2)) == 0) {
<a name="l00295"></a>00295       ssize = ssize * 2;
<a name="l00296"></a>00296     }
<a name="l00297"></a>00297 <span class="preprocessor">#endif</span>
<a name="l00298"></a>00298 <span class="preprocessor"></span>    compptr-&gt;DCT_v_scaled_size = cinfo-&gt;min_DCT_v_scaled_size * ssize;
<a name="l00299"></a>00299 
<a name="l00300"></a>00300     <span class="comment">/* We don&#39;t support DCT ratios larger than 2. */</span>
<a name="l00301"></a>00301     <span class="keywordflow">if</span> (compptr-&gt;DCT_h_scaled_size &gt; compptr-&gt;DCT_v_scaled_size * 2)
<a name="l00302"></a>00302     compptr-&gt;DCT_h_scaled_size = compptr-&gt;DCT_v_scaled_size * 2;
<a name="l00303"></a>00303     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (compptr-&gt;DCT_v_scaled_size &gt; compptr-&gt;DCT_h_scaled_size * 2)
<a name="l00304"></a>00304     compptr-&gt;DCT_v_scaled_size = compptr-&gt;DCT_h_scaled_size * 2;
<a name="l00305"></a>00305 
<a name="l00306"></a>00306     <span class="comment">/* Size in DCT blocks */</span>
<a name="l00307"></a>00307     compptr-&gt;width_in_blocks = (JDIMENSION)
<a name="l00308"></a>00308       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;jpeg_width * (long) compptr-&gt;h_samp_factor,
<a name="l00309"></a>00309             (<span class="keywordtype">long</span>) (cinfo-&gt;max_h_samp_factor * cinfo-&gt;block_size));
<a name="l00310"></a>00310     compptr-&gt;height_in_blocks = (JDIMENSION)
<a name="l00311"></a>00311       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;jpeg_height * (long) compptr-&gt;v_samp_factor,
<a name="l00312"></a>00312             (<span class="keywordtype">long</span>) (cinfo-&gt;max_v_samp_factor * cinfo-&gt;block_size));
<a name="l00313"></a>00313     <span class="comment">/* Size in samples */</span>
<a name="l00314"></a>00314     compptr-&gt;downsampled_width = (JDIMENSION)
<a name="l00315"></a>00315       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;jpeg_width *
<a name="l00316"></a>00316             (long) (compptr-&gt;h_samp_factor * compptr-&gt;DCT_h_scaled_size),
<a name="l00317"></a>00317             (long) (cinfo-&gt;max_h_samp_factor * cinfo-&gt;block_size));
<a name="l00318"></a>00318     compptr-&gt;downsampled_height = (JDIMENSION)
<a name="l00319"></a>00319       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;jpeg_height *
<a name="l00320"></a>00320             (long) (compptr-&gt;v_samp_factor * compptr-&gt;DCT_v_scaled_size),
<a name="l00321"></a>00321             (long) (cinfo-&gt;max_v_samp_factor * cinfo-&gt;block_size));
<a name="l00322"></a>00322     <span class="comment">/* Mark component needed (this flag isn&#39;t actually used for compression) */</span>
<a name="l00323"></a>00323     compptr-&gt;component_needed = TRUE;
<a name="l00324"></a>00324   }
<a name="l00325"></a>00325 
<a name="l00326"></a>00326   <span class="comment">/* Compute number of fully interleaved MCU rows (number of times that</span>
<a name="l00327"></a>00327 <span class="comment">   * main controller will call coefficient controller).</span>
<a name="l00328"></a>00328 <span class="comment">   */</span>
<a name="l00329"></a>00329   cinfo-&gt;total_iMCU_rows = (JDIMENSION)
<a name="l00330"></a>00330     jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;jpeg_height,
<a name="l00331"></a>00331           (long) (cinfo-&gt;max_v_samp_factor * cinfo-&gt;block_size));
<a name="l00332"></a>00332 }
<a name="l00333"></a>00333 
<a name="l00334"></a>00334 
<a name="l00335"></a>00335 <span class="preprocessor">#ifdef C_MULTISCAN_FILES_SUPPORTED</span>
<a name="l00336"></a>00336 <span class="preprocessor"></span>
<a name="l00337"></a>00337 LOCAL(<span class="keywordtype">void</span>)
<a name="l00338"></a>00338 validate_script (j_compress_ptr cinfo)
<a name="l00339"></a>00339 <span class="comment">/* Verify that the scan script in cinfo-&gt;scan_info[] is valid; also</span>
<a name="l00340"></a>00340 <span class="comment"> * determine whether it uses progressive JPEG, and set cinfo-&gt;progressive_mode.</span>
<a name="l00341"></a>00341 <span class="comment"> */</span>
<a name="l00342"></a>00342 {
<a name="l00343"></a>00343   <span class="keyword">const</span> <a class="code" href="structjpeg__scan__info.html">jpeg_scan_info</a> * scanptr;
<a name="l00344"></a>00344   <span class="keywordtype">int</span> scanno, ncomps, ci, coefi, thisi;
<a name="l00345"></a>00345   <span class="keywordtype">int</span> Ss, Se, Ah, Al;
<a name="l00346"></a>00346   <span class="keywordtype">boolean</span> component_sent[MAX_COMPONENTS];
<a name="l00347"></a>00347 <span class="preprocessor">#ifdef C_PROGRESSIVE_SUPPORTED</span>
<a name="l00348"></a>00348 <span class="preprocessor"></span>  <span class="keywordtype">int</span> * last_bitpos_ptr;
<a name="l00349"></a>00349   <span class="keywordtype">int</span> last_bitpos[MAX_COMPONENTS][DCTSIZE2];
<a name="l00350"></a>00350   <span class="comment">/* -1 until that coefficient has been seen; then last Al for it */</span>
<a name="l00351"></a>00351 <span class="preprocessor">#endif</span>
<a name="l00352"></a>00352 <span class="preprocessor"></span>
<a name="l00353"></a>00353   <span class="keywordflow">if</span> (cinfo-&gt;num_scans &lt;= 0)
<a name="l00354"></a>00354     ERREXIT1(cinfo, JERR_BAD_SCAN_SCRIPT, 0);
<a name="l00355"></a>00355 
<a name="l00356"></a>00356   <span class="comment">/* For sequential JPEG, all scans must have Ss=0, Se=DCTSIZE2-1;</span>
<a name="l00357"></a>00357 <span class="comment">   * for progressive JPEG, no scan can have this.</span>
<a name="l00358"></a>00358 <span class="comment">   */</span>
<a name="l00359"></a>00359   scanptr = cinfo-&gt;scan_info;
<a name="l00360"></a>00360   <span class="keywordflow">if</span> (scanptr-&gt;Ss != 0 || scanptr-&gt;Se != DCTSIZE2-1) {
<a name="l00361"></a>00361 <span class="preprocessor">#ifdef C_PROGRESSIVE_SUPPORTED</span>
<a name="l00362"></a>00362 <span class="preprocessor"></span>    cinfo-&gt;progressive_mode = TRUE;
<a name="l00363"></a>00363     last_bitpos_ptr = &amp; last_bitpos[0][0];
<a name="l00364"></a>00364     <span class="keywordflow">for</span> (ci = 0; ci &lt; cinfo-&gt;num_components; ci++) 
<a name="l00365"></a>00365       <span class="keywordflow">for</span> (coefi = 0; coefi &lt; DCTSIZE2; coefi++)
<a name="l00366"></a>00366     *last_bitpos_ptr++ = -1;
<a name="l00367"></a>00367 <span class="preprocessor">#else</span>
<a name="l00368"></a>00368 <span class="preprocessor"></span>    ERREXIT(cinfo, JERR_NOT_COMPILED);
<a name="l00369"></a>00369 <span class="preprocessor">#endif</span>
<a name="l00370"></a>00370 <span class="preprocessor"></span>  } <span class="keywordflow">else</span> {
<a name="l00371"></a>00371     cinfo-&gt;progressive_mode = FALSE;
<a name="l00372"></a>00372     <span class="keywordflow">for</span> (ci = 0; ci &lt; cinfo-&gt;num_components; ci++) 
<a name="l00373"></a>00373       component_sent[ci] = FALSE;
<a name="l00374"></a>00374   }
<a name="l00375"></a>00375 
<a name="l00376"></a>00376   <span class="keywordflow">for</span> (scanno = 1; scanno &lt;= cinfo-&gt;num_scans; scanptr++, scanno++) {
<a name="l00377"></a>00377     <span class="comment">/* Validate component indexes */</span>
<a name="l00378"></a>00378     ncomps = scanptr-&gt;comps_in_scan;
<a name="l00379"></a>00379     <span class="keywordflow">if</span> (ncomps &lt;= 0 || ncomps &gt; MAX_COMPS_IN_SCAN)
<a name="l00380"></a>00380       ERREXIT2(cinfo, JERR_COMPONENT_COUNT, ncomps, MAX_COMPS_IN_SCAN);
<a name="l00381"></a>00381     <span class="keywordflow">for</span> (ci = 0; ci &lt; ncomps; ci++) {
<a name="l00382"></a>00382       thisi = scanptr-&gt;component_index[ci];
<a name="l00383"></a>00383       <span class="keywordflow">if</span> (thisi &lt; 0 || thisi &gt;= cinfo-&gt;num_components)
<a name="l00384"></a>00384     ERREXIT1(cinfo, JERR_BAD_SCAN_SCRIPT, scanno);
<a name="l00385"></a>00385       <span class="comment">/* Components must appear in SOF order within each scan */</span>
<a name="l00386"></a>00386       <span class="keywordflow">if</span> (ci &gt; 0 &amp;&amp; thisi &lt;= scanptr-&gt;component_index[ci-1])
<a name="l00387"></a>00387     ERREXIT1(cinfo, JERR_BAD_SCAN_SCRIPT, scanno);
<a name="l00388"></a>00388     }
<a name="l00389"></a>00389     <span class="comment">/* Validate progression parameters */</span>
<a name="l00390"></a>00390     Ss = scanptr-&gt;Ss;
<a name="l00391"></a>00391     Se = scanptr-&gt;Se;
<a name="l00392"></a>00392     Ah = scanptr-&gt;Ah;
<a name="l00393"></a>00393     Al = scanptr-&gt;Al;
<a name="l00394"></a>00394     <span class="keywordflow">if</span> (cinfo-&gt;progressive_mode) {
<a name="l00395"></a>00395 <span class="preprocessor">#ifdef C_PROGRESSIVE_SUPPORTED</span>
<a name="l00396"></a>00396 <span class="preprocessor"></span>      <span class="comment">/* The JPEG spec simply gives the ranges 0..13 for Ah and Al, but that</span>
<a name="l00397"></a>00397 <span class="comment">       * seems wrong: the upper bound ought to depend on data precision.</span>
<a name="l00398"></a>00398 <span class="comment">       * Perhaps they really meant 0..N+1 for N-bit precision.</span>
<a name="l00399"></a>00399 <span class="comment">       * Here we allow 0..10 for 8-bit data; Al larger than 10 results in</span>
<a name="l00400"></a>00400 <span class="comment">       * out-of-range reconstructed DC values during the first DC scan,</span>
<a name="l00401"></a>00401 <span class="comment">       * which might cause problems for some decoders.</span>
<a name="l00402"></a>00402 <span class="comment">       */</span>
<a name="l00403"></a>00403 <span class="preprocessor">#if BITS_IN_JSAMPLE == 8</span>
<a name="l00404"></a>00404 <span class="preprocessor"></span><span class="preprocessor">#define MAX_AH_AL 10</span>
<a name="l00405"></a>00405 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00406"></a>00406 <span class="preprocessor"></span><span class="preprocessor">#define MAX_AH_AL 13</span>
<a name="l00407"></a>00407 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00408"></a>00408 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (Ss &lt; 0 || Ss &gt;= DCTSIZE2 || Se &lt; Ss || Se &gt;= DCTSIZE2 ||
<a name="l00409"></a>00409       Ah &lt; 0 || Ah &gt; MAX_AH_AL || Al &lt; 0 || Al &gt; MAX_AH_AL)
<a name="l00410"></a>00410     ERREXIT1(cinfo, JERR_BAD_PROG_SCRIPT, scanno);
<a name="l00411"></a>00411       <span class="keywordflow">if</span> (Ss == 0) {
<a name="l00412"></a>00412     <span class="keywordflow">if</span> (Se != 0)        <span class="comment">/* DC and AC together not OK */</span>
<a name="l00413"></a>00413       ERREXIT1(cinfo, JERR_BAD_PROG_SCRIPT, scanno);
<a name="l00414"></a>00414       } <span class="keywordflow">else</span> {
<a name="l00415"></a>00415     <span class="keywordflow">if</span> (ncomps != 1)    <span class="comment">/* AC scans must be for only one component */</span>
<a name="l00416"></a>00416       ERREXIT1(cinfo, JERR_BAD_PROG_SCRIPT, scanno);
<a name="l00417"></a>00417       }
<a name="l00418"></a>00418       <span class="keywordflow">for</span> (ci = 0; ci &lt; ncomps; ci++) {
<a name="l00419"></a>00419     last_bitpos_ptr = &amp; last_bitpos[scanptr-&gt;component_index[ci]][0];
<a name="l00420"></a>00420     <span class="keywordflow">if</span> (Ss != 0 &amp;&amp; last_bitpos_ptr[0] &lt; 0) <span class="comment">/* AC without prior DC scan */</span>
<a name="l00421"></a>00421       ERREXIT1(cinfo, JERR_BAD_PROG_SCRIPT, scanno);
<a name="l00422"></a>00422     <span class="keywordflow">for</span> (coefi = Ss; coefi &lt;= Se; coefi++) {
<a name="l00423"></a>00423       <span class="keywordflow">if</span> (last_bitpos_ptr[coefi] &lt; 0) {
<a name="l00424"></a>00424         <span class="comment">/* first scan of this coefficient */</span>
<a name="l00425"></a>00425         <span class="keywordflow">if</span> (Ah != 0)
<a name="l00426"></a>00426           ERREXIT1(cinfo, JERR_BAD_PROG_SCRIPT, scanno);
<a name="l00427"></a>00427       } <span class="keywordflow">else</span> {
<a name="l00428"></a>00428         <span class="comment">/* not first scan */</span>
<a name="l00429"></a>00429         <span class="keywordflow">if</span> (Ah != last_bitpos_ptr[coefi] || Al != Ah-1)
<a name="l00430"></a>00430           ERREXIT1(cinfo, JERR_BAD_PROG_SCRIPT, scanno);
<a name="l00431"></a>00431       }
<a name="l00432"></a>00432       last_bitpos_ptr[coefi] = Al;
<a name="l00433"></a>00433     }
<a name="l00434"></a>00434       }
<a name="l00435"></a>00435 <span class="preprocessor">#endif</span>
<a name="l00436"></a>00436 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> {
<a name="l00437"></a>00437       <span class="comment">/* For sequential JPEG, all progression parameters must be these: */</span>
<a name="l00438"></a>00438       <span class="keywordflow">if</span> (Ss != 0 || Se != DCTSIZE2-1 || Ah != 0 || Al != 0)
<a name="l00439"></a>00439     ERREXIT1(cinfo, JERR_BAD_PROG_SCRIPT, scanno);
<a name="l00440"></a>00440       <span class="comment">/* Make sure components are not sent twice */</span>
<a name="l00441"></a>00441       <span class="keywordflow">for</span> (ci = 0; ci &lt; ncomps; ci++) {
<a name="l00442"></a>00442     thisi = scanptr-&gt;component_index[ci];
<a name="l00443"></a>00443     <span class="keywordflow">if</span> (component_sent[thisi])
<a name="l00444"></a>00444       ERREXIT1(cinfo, JERR_BAD_SCAN_SCRIPT, scanno);
<a name="l00445"></a>00445     component_sent[thisi] = TRUE;
<a name="l00446"></a>00446       }
<a name="l00447"></a>00447     }
<a name="l00448"></a>00448   }
<a name="l00449"></a>00449 
<a name="l00450"></a>00450   <span class="comment">/* Now verify that everything got sent. */</span>
<a name="l00451"></a>00451   <span class="keywordflow">if</span> (cinfo-&gt;progressive_mode) {
<a name="l00452"></a>00452 <span class="preprocessor">#ifdef C_PROGRESSIVE_SUPPORTED</span>
<a name="l00453"></a>00453 <span class="preprocessor"></span>    <span class="comment">/* For progressive mode, we only check that at least some DC data</span>
<a name="l00454"></a>00454 <span class="comment">     * got sent for each component; the spec does not require that all bits</span>
<a name="l00455"></a>00455 <span class="comment">     * of all coefficients be transmitted.  Would it be wiser to enforce</span>
<a name="l00456"></a>00456 <span class="comment">     * transmission of all coefficient bits??</span>
<a name="l00457"></a>00457 <span class="comment">     */</span>
<a name="l00458"></a>00458     <span class="keywordflow">for</span> (ci = 0; ci &lt; cinfo-&gt;num_components; ci++) {
<a name="l00459"></a>00459       <span class="keywordflow">if</span> (last_bitpos[ci][0] &lt; 0)
<a name="l00460"></a>00460     ERREXIT(cinfo, JERR_MISSING_DATA);
<a name="l00461"></a>00461     }
<a name="l00462"></a>00462 <span class="preprocessor">#endif</span>
<a name="l00463"></a>00463 <span class="preprocessor"></span>  } <span class="keywordflow">else</span> {
<a name="l00464"></a>00464     <span class="keywordflow">for</span> (ci = 0; ci &lt; cinfo-&gt;num_components; ci++) {
<a name="l00465"></a>00465       <span class="keywordflow">if</span> (! component_sent[ci])
<a name="l00466"></a>00466     ERREXIT(cinfo, JERR_MISSING_DATA);
<a name="l00467"></a>00467     }
<a name="l00468"></a>00468   }
<a name="l00469"></a>00469 }
<a name="l00470"></a>00470 
<a name="l00471"></a>00471 
<a name="l00472"></a>00472 LOCAL(<span class="keywordtype">void</span>)
<a name="l00473"></a>00473 reduce_script (j_compress_ptr cinfo)
<a name="l00474"></a>00474 <span class="comment">/* Adapt scan script for use with reduced block size;</span>
<a name="l00475"></a>00475 <span class="comment"> * assume that script has been validated before.</span>
<a name="l00476"></a>00476 <span class="comment"> */</span>
<a name="l00477"></a>00477 {
<a name="l00478"></a>00478   <a class="code" href="structjpeg__scan__info.html">jpeg_scan_info</a> * scanptr;
<a name="l00479"></a>00479   <span class="keywordtype">int</span> idxout, idxin;
<a name="l00480"></a>00480 
<a name="l00481"></a>00481   <span class="comment">/* Circumvent const declaration for this function */</span>
<a name="l00482"></a>00482   scanptr = (<a class="code" href="structjpeg__scan__info.html">jpeg_scan_info</a> *) cinfo-&gt;scan_info;
<a name="l00483"></a>00483   idxout = 0;
<a name="l00484"></a>00484 
<a name="l00485"></a>00485   for (idxin = 0; idxin &lt; cinfo-&gt;num_scans; idxin++) {
<a name="l00486"></a>00486     <span class="comment">/* After skipping, idxout becomes smaller than idxin */</span>
<a name="l00487"></a>00487     <span class="keywordflow">if</span> (idxin != idxout)
<a name="l00488"></a>00488       <span class="comment">/* Copy rest of data;</span>
<a name="l00489"></a>00489 <span class="comment">       * note we stay in given chunk of allocated memory.</span>
<a name="l00490"></a>00490 <span class="comment">       */</span>
<a name="l00491"></a>00491       scanptr[idxout] = scanptr[idxin];
<a name="l00492"></a>00492     <span class="keywordflow">if</span> (scanptr[idxout].Ss &gt; cinfo-&gt;lim_Se)
<a name="l00493"></a>00493       <span class="comment">/* Entire scan out of range - skip this entry */</span>
<a name="l00494"></a>00494       <span class="keywordflow">continue</span>;
<a name="l00495"></a>00495     <span class="keywordflow">if</span> (scanptr[idxout].Se &gt; cinfo-&gt;lim_Se)
<a name="l00496"></a>00496       <span class="comment">/* Limit scan to end of block */</span>
<a name="l00497"></a>00497       scanptr[idxout].Se = cinfo-&gt;lim_Se;
<a name="l00498"></a>00498     idxout++;
<a name="l00499"></a>00499   }
<a name="l00500"></a>00500 
<a name="l00501"></a>00501   cinfo-&gt;num_scans = idxout;
<a name="l00502"></a>00502 }
<a name="l00503"></a>00503 
<a name="l00504"></a>00504 <span class="preprocessor">#endif </span><span class="comment">/* C_MULTISCAN_FILES_SUPPORTED */</span>
<a name="l00505"></a>00505 
<a name="l00506"></a>00506 
<a name="l00507"></a>00507 LOCAL(<span class="keywordtype">void</span>)
<a name="l00508"></a>00508 select_scan_parameters (j_compress_ptr cinfo)
<a name="l00509"></a>00509 <span class="comment">/* Set up the scan parameters for the current scan */</span>
<a name="l00510"></a>00510 {
<a name="l00511"></a>00511   <span class="keywordtype">int</span> ci;
<a name="l00512"></a>00512 
<a name="l00513"></a>00513 <span class="preprocessor">#ifdef C_MULTISCAN_FILES_SUPPORTED</span>
<a name="l00514"></a>00514 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (cinfo-&gt;scan_info != NULL) {
<a name="l00515"></a>00515     <span class="comment">/* Prepare for current scan --- the script is already validated */</span>
<a name="l00516"></a>00516     <a class="code" href="structmy__comp__master.html">my_master_ptr</a> master = (<a class="code" href="structmy__comp__master.html">my_master_ptr</a>) cinfo-&gt;master;
<a name="l00517"></a>00517     <span class="keyword">const</span> <a class="code" href="structjpeg__scan__info.html">jpeg_scan_info</a> * scanptr = cinfo-&gt;scan_info + master-&gt;scan_number;
<a name="l00518"></a>00518 
<a name="l00519"></a>00519     cinfo-&gt;comps_in_scan = scanptr-&gt;comps_in_scan;
<a name="l00520"></a>00520     for (ci = 0; ci &lt; scanptr-&gt;comps_in_scan; ci++) {
<a name="l00521"></a>00521       cinfo-&gt;cur_comp_info[ci] =
<a name="l00522"></a>00522     &amp;cinfo-&gt;comp_info[scanptr-&gt;component_index[ci]];
<a name="l00523"></a>00523     }
<a name="l00524"></a>00524     <span class="keywordflow">if</span> (cinfo-&gt;progressive_mode) {
<a name="l00525"></a>00525       cinfo-&gt;Ss = scanptr-&gt;Ss;
<a name="l00526"></a>00526       cinfo-&gt;Se = scanptr-&gt;Se;
<a name="l00527"></a>00527       cinfo-&gt;Ah = scanptr-&gt;Ah;
<a name="l00528"></a>00528       cinfo-&gt;Al = scanptr-&gt;Al;
<a name="l00529"></a>00529       <span class="keywordflow">return</span>;
<a name="l00530"></a>00530     }
<a name="l00531"></a>00531   }
<a name="l00532"></a>00532   <span class="keywordflow">else</span>
<a name="l00533"></a>00533 <span class="preprocessor">#endif</span>
<a name="l00534"></a>00534 <span class="preprocessor"></span>  {
<a name="l00535"></a>00535     <span class="comment">/* Prepare for single sequential-JPEG scan containing all components */</span>
<a name="l00536"></a>00536     <span class="keywordflow">if</span> (cinfo-&gt;num_components &gt; MAX_COMPS_IN_SCAN)
<a name="l00537"></a>00537       ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo-&gt;num_components,
<a name="l00538"></a>00538            MAX_COMPS_IN_SCAN);
<a name="l00539"></a>00539     cinfo-&gt;comps_in_scan = cinfo-&gt;num_components;
<a name="l00540"></a>00540     <span class="keywordflow">for</span> (ci = 0; ci &lt; cinfo-&gt;num_components; ci++) {
<a name="l00541"></a>00541       cinfo-&gt;cur_comp_info[ci] = &amp;cinfo-&gt;comp_info[ci];
<a name="l00542"></a>00542     }
<a name="l00543"></a>00543   }
<a name="l00544"></a>00544   cinfo-&gt;Ss = 0;
<a name="l00545"></a>00545   cinfo-&gt;Se = cinfo-&gt;block_size * cinfo-&gt;block_size - 1;
<a name="l00546"></a>00546   cinfo-&gt;Ah = 0;
<a name="l00547"></a>00547   cinfo-&gt;Al = 0;
<a name="l00548"></a>00548 }
<a name="l00549"></a>00549 
<a name="l00550"></a>00550 
<a name="l00551"></a>00551 LOCAL(<span class="keywordtype">void</span>)
<a name="l00552"></a>00552 per_scan_setup (j_compress_ptr cinfo)
<a name="l00553"></a>00553 <span class="comment">/* Do computations that are needed before processing a JPEG scan */</span>
<a name="l00554"></a>00554 <span class="comment">/* cinfo-&gt;comps_in_scan and cinfo-&gt;cur_comp_info[] are already set */</span>
<a name="l00555"></a>00555 {
<a name="l00556"></a>00556   <span class="keywordtype">int</span> ci, mcublks, tmp;
<a name="l00557"></a>00557   <a class="code" href="structjpeg__component__info.html">jpeg_component_info</a> *compptr;
<a name="l00558"></a>00558   
<a name="l00559"></a>00559   <span class="keywordflow">if</span> (cinfo-&gt;comps_in_scan == 1) {
<a name="l00560"></a>00560     
<a name="l00561"></a>00561     <span class="comment">/* Noninterleaved (single-component) scan */</span>
<a name="l00562"></a>00562     compptr = cinfo-&gt;cur_comp_info[0];
<a name="l00563"></a>00563     
<a name="l00564"></a>00564     <span class="comment">/* Overall image size in MCUs */</span>
<a name="l00565"></a>00565     cinfo-&gt;MCUs_per_row = compptr-&gt;width_in_blocks;
<a name="l00566"></a>00566     cinfo-&gt;MCU_rows_in_scan = compptr-&gt;height_in_blocks;
<a name="l00567"></a>00567     
<a name="l00568"></a>00568     <span class="comment">/* For noninterleaved scan, always one block per MCU */</span>
<a name="l00569"></a>00569     compptr-&gt;MCU_width = 1;
<a name="l00570"></a>00570     compptr-&gt;MCU_height = 1;
<a name="l00571"></a>00571     compptr-&gt;MCU_blocks = 1;
<a name="l00572"></a>00572     compptr-&gt;MCU_sample_width = compptr-&gt;DCT_h_scaled_size;
<a name="l00573"></a>00573     compptr-&gt;last_col_width = 1;
<a name="l00574"></a>00574     <span class="comment">/* For noninterleaved scans, it is convenient to define last_row_height</span>
<a name="l00575"></a>00575 <span class="comment">     * as the number of block rows present in the last iMCU row.</span>
<a name="l00576"></a>00576 <span class="comment">     */</span>
<a name="l00577"></a>00577     tmp = (int) (compptr-&gt;height_in_blocks % compptr-&gt;v_samp_factor);
<a name="l00578"></a>00578     <span class="keywordflow">if</span> (tmp == 0) tmp = compptr-&gt;v_samp_factor;
<a name="l00579"></a>00579     compptr-&gt;last_row_height = tmp;
<a name="l00580"></a>00580     
<a name="l00581"></a>00581     <span class="comment">/* Prepare array describing MCU composition */</span>
<a name="l00582"></a>00582     cinfo-&gt;blocks_in_MCU = 1;
<a name="l00583"></a>00583     cinfo-&gt;MCU_membership[0] = 0;
<a name="l00584"></a>00584     
<a name="l00585"></a>00585   } <span class="keywordflow">else</span> {
<a name="l00586"></a>00586     
<a name="l00587"></a>00587     <span class="comment">/* Interleaved (multi-component) scan */</span>
<a name="l00588"></a>00588     <span class="keywordflow">if</span> (cinfo-&gt;comps_in_scan &lt;= 0 || cinfo-&gt;comps_in_scan &gt; MAX_COMPS_IN_SCAN)
<a name="l00589"></a>00589       ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo-&gt;comps_in_scan,
<a name="l00590"></a>00590            MAX_COMPS_IN_SCAN);
<a name="l00591"></a>00591     
<a name="l00592"></a>00592     <span class="comment">/* Overall image size in MCUs */</span>
<a name="l00593"></a>00593     cinfo-&gt;MCUs_per_row = (JDIMENSION)
<a name="l00594"></a>00594       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;jpeg_width,
<a name="l00595"></a>00595             (long) (cinfo-&gt;max_h_samp_factor * cinfo-&gt;block_size));
<a name="l00596"></a>00596     cinfo-&gt;MCU_rows_in_scan = (JDIMENSION)
<a name="l00597"></a>00597       jdiv_round_up((<span class="keywordtype">long</span>) cinfo-&gt;jpeg_height,
<a name="l00598"></a>00598             (long) (cinfo-&gt;max_v_samp_factor * cinfo-&gt;block_size));
<a name="l00599"></a>00599     
<a name="l00600"></a>00600     cinfo-&gt;blocks_in_MCU = 0;
<a name="l00601"></a>00601     
<a name="l00602"></a>00602     <span class="keywordflow">for</span> (ci = 0; ci &lt; cinfo-&gt;comps_in_scan; ci++) {
<a name="l00603"></a>00603       compptr = cinfo-&gt;cur_comp_info[ci];
<a name="l00604"></a>00604       <span class="comment">/* Sampling factors give # of blocks of component in each MCU */</span>
<a name="l00605"></a>00605       compptr-&gt;MCU_width = compptr-&gt;h_samp_factor;
<a name="l00606"></a>00606       compptr-&gt;MCU_height = compptr-&gt;v_samp_factor;
<a name="l00607"></a>00607       compptr-&gt;MCU_blocks = compptr-&gt;MCU_width * compptr-&gt;MCU_height;
<a name="l00608"></a>00608       compptr-&gt;MCU_sample_width = compptr-&gt;MCU_width * compptr-&gt;DCT_h_scaled_size;
<a name="l00609"></a>00609       <span class="comment">/* Figure number of non-dummy blocks in last MCU column &amp; row */</span>
<a name="l00610"></a>00610       tmp = (int) (compptr-&gt;width_in_blocks % compptr-&gt;MCU_width);
<a name="l00611"></a>00611       <span class="keywordflow">if</span> (tmp == 0) tmp = compptr-&gt;MCU_width;
<a name="l00612"></a>00612       compptr-&gt;last_col_width = tmp;
<a name="l00613"></a>00613       tmp = (int) (compptr-&gt;height_in_blocks % compptr-&gt;MCU_height);
<a name="l00614"></a>00614       <span class="keywordflow">if</span> (tmp == 0) tmp = compptr-&gt;MCU_height;
<a name="l00615"></a>00615       compptr-&gt;last_row_height = tmp;
<a name="l00616"></a>00616       <span class="comment">/* Prepare array describing MCU composition */</span>
<a name="l00617"></a>00617       mcublks = compptr-&gt;MCU_blocks;
<a name="l00618"></a>00618       <span class="keywordflow">if</span> (cinfo-&gt;blocks_in_MCU + mcublks &gt; C_MAX_BLOCKS_IN_MCU)
<a name="l00619"></a>00619     ERREXIT(cinfo, JERR_BAD_MCU_SIZE);
<a name="l00620"></a>00620       <span class="keywordflow">while</span> (mcublks-- &gt; 0) {
<a name="l00621"></a>00621     cinfo-&gt;MCU_membership[cinfo-&gt;blocks_in_MCU++] = ci;
<a name="l00622"></a>00622       }
<a name="l00623"></a>00623     }
<a name="l00624"></a>00624     
<a name="l00625"></a>00625   }
<a name="l00626"></a>00626 
<a name="l00627"></a>00627   <span class="comment">/* Convert restart specified in rows to actual MCU count. */</span>
<a name="l00628"></a>00628   <span class="comment">/* Note that count must fit in 16 bits, so we provide limiting. */</span>
<a name="l00629"></a>00629   <span class="keywordflow">if</span> (cinfo-&gt;restart_in_rows &gt; 0) {
<a name="l00630"></a>00630     <span class="keywordtype">long</span> nominal = (long) cinfo-&gt;restart_in_rows * (<span class="keywordtype">long</span>) cinfo-&gt;MCUs_per_row;
<a name="l00631"></a>00631     cinfo-&gt;restart_interval = (<span class="keywordtype">unsigned</span> int) <a class="code" href="group__usbd__cdc.html#ga3acffbd305ee72dcd4593c0d8af64a4f">MIN</a>(nominal, 65535L);
<a name="l00632"></a>00632   }
<a name="l00633"></a>00633 }
<a name="l00634"></a>00634 
<a name="l00635"></a>00635 
<a name="l00636"></a>00636 <span class="comment">/*</span>
<a name="l00637"></a>00637 <span class="comment"> * Per-pass setup.</span>
<a name="l00638"></a>00638 <span class="comment"> * This is called at the beginning of each pass.  We determine which modules</span>
<a name="l00639"></a>00639 <span class="comment"> * will be active during this pass and give them appropriate start_pass calls.</span>
<a name="l00640"></a>00640 <span class="comment"> * We also set is_last_pass to indicate whether any more passes will be</span>
<a name="l00641"></a>00641 <span class="comment"> * required.</span>
<a name="l00642"></a>00642 <span class="comment"> */</span>
<a name="l00643"></a>00643 
<a name="l00644"></a>00644 METHODDEF(<span class="keywordtype">void</span>)
<a name="l00645"></a>00645 prepare_for_pass (j_compress_ptr cinfo)
<a name="l00646"></a>00646 {
<a name="l00647"></a>00647   <a class="code" href="structmy__comp__master.html">my_master_ptr</a> master = (<a class="code" href="structmy__comp__master.html">my_master_ptr</a>) cinfo-&gt;master;
<a name="l00648"></a>00648 
<a name="l00649"></a>00649   switch (master-&gt;pass_type) {
<a name="l00650"></a>00650   <span class="keywordflow">case</span> main_pass:
<a name="l00651"></a>00651     <span class="comment">/* Initial pass: will collect input data, and do either Huffman</span>
<a name="l00652"></a>00652 <span class="comment">     * optimization or data output for the first scan.</span>
<a name="l00653"></a>00653 <span class="comment">     */</span>
<a name="l00654"></a>00654     select_scan_parameters(cinfo);
<a name="l00655"></a>00655     per_scan_setup(cinfo);
<a name="l00656"></a>00656     <span class="keywordflow">if</span> (! cinfo-&gt;raw_data_in) {
<a name="l00657"></a>00657       (*cinfo-&gt;cconvert-&gt;start_pass) (cinfo);
<a name="l00658"></a>00658       (*cinfo-&gt;downsample-&gt;start_pass) (cinfo);
<a name="l00659"></a>00659       (*cinfo-&gt;prep-&gt;start_pass) (cinfo, JBUF_PASS_THRU);
<a name="l00660"></a>00660     }
<a name="l00661"></a>00661     (*cinfo-&gt;fdct-&gt;start_pass) (cinfo);
<a name="l00662"></a>00662     (*cinfo-&gt;entropy-&gt;start_pass) (cinfo, cinfo-&gt;optimize_coding);
<a name="l00663"></a>00663     (*cinfo-&gt;coef-&gt;start_pass) (cinfo,
<a name="l00664"></a>00664                 (master-&gt;total_passes &gt; 1 ?
<a name="l00665"></a>00665                  JBUF_SAVE_AND_PASS : JBUF_PASS_THRU));
<a name="l00666"></a>00666     (*cinfo-&gt;main-&gt;start_pass) (cinfo, JBUF_PASS_THRU);
<a name="l00667"></a>00667     <span class="keywordflow">if</span> (cinfo-&gt;optimize_coding) {
<a name="l00668"></a>00668       <span class="comment">/* No immediate data output; postpone writing frame/scan headers */</span>
<a name="l00669"></a>00669       master-&gt;pub.call_pass_startup = FALSE;
<a name="l00670"></a>00670     } <span class="keywordflow">else</span> {
<a name="l00671"></a>00671       <span class="comment">/* Will write frame/scan headers at first jpeg_write_scanlines call */</span>
<a name="l00672"></a>00672       master-&gt;pub.call_pass_startup = TRUE;
<a name="l00673"></a>00673     }
<a name="l00674"></a>00674     <span class="keywordflow">break</span>;
<a name="l00675"></a>00675 <span class="preprocessor">#ifdef ENTROPY_OPT_SUPPORTED</span>
<a name="l00676"></a>00676 <span class="preprocessor"></span>  <span class="keywordflow">case</span> huff_opt_pass:
<a name="l00677"></a>00677     <span class="comment">/* Do Huffman optimization for a scan after the first one. */</span>
<a name="l00678"></a>00678     select_scan_parameters(cinfo);
<a name="l00679"></a>00679     per_scan_setup(cinfo);
<a name="l00680"></a>00680     <span class="keywordflow">if</span> (cinfo-&gt;Ss != 0 || cinfo-&gt;Ah == 0) {
<a name="l00681"></a>00681       (*cinfo-&gt;entropy-&gt;start_pass) (cinfo, TRUE);
<a name="l00682"></a>00682       (*cinfo-&gt;coef-&gt;start_pass) (cinfo, JBUF_CRANK_DEST);
<a name="l00683"></a>00683       master-&gt;pub.call_pass_startup = FALSE;
<a name="l00684"></a>00684       <span class="keywordflow">break</span>;
<a name="l00685"></a>00685     }
<a name="l00686"></a>00686     <span class="comment">/* Special case: Huffman DC refinement scans need no Huffman table</span>
<a name="l00687"></a>00687 <span class="comment">     * and therefore we can skip the optimization pass for them.</span>
<a name="l00688"></a>00688 <span class="comment">     */</span>
<a name="l00689"></a>00689     master-&gt;pass_type = output_pass;
<a name="l00690"></a>00690     master-&gt;pass_number++;
<a name="l00691"></a>00691     <span class="comment">/*FALLTHROUGH*/</span>
<a name="l00692"></a>00692 <span class="preprocessor">#endif</span>
<a name="l00693"></a>00693 <span class="preprocessor"></span>  <span class="keywordflow">case</span> output_pass:
<a name="l00694"></a>00694     <span class="comment">/* Do a data-output pass. */</span>
<a name="l00695"></a>00695     <span class="comment">/* We need not repeat per-scan setup if prior optimization pass did it. */</span>
<a name="l00696"></a>00696     <span class="keywordflow">if</span> (! cinfo-&gt;optimize_coding) {
<a name="l00697"></a>00697       select_scan_parameters(cinfo);
<a name="l00698"></a>00698       per_scan_setup(cinfo);
<a name="l00699"></a>00699     }
<a name="l00700"></a>00700     (*cinfo-&gt;entropy-&gt;start_pass) (cinfo, FALSE);
<a name="l00701"></a>00701     (*cinfo-&gt;coef-&gt;start_pass) (cinfo, JBUF_CRANK_DEST);
<a name="l00702"></a>00702     <span class="comment">/* We emit frame/scan headers now */</span>
<a name="l00703"></a>00703     <span class="keywordflow">if</span> (master-&gt;scan_number == 0)
<a name="l00704"></a>00704       (*cinfo-&gt;marker-&gt;write_frame_header) (cinfo);
<a name="l00705"></a>00705     (*cinfo-&gt;marker-&gt;write_scan_header) (cinfo);
<a name="l00706"></a>00706     master-&gt;pub.call_pass_startup = FALSE;
<a name="l00707"></a>00707     <span class="keywordflow">break</span>;
<a name="l00708"></a>00708   <span class="keywordflow">default</span>:
<a name="l00709"></a>00709     ERREXIT(cinfo, JERR_NOT_COMPILED);
<a name="l00710"></a>00710   }
<a name="l00711"></a>00711 
<a name="l00712"></a>00712   master-&gt;pub.is_last_pass = (master-&gt;pass_number == master-&gt;total_passes-1);
<a name="l00713"></a>00713 
<a name="l00714"></a>00714   <span class="comment">/* Set up progress monitor&#39;s pass info if present */</span>
<a name="l00715"></a>00715   <span class="keywordflow">if</span> (cinfo-&gt;progress != NULL) {
<a name="l00716"></a>00716     cinfo-&gt;progress-&gt;completed_passes = master-&gt;pass_number;
<a name="l00717"></a>00717     cinfo-&gt;progress-&gt;total_passes = master-&gt;total_passes;
<a name="l00718"></a>00718   }
<a name="l00719"></a>00719 }
<a name="l00720"></a>00720 
<a name="l00721"></a>00721 
<a name="l00722"></a>00722 <span class="comment">/*</span>
<a name="l00723"></a>00723 <span class="comment"> * Special start-of-pass hook.</span>
<a name="l00724"></a>00724 <span class="comment"> * This is called by jpeg_write_scanlines if call_pass_startup is TRUE.</span>
<a name="l00725"></a>00725 <span class="comment"> * In single-pass processing, we need this hook because we don&#39;t want to</span>
<a name="l00726"></a>00726 <span class="comment"> * write frame/scan headers during jpeg_start_compress; we want to let the</span>
<a name="l00727"></a>00727 <span class="comment"> * application write COM markers etc. between jpeg_start_compress and the</span>
<a name="l00728"></a>00728 <span class="comment"> * jpeg_write_scanlines loop.</span>
<a name="l00729"></a>00729 <span class="comment"> * In multi-pass processing, this routine is not used.</span>
<a name="l00730"></a>00730 <span class="comment"> */</span>
<a name="l00731"></a>00731 
<a name="l00732"></a>00732 METHODDEF(<span class="keywordtype">void</span>)
<a name="l00733"></a>00733 pass_startup (j_compress_ptr cinfo)
<a name="l00734"></a>00734 {
<a name="l00735"></a>00735   cinfo-&gt;master-&gt;call_pass_startup = FALSE; <span class="comment">/* reset flag so call only once */</span>
<a name="l00736"></a>00736 
<a name="l00737"></a>00737   (*cinfo-&gt;marker-&gt;write_frame_header) (cinfo);
<a name="l00738"></a>00738   (*cinfo-&gt;marker-&gt;write_scan_header) (cinfo);
<a name="l00739"></a>00739 }
<a name="l00740"></a>00740 
<a name="l00741"></a>00741 
<a name="l00742"></a>00742 <span class="comment">/*</span>
<a name="l00743"></a>00743 <span class="comment"> * Finish up at end of pass.</span>
<a name="l00744"></a>00744 <span class="comment"> */</span>
<a name="l00745"></a>00745 
<a name="l00746"></a>00746 METHODDEF(<span class="keywordtype">void</span>)
<a name="l00747"></a>00747 finish_pass_master (j_compress_ptr cinfo)
<a name="l00748"></a>00748 {
<a name="l00749"></a>00749   <a class="code" href="structmy__comp__master.html">my_master_ptr</a> master = (<a class="code" href="structmy__comp__master.html">my_master_ptr</a>) cinfo-&gt;master;
<a name="l00750"></a>00750 
<a name="l00751"></a>00751   <span class="comment">/* The entropy coder always needs an end-of-pass call,</span>
<a name="l00752"></a>00752 <span class="comment">   * either to analyze statistics or to flush its output buffer.</span>
<a name="l00753"></a>00753 <span class="comment">   */</span>
<a name="l00754"></a>00754   (*cinfo-&gt;entropy-&gt;finish_pass) (cinfo);
<a name="l00755"></a>00755 
<a name="l00756"></a>00756   <span class="comment">/* Update state for next pass */</span>
<a name="l00757"></a>00757   <span class="keywordflow">switch</span> (master-&gt;pass_type) {
<a name="l00758"></a>00758   <span class="keywordflow">case</span> main_pass:
<a name="l00759"></a>00759     <span class="comment">/* next pass is either output of scan 0 (after optimization)</span>
<a name="l00760"></a>00760 <span class="comment">     * or output of scan 1 (if no optimization).</span>
<a name="l00761"></a>00761 <span class="comment">     */</span>
<a name="l00762"></a>00762     master-&gt;pass_type = output_pass;
<a name="l00763"></a>00763     <span class="keywordflow">if</span> (! cinfo-&gt;optimize_coding)
<a name="l00764"></a>00764       master-&gt;scan_number++;
<a name="l00765"></a>00765     <span class="keywordflow">break</span>;
<a name="l00766"></a>00766   <span class="keywordflow">case</span> huff_opt_pass:
<a name="l00767"></a>00767     <span class="comment">/* next pass is always output of current scan */</span>
<a name="l00768"></a>00768     master-&gt;pass_type = output_pass;
<a name="l00769"></a>00769     <span class="keywordflow">break</span>;
<a name="l00770"></a>00770   <span class="keywordflow">case</span> output_pass:
<a name="l00771"></a>00771     <span class="comment">/* next pass is either optimization or output of next scan */</span>
<a name="l00772"></a>00772     <span class="keywordflow">if</span> (cinfo-&gt;optimize_coding)
<a name="l00773"></a>00773       master-&gt;pass_type = huff_opt_pass;
<a name="l00774"></a>00774     master-&gt;scan_number++;
<a name="l00775"></a>00775     <span class="keywordflow">break</span>;
<a name="l00776"></a>00776   }
<a name="l00777"></a>00777 
<a name="l00778"></a>00778   master-&gt;pass_number++;
<a name="l00779"></a>00779 }
<a name="l00780"></a>00780 
<a name="l00781"></a>00781 
<a name="l00782"></a>00782 <span class="comment">/*</span>
<a name="l00783"></a>00783 <span class="comment"> * Initialize master compression control.</span>
<a name="l00784"></a>00784 <span class="comment"> */</span>
<a name="l00785"></a>00785 
<a name="l00786"></a>00786 GLOBAL(<span class="keywordtype">void</span>)
<a name="l00787"></a>00787 jinit_c_master_control (j_compress_ptr cinfo, <span class="keywordtype">boolean</span> transcode_only)
<a name="l00788"></a>00788 {
<a name="l00789"></a>00789   <a class="code" href="structmy__comp__master.html">my_master_ptr</a> master;
<a name="l00790"></a>00790 
<a name="l00791"></a>00791   master = (<a class="code" href="structmy__comp__master.html">my_master_ptr</a>)
<a name="l00792"></a>00792       (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
<a name="l00793"></a>00793                   SIZEOF(<a class="code" href="structmy__comp__master.html">my_comp_master</a>));
<a name="l00794"></a>00794   cinfo-&gt;master = (<span class="keyword">struct </span><a class="code" href="structjpeg__comp__master.html">jpeg_comp_master</a> *) master;
<a name="l00795"></a>00795   master-&gt;pub.prepare_for_pass = prepare_for_pass;
<a name="l00796"></a>00796   master-&gt;pub.pass_startup = pass_startup;
<a name="l00797"></a>00797   master-&gt;pub.finish_pass = finish_pass_master;
<a name="l00798"></a>00798   master-&gt;pub.is_last_pass = FALSE;
<a name="l00799"></a>00799 
<a name="l00800"></a>00800   <span class="comment">/* Validate parameters, determine derived values */</span>
<a name="l00801"></a>00801   initial_setup(cinfo, transcode_only);
<a name="l00802"></a>00802 
<a name="l00803"></a>00803   <span class="keywordflow">if</span> (cinfo-&gt;scan_info != NULL) {
<a name="l00804"></a>00804 <span class="preprocessor">#ifdef C_MULTISCAN_FILES_SUPPORTED</span>
<a name="l00805"></a>00805 <span class="preprocessor"></span>    validate_script(cinfo);
<a name="l00806"></a>00806     <span class="keywordflow">if</span> (cinfo-&gt;block_size &lt; DCTSIZE)
<a name="l00807"></a>00807       reduce_script(cinfo);
<a name="l00808"></a>00808 <span class="preprocessor">#else</span>
<a name="l00809"></a>00809 <span class="preprocessor"></span>    ERREXIT(cinfo, JERR_NOT_COMPILED);
<a name="l00810"></a>00810 <span class="preprocessor">#endif</span>
<a name="l00811"></a>00811 <span class="preprocessor"></span>  } <span class="keywordflow">else</span> {
<a name="l00812"></a>00812     cinfo-&gt;progressive_mode = FALSE;
<a name="l00813"></a>00813     cinfo-&gt;num_scans = 1;
<a name="l00814"></a>00814   }
<a name="l00815"></a>00815 
<a name="l00816"></a>00816   <span class="keywordflow">if</span> ((cinfo-&gt;progressive_mode || cinfo-&gt;block_size &lt; DCTSIZE) &amp;&amp;
<a name="l00817"></a>00817       !cinfo-&gt;arith_code)           <span class="comment">/*  TEMPORARY HACK ??? */</span>
<a name="l00818"></a>00818     <span class="comment">/* assume default tables no good for progressive or downscale mode */</span>
<a name="l00819"></a>00819     cinfo-&gt;optimize_coding = TRUE;
<a name="l00820"></a>00820 
<a name="l00821"></a>00821   <span class="comment">/* Initialize my private state */</span>
<a name="l00822"></a>00822   <span class="keywordflow">if</span> (transcode_only) {
<a name="l00823"></a>00823     <span class="comment">/* no main pass in transcoding */</span>
<a name="l00824"></a>00824     <span class="keywordflow">if</span> (cinfo-&gt;optimize_coding)
<a name="l00825"></a>00825       master-&gt;pass_type = huff_opt_pass;
<a name="l00826"></a>00826     <span class="keywordflow">else</span>
<a name="l00827"></a>00827       master-&gt;pass_type = output_pass;
<a name="l00828"></a>00828   } <span class="keywordflow">else</span> {
<a name="l00829"></a>00829     <span class="comment">/* for normal compression, first pass is always this type: */</span>
<a name="l00830"></a>00830     master-&gt;pass_type = main_pass;
<a name="l00831"></a>00831   }
<a name="l00832"></a>00832   master-&gt;scan_number = 0;
<a name="l00833"></a>00833   master-&gt;pass_number = 0;
<a name="l00834"></a>00834   <span class="keywordflow">if</span> (cinfo-&gt;optimize_coding)
<a name="l00835"></a>00835     master-&gt;total_passes = cinfo-&gt;num_scans * 2;
<a name="l00836"></a>00836   <span class="keywordflow">else</span>
<a name="l00837"></a>00837     master-&gt;total_passes = cinfo-&gt;num_scans;
<a name="l00838"></a>00838 }
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
